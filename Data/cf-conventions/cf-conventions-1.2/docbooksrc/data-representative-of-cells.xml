<chapter>
	<title>
		Data Representative of Cells
	</title>

	<para>
		When gridded data does not represent the point values of
		a field but instead represents some characteristic of
		the field within cells of finite "volume," a complete
		description of the variable should include metadata
		that describes the domain or extent of each cell, and
		the characteristic of the field that the cell values
		represent. It is possible for a single data value to be
		the result of an operation whose domain is a disjoint set
		of cells. This is true for many types of climatological
		averages, for example, the mean January temperature for
		the years 1970-2000. The methods that we present below
		for describing cells only provides an association of
		a grid point with a single cell, not with a collection
		of cells. However, climatological statistics are of such
		importance that we provide special methods for describing
		their associated computational domains in <xref linkend="climatological-statistics"/>.
	</para>

	<section id="cell-boundaries">
		<title>Cell Boundaries</title>
		<para>
			To represent cells we add the attribute 
			<varname>bounds</varname>
			to the appropriate coordinate variable(s). The
			value of 
			<varname>bounds</varname>
			is the name of the variable that
			contains the vertices of the cell boundaries. We
			refer to this type of variable as a "boundary
			variable." 
			<emphasis>
				A boundary variable will have one more
				dimension than its associated coordinate
				or auxiliary coordinate variable.
			</emphasis> 
			The additional
			dimension should be the most rapidly varying
			one, and its size is the maximum number of cell
			vertices. Since a boundary variable is considered
			to be part of a coordinate variable's metadata,
			it is not necessary to provide it with attributes
			such as 
			<varname>long_name</varname>
			and 
			<varname>units</varname>.
		</para>
		<para>
			Note that the boundary variable for a set of
			N contiguous intervals is an array of shape
			(N,2). Although in this case there will be a
			duplication of the boundary coordinates between
			adjacent intervals, this representation has the
			advantage that it is general enough to handle,
			without modification, non-contiguous intervals,
			as well as intervals on an axis using the
			unlimited dimension.
		</para>
		<para>
			Applications that process cell boundary data often
			times need to determine whether or not adjacent
			cells share an edge. In order to facilitate this
			type of processing the following restrictions
			are placed on the data in boundary variables.
		</para>
		<para>
			<variablelist>
				<varlistentry>
					<term>Bounds for 1-D coordinate variables</term>
					<listitem>
						<para>
							For a coordinate variable such as <varname>lat(lat)</varname>
							with associated boundary variable <varname>latbnd(x,2)</varname>, the
							interval endpoints must be ordered consistently with
							the associated coordinate, e.g., for an increasing
							coordinate, <varname>lat(1)</varname> > <varname>lat(0)</varname>
                            implies <varname>latbnd(i,1)</varname> >= <varname>latbnd(i,0)</varname>
                            for all <varname>i</varname>
						</para>
						<para>
							If adjacent intervals are contiguous,
							the shared endpoint must be represented
							indentically in each instance where it occurs
							in the boundary variable. For example, if the
							intervals that contain grid points <varname>lat(i)</varname>
							and <varname>lat(i+1)</varname> are contiguous,
                            then <varname>latbnd(i+1,0)</varname> = <varname>latbnd(i,1)</varname>.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Bounds for 2-D coordinate variables with 4-sided cells</term>
					<listitem>
						<para>
							In the case where the horizontal grid is described
							by two-dimensional auxiliary coordinate
							variables in latitude <varname>lat(n,m)</varname> and longitude
							<varname>lon(n,m)</varname>, and the associated cells are four-sided,
							then the boundary variables are given in the form
							<varname>latbnd(n,m,4)</varname> and <varname>lonbnd(n,m,4)</varname>, where the trailing
							index runs over the four vertices of the cells. Let
							us call the side of cell <varname>(j,i)</varname>
                            facing cell <varname>(j,i-1)</varname>
							the "<varname>i-1</varname>" side, the side facing cell
                            <varname>(j,i+1)</varname>
							the "<varname>i+1</varname>" side, and similarly for "<varname>j-1</varname>" and
							"<varname>j+1</varname>". Then we can refer to the vertex formed by
							sides <varname>i-1</varname> and <varname>j-1</varname>
                            as <varname>(j-1,i-1)</varname>. With this notation,
							the four vertices are indexed as follows:
							<varname>0=(j-1,i-1)</varname>,
							<varname>1=(j-1,i+1)</varname>,
							<varname>2=(j+1,i+1)</varname>,
							<varname>3=(j+1,i-1)</varname>.
						</para>
						<para>
							If i-j-upward is a right-handed coordinate system (like
							lon-lat-upward), this ordering means the vertices will be traversed
							anticlockwise on the lon-lat surface seen from above. If
							i-j-upward is left-handed, they will be traversed clockwise on the
							lon-lat surface.
						</para>
						<para>
							The bounds can be used to decide whether cells are contiguous
							via the following relationships. In these equations the variable
							<varname>bnd</varname> is used generically to represent either the latitude
							or longitude boundary variable.
							<programlisting>
For 0 &lt; j &lt; n and 0 &lt; i &lt; m,
	If cells (j,i) and (j,i+1) are contiguous, then
		bnd(j,i,1)=bnd(j,i+1,0) 
		bnd(j,i,2)=bnd(j,i+1,3)
	If cells (j,i) and (j+1,i) are contiguous, then	
		bnd(j,i,3)=bnd(j+1,i,0) and bnd(j,i,2)=bnd(j+1,i,1)
							</programlisting>
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Bounds for multi-dimensional coordinate variables with p-sided cells</term>
					<listitem>
						<para>
							In all other cases, the bounds should be dimensioned <varname>(...,n,p)</varname>, where
							<varname>(...,n)</varname> are the dimensions of the auxiliary coordinate variables, and
							<varname>p</varname> the number of vertices of the cells. The vertices must be traversed
							anticlockwise in the lon-lat plane as viewed from above. The starting vertex
							is not specified.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>

		<para>
			<example>
				<title> Cells on a latitude axis</title>
				<para>
					<programlisting>
dimensions:
  lat = 64;
  nv = 2;    // number of vertices
variables:
  float lat(lat);
    lat:long_name = "latitude";
    lat:units = "degrees_north";
    lat:bounds = "lat_bnds";
  float lat_bnds(lat,nv);
					</programlisting>
				</para>
				<para>
					The boundary variable <varname>lat_bnds</varname> associates a latitude gridpoint
					<varname>i</varname> with the interval whose boundaries are <varname>lat_bnds(i,0)</varname> and
					<varname>lat_bnds(i,1)</varname>. The gridpoint location, <varname>lat(i)</varname>, should be
					contained within this interval.
				</para>
			</example>
		</para>
		<para>
			For rectangular grids, two-dimensional cells
			can be expressed as Cartesian products of
			one-dimensional cells of the type in the preceding
			example. However for non-rectangular grids a
			"rectangular" cell will in general require
			specifying all four vertices for each cell.
		</para>
		<para>
			<example>
				<title> Cells in a non-rectangular grid</title>
				<para>
					<programlisting>
dimensions:
  imax = 128;
  jmax = 64;
  nv = 4;
variables:
  float lat(jmax,imax);
    lat:long_name = "latitude";
    lat:units = "degrees_north";
    lat:bounds = "lat_bnds";
  float lon(jmax,imax);
    lon:long_name = "longitude";
    lon:units = "degrees_east";
    lon:bounds = "lon_bnds";
  float lat_bnds(jmax,imax,nv);
  float lon_bnds(jmax,imax,nv);
					</programlisting>
				</para>
				<para>
					The boundary variables <varname>lat_bnds</varname>
					and <varname>lon_bnds</varname> associate a
					gridpoint <varname>(j,i)</varname> with the cell
					determined by the vertices
					<varname>(lat_bnds(j,i,n),lon_bnds(j,i,n))</varname>,
					<varname>n=0,..,3</varname>. The gridpoint location,
					<varname>(lat(j,i),lon(j,i))</varname>, should be
					contained within this region.
				</para>
			</example>
		</para>
	</section>




	<section id="cell-measures">
		<title>Cell Measures</title>
		<para>
			For some calculations, information is needed
			about the size, shape or location of the cells
			that cannot be deduced from the coordinates and
			bounds without special knowledge that a generic
			application cannot be expected to have. For
			instance, in computing the mean of several cell
			values, it is often appropriate to "weight" the
			values by area. When computing an area-mean each
			grid cell value is multiplied by the grid-cell
			area before summing, and then the sum is divided
			by the sum of the grid-cell areas. Area weights
			may also be needed to map data from one grid to
			another in such a way as to preserve the area
			mean of the field. The preservation of area-mean
			values while regridding may be essential, for
			example, when calculating surface heat fluxes
			in an atmospheric model with a grid that differs
			from the ocean model grid to which it is coupled.
		</para>
		<para>
			In many cases the areas can be calculated from the
			cell bounds, but there are exceptions. Consider,
			for example, a spherical geodesic grid composed
			of contiguous, roughly hexagonal cells. The
			vertices of the cells can be stored in the
			variable identified by the 
			<varname>bounds </varname> 
			attribute,
			but the cell perimeter is not uniquely defined
			by its vertices (because the vertices could, for
			example, be connected by straight lines, or, on
			a sphere, by lines following a great circle, or,
			in general, in some other way). Thus, given the
			cell vertices alone, it is generally impossible
			to calculate the area of a grid cell. This is
			why it may be necessary to store the grid-cell
			areas in addition to the cell vertices.
		</para>
		<para>
			In other cases, the grid cell-volume might be
			needed and might not be easily calculated from
			the coordinate information. In ocean models, for
			example, it is not uncommon to find "partial" grid
			cells at the bottom of the ocean. In this case,
			rather than (or in addition to) indicating grid
			cell area, it may be necessary to indicate volume.
		</para>
		<para>
			To indicate extra information about the
			spatial properties of a variable's grid cells,
			a 
			<varname>cell_measures</varname> 
			attribute may be defined for a
			variable. This is a string attribute comprising
			a list of blank-separated pairs of words of the
			form "<varname>measure: name</varname>".
            For the moment, "<varname>area</varname>" and
			"<varname>volume</varname>" are the only defined measures, but others
			may be supported in future. The "name" is the name
			of the variable containing the measure values,
			which we refer to as a "measure variable". The
			dimensions of the measure variable should be
			the same as or a subset of the dimensions of
			the variable to which they are related, but
			their order is not restricted. In the case of
			area, for example, the field itself might be a
			function of longitude, latitude, and time, but
			the variable containing the area values would
			only include longitude and latitude dimensions
			(and the dimension order could be reversed,
			although this is not recommended). The variable
			must have a 
			<varname>units</varname>
			attribute and may have other
			attributes such as a 
			<varname>standard_name</varname>.
		</para>
		<para>
			For rectangular longitude-latitude grids, the
			area of grid cells can be calculated from the
			bounds: the area of a cell is proportional to the
			product of the difference in the longitude bounds
			of the cell and the difference between the sine
			of each latitude bound of the cell. In this case
			supplying grid-cell areas via the 
			<varname>cell_measures</varname>
			attribute is unnecessary because it may be assumed
			that applications can perform this calculation,
			using their own value for the radius of the Earth.
		</para>
		<para>
			<example>
				<title> Cell areas for a spherical geodesic grid</title>
				<para>
					<programlisting>
dimensions:
  cell = 2562 ;  // number of grid cells
  time = 12 ;
  nv = 6 ;       // maximum number of cell vertices 
variables:
  float PS(time,cell) ;
    PS:units = "Pa" ;
    PS:coordinates = "lon lat" ;
    PS:cell_measures = "area: cell_area" ;
  float lon(cell) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
    lon:bounds="lon_vertices" ;
  float lat(cell) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
    lat:bounds="lat_vertices" ;
  float time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1979-01-01 0:0:0" ;
  float cell_area(cell) ;
    cell_area:long_name = "area of grid cell" ;
    cell_area:standard_name="area";
    cell_area:units = "m2"
  float lon_vertices(cell,nv) ;
  float lat_vertices(cell,nv) ;
					</programlisting>
				</para>
			</example>
		</para>
	</section>






	<section id="cell-methods">
		<title>Cell Methods</title>
		<para>
			To describe the characteristic of a field that
			is represented by cell values we define the
			<varname>cell_methods</varname>
			attribute of the variable. This
			is a string attribute comprising a list
			of blank-separated words of the form "<varname>name:
			method</varname>". Each "<varname>name: method</varname>" pair indicates that
			for the axis identified by <varname>name</varname>, the cell values
			representing the field have been determined or
			derived by the specified <varname>method</varname>. The token name
			can be a dimension of the variable, a scalar
			coordinate variable, or a valid standard name. The
			values of <varname>method</varname> should be selected from the list
			in 
			<xref linkend="appendix-cell-methods"/>, 
			which includes 
			<constant>point</constant>, 
			<constant>sum</constant>, 
			<constant>mean</constant>, 
			<constant>maximum</constant>, 
			<constant>minimum</constant>, 
			<constant>mid_range</constant>, 
			<constant>standard_deviation</constant>, 
			<constant>variance</constant>, 
			<constant>mode</constant>, 
			and
			<constant>median</constant>. 
			Case is not
			significant in the method name. Some methods
			(e.g., <constant>variance</constant>) 
			imply a change of units of
			the variable, and this also is specified by
			<xref linkend="dimensionless-v-coord"/>. 
			It must be remembered that the
			method applies only to the axis indicated, and
			different methods may apply to other axes. If
			a precipitation value in a longitude-latitude
			cell is given the method maximum for these axes,
			for instance, it means that it is the maximum
			within these spatial cells, and does not imply
			that it is also the maximum in time.
		</para>
		<para>
			The default interpretation for variables that
			have cells associated with their grid points,
			but do not have the 
			<varname>cell_methods</varname>
			attribute
			specified, depends on whether the quantity is
			extensive (which depends on the size of the cell)
			or intensive (which doesn't). So, for example,
			suppose the quantities "accumulated precipitation"
			and "precipitation rate" each have a time axis
			and that time intervals are associated with each
			point on the time axis via a boundary variable. A
			variable representing accumulated precipitation
			is extensive in time and requires a time interval
			to be completely specified. Hence its default
			interpretation should be that the cell associated
			with the grid point represents the time interval
			over which the precipitation was accumulated. This
			is indicated explicitly by setting the cell method
			to <varname>sum</varname>. A precipitation rate on the other hand is
			intensive in time and could equally well represent
			an instantaneous value or a mean value over the
			time interval specified by the cell. However,
			if the <varname>mean</varname> method is not specified then the
			default interpretation for the quantity would be
			instantaneous. The default method is indicated
			explicity by setting the cell method to <varname>point</varname>.
		</para>
		<para>
			<example>
				<title> Methods applied to a timeseries </title>
				<para>
					 Consider 12-hourly timeseries of pressure, temperature and
					 precipitation from a number of stations, where pressure
					 is measured instantaneously, maximum temperature for the
					 preceding 12 hours is recorded, and precipitation is accumulated
					 in a rain gauge. For a period of 48 hours from 6 a.m. on
					 19 April 1998, the data is structured as follows:
				</para>
				<para>
					<programlisting>
dimensions:
  time = UNLIMITED; // (5 currently)
  station = 10;
  nv = 2;
variables:
  float pressure(station,time);
    pressure:long_name = "pressure";
    pressure:units = "kPa";
  float maxtemp(station,time);
    maxtemp:long_name = "temperature";
    maxtemp:units = "K";
    maxtemp:cell_methods = "time: maximum";
  float ppn(station,time);
    ppn:long_name = "depth of water-equivalent precipitation";
    ppn:units = "mm";
  double time(time);
    time:long_name = "time";
    time:units = "h since 1998-4-19 6:0:0";
    time:bounds = "time_bnds";
  double time_bnds(time,nv);
data:
  time = 0., 12., 24., 36., 48.;
  time_bnds = -12.,0., 0.,12., 12.,24., 24.,36., 36.,48.; 
					</programlisting>
				</para>
				<para>
					Note that in this example the
					time axis values coincide with
					the end of each interval. It is
					sometimes desirable, however, to
					use the midpoint of intervals as
					coordinate values for variables
					that are representative of an
					interval. An application may
					simply obtain the midpoint values
					by making use of the boundary
					data in <constant>time_bnds</constant>.
				</para>
			</example>
		</para>
        
        <para>
            If more than one cell method is to be indicated, they should be
            arranged in the order they were applied. The left-most operation
            is assumed to have been applied first. Suppose a quantity varies
            in both longitude and time (dimensions lon and time) within each
            gridbox. Values that represent the time-average of the zonal
            maximum are labelled <varname>cell_methods="lon: maximum time: mean"</varname>,
            i.e. find the largest value at each instant of time over all
            longitudes, then average these maxima over time; values of the
            zonal maximum of time-averages are labelled
            <varname>cell_methods="time: mean lon: maximum"</varname>. If the methods could
            have been applied in any order without affecting the outcome,
            they may be put in any order in the <varname>cell_methods</varname> attribute.
        </para>
        
        <para>
            If a data value is representative of variation over a combination
            of axes, a single method should be prefixed by the names of all
            the dimensions involved, whose order is immaterial. Dimensions
            should be grouped in this way only if there is an essential
            difference from treating them individually. For instance, the
            standard deviation of topographic height within a
            longitude-latitude gridbox would have
            <varname>cell_methods="lat: lon: standard_deviation"</varname>. This is not the
            same as
            <varname>cell_methods="lon: standard_deviation lat: standard_deviation"</varname>,
            which would mean finding the standard deviation along each
            parallel of latitude within the zonal extent of the gridbox,
            and then the standard deviation of these values over latitude.
        </para>
        
        <para>
            To indicate more precisely how the cell method was applied,
            extra information may be included in parentheses () after the
            identification of the method. This information includes
            standardized and non-standarized parts. Currently the only
            stardardized information is to provide the typical interval
            between the original data values to which the method was applied,
            in the situation where the present data values are statistically
            representative of original data values which had a finer spacing.
            The syntax is <varname>(interval: <emphasis>value unit</emphasis>)</varname>,
            where <varname><emphasis>value</emphasis></varname> is a numerical
            value and <varname><emphasis>unit</emphasis></varname>
            is a string that can be recognized by UNIDATA's
            Udunits package <biblioref linkend="udunits"/>.
            The <varname><emphasis>unit</emphasis></varname> does not have to be
            dimensionally equivalent to the unit of the corresponding
            dimension name, although it often will be. Recording the original
            interval is particularly important for standard deviations.
            For example, the standard deviation of daily values could be
            indicated by
            <varname>cell_methods="time: standard_deviation (interval: 1 day)"</varname>
            and of annual values
            <varname>cell_methods="time: standard_deviation (interval: 1 year)"</varname>.
        </para>
        
        <para>
            If the cell method applies to a combination of axes, they may
            have a common original interval
            e.g. <varname>cell_methods="lat: lon: standard_deviation (interval: 10 km)"</varname>.
            Alternatively, they may have separate intervals, which are
            matched to the names of axes by position
            e.g. <varname>cell_methods="lat: lon: standard_deviation (interval: 0.1 degree_N interval: 0.2 degree_E)"</varname>,
            in which 0.1 degree applies to latitude and 0.2 degree to longitude.
        </para>
        
        <para>
            If there is both standardized and non-standardized information,
            the non-standardized follows the standardized information and
            the keyword <varname>comment:</varname>. For instance, an area-weighted mean over
            latitude could be indicated as <varname>lat: mean (area-weighted)</varname>
            or <varname>lat: mean (interval: 1 degree_north comment: area-weighted)</varname>.
        </para>
        
        <para>
            A dimension of size one may be the result of "collapsing" an
            axis by some statistical operation, for instance by calculating
            a variance from time series data. We strongly recommend that
            dimensions of size one be retained and used to document the
            method and its domain.
        </para>
        
        		<para>
			<example>
				<title>Surface air temperature variance</title>
				<para>
					 The variance of the diurnal cycle on 1 January 1990
                     has been calculated from hourly instantaneous surface
                     air temperature measurments. The time dimension of size
                     one has been retained.
				</para>
				<para>
					<programlisting>
dimensions:
  lat=90;
  lon=180;
  time=1;
  nv=2;
variables:
  float TS_var(time,lat,lon);
    TS_var:long_name="surface air temperature variance"
    TS_var:units="K2";
    TS_var:cell_methods="time: variance (of hourly instantaneous)";
  float time(time);
    time:units="days since 1990-01-01 00:00:00";
    time:bounds="time_bnds";
  float time_bnds(time,nv);
data:
  time=.5;
  time_bnds=0.,1.;
					</programlisting>
				</para>
				<para>
                    Notice that a parenthesized comment in the
                    <varname>cell_methods</varname> attribute provides
                    the nature of the samples used to calculate the variance.
				</para>
			</example>
		</para>
        
        <para>
            The convention of specifying a cell method for a
            <varname>standard_name</varname> rather than for
            a dimension with a coordinate variable is to allow
            one to provide an indication that a particular cell
            method is relevant to the data without having to
            provide a precise description of the corresponding cell.
            There are two reasons for doing this.
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If the cell coordinate range cannot be precisely defined.
                    For example, the Levitus ocean climatology uses any data
                    that exists. It is a time mean but the time range
                    is not well defined, so cannot be stated.
                </para>
            </listitem>
            <listitem>
                <para>
                    For convenience, if the cell extends over all valid
                    coordinates. This is permitted only for the standard
                    names <varname>longitude</varname> and <varname>latitude</varname>. Methods specified
                    for these standard names are assumed to apply
                    to the complete range of longitude and latitude
                    respectively. If in addition the data variable has
                    a dimension with a corresponding labeled axis that
                    specifies a geographic region <xref linkend="geographic-regions"/>, the implied
                    range of longitude and latitude is the valid range
                    for each specified region.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>
            We recommend that whenever possible cell bounds should be
            supplied by giving the variable a dimension of size one
            and attaching bounds to the associated coordinate variable.
        </para>
        
	</section>


	<section id="climatological-statistics">
		<title>Climatological Statistics</title>
		<para>
			Climatological statistics may be derived from
			corresponding portions of the annual cycle
			in a set of years, e.g., the average January
			temperatures in the climatology of 1961-1990,
			where the values are derived by averaging the 30
			Januarys from the separate years. Portions of the
			climatological cycle are specified by references
			to dates within the calendar year. However,
			a calendar year is not a well-defined unit of
			time, because it differs between leap years and
			other years, and among calendars. Nonetheless for
			practical purposes we wish to compare statistics
			for months or seasons from different calendars,
			and to make climatologies from a mixture of leap
			years and other years. Hence we provide special
			conventions for indicating dates within the
			climatological year. Climatological statistics
			may also be derived from corresponding portions
			of a range of days, for instance the average
			temperature for each hour of the average day in
			April 1997. In addition the two concepts may
			be used at once, for instance to indicate not
			April 1997, but the average April of the five
			years 1995-1999.
		</para>
		<para>
			Climatological variables have a climatological
			time axis. Like an ordinary time axis, a
			climatological time axis may have a dimension
			of unity (for example, a variable containing the
			January average temperatures for 1961-1990), but
			often it will have several elements (for example,
			a climatological time axis with a dimension of
			12 for the climatological average temperatures in
			each month for 1961-1990, a dimension of 3 for the
			January mean temperatures for the three decades
			1961-1970, 1971-1980, 1981-1990, or a dimension of
			24 for the hours of an average day). Intervals of
			climatological time are conceptually different
			from ordinary time intervals; a given interval
			of climatological time represents a set
			of subintervals which are not necessarily
			contiguous. To indicate this difference, a
			climatological time coordinate variable does
			not have a 
			<varname>bounds</varname> 
			attribute. Instead, it has a
			<varname>climatology</varname>
			attribute, which names a variable
			with dimensions (n,2), n being the dimension of
			the climatological time axis. Using the units and
			calendar of the time coordinate variable, element
			(i,0) of the climatology variable specifies the
			beginning of the first subinterval and element
			(i,1) the end of the last subinterval used to
			evaluate the climatological statistics with index
			i in the time dimension. The time coordinates
			should be values that are representative
			of the climatological time intervals, such
			that an application which does not recognise
			climatological time will nonetheless be able to
			make a reasonable interpretation.
		</para>
		<para>
			The COARDS standard offers limited support
			for climatological time. For compatibility with
			COARDS, time coordinates should also be recognised
			as climatological if they have a 
			<varname>units</varname>
			attribute
			of time-units relative to midnight on 1 January
			in year 0 i.e. <varname>since 0-1-1</varname> in udunits syntax , and
			provided they refer to the real-world calendar. We
			do not recommend this convention because (a)
			it does not provide any information about the
			intervals used to compute the climatology, and
			(b) there is no standard for how dates since year
			1 will be encoded with units having a reference
			time in year 0, since this year does not exist;
			consequently there may be inconsistencies among
			software packages in the interpretation of the
			time coordinates. Year 0 may be a valid year in
			non-real-world calendars, and therefore cannot be
			used to signal climatological time in such cases.
		</para>
		<para>
			A climatological axis may use different
			statistical methods to represent variation among
			years, within years and within days. For example,
			the average January temperature in a climatology
			is obtained by averaging both within years and
			over years. This is different from the average
			January-maximum temperature and the maximum
			January-average temperature. For the former,
			we first calculate the maximum temperature in
			each January, then average these maxima; for the
			latter, we first calculate the average temperature
			in each January, then find the largest one. As
			usual, the statistical operations are recorded
			in the 
			<varname>cell_methods</varname>
			attribute, which may have
			two or three entries for the climatological
			time dimension.
		</para>
		<para>
			Valid values of the 
			<varname>cell_methods</varname> attribute must be
			in one of the forms from the following list. The
			intervals over which various statistical methods
			are applied are determined by decomposing the date
			and time specifications of the climatological time
			bounds of a cell, as recorded in the variable
			named by the 
			<varname>climatology</varname>
			attribute. (The date
			and time specifications must be calculated from
			the time coordinates expressed in units of "time
			interval since reference date and time".) In the
			descriptions that follow we use the abbreviations
			<emphasis>y</emphasis>,
            <emphasis>m</emphasis>,
            <emphasis>d</emphasis>,
            <emphasis>H</emphasis>,
            <emphasis>M</emphasis>,
            and <emphasis>S</emphasis> for year, month, day, hour,
			minute, and second respectively. The suffix <emphasis>0</emphasis>
			indicates the earlier bound and <emphasis>1</emphasis> the latter.
			<variablelist>
				<varlistentry>
						<term>time: method1 <varname>within years</varname> &nbsp; time: method2 <varname>over years</varname></term>
					<listitem>
						<para>
							<emphasis>method1</emphasis> is applied to the time intervals 
							(mdHMS0-mdHMS1) within individual years 
							and
							<emphasis>method2</emphasis> is applied over the range of years (y0-y1). 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>time: method1 <varname>within days</varname> &nbsp; time: method2 <varname>over days</varname></term>
					<listitem>
						<para>
							<emphasis>method1</emphasis> is applied to the time intervals 
							(HMS0-HMS1) within individual days 
							and
							<emphasis>method2</emphasis> is applied over the days in
							the interval (ymd0-ymd1). 
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
						<term>time: method1 <varname>within days</varname> &nbsp; time: method2 <varname>over days</varname> &nbsp; time: method3 <varname>over years</varname></term>
					<listitem>
						<para>
							<emphasis>method1</emphasis> is applied to the time intervals 
							(HMS0-HMS1) within individual days 
							and
							<emphasis>method2</emphasis> is applied over the days in
							the interval (md0-md1), and <emphasis>method3</emphasis> is applied over the range of years (y0-y1). 
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>
		<para>
			The methods which can be specified are those
			listed in <xref linkend="appendix-cell-methods"/> and each entry in the
			<varname>cell_methods</varname>
			attribute may also, as usual, contain
			non-standardised information in parentheses after
			the method. For instance, a mean over ENSO years
			might be indicated by 
			"<computeroutput>time: mean over years (ENSO years)</computeroutput>".
		</para>
		<para>
			When considering intervals within years, if the
			earlier climatological time bound is later in the
			year than the later climatological time bound, it
			implies that the time intervals for the individual
			years run from each year across January 1 into the
			next year e.g. DJF intervals run from December 1
			0:00 to March 1 0:00. Analogous situations arise
			for daily intervals running across midnight from
			one day to the next.
		</para>
		<para>
			When considering intervals within days, if the
			earlier time of day is equal to the later time
			of day, then the method is applied to a full 24
			hour day.
		</para>
		<para>
			<emphasis>
				We have tried to make the examples in
				this section easier to understand by
				translating all time coordinate values
				to date and time formats. This is not
				currently valid CDL syntax.
			</emphasis>
		</para>
		<para>
			<example>
				<title>Climatological seasons</title>
				<para>
					This example shows the metadata
					for the average seasonal-minimum
					temperature for the four standard
					climatological seasons MAM JJA
					SON DJF, made from data for
					March 1960 to February 1991.
				</para>
				<para>
					<programlisting>
dimensions:
  time=4;
  nv=2;
variables:
  float temperature(time,lat,lon);
    temperature:long_name="surface air temperature";
    temperature:cell_methods="time: minimum within years time: mean over years";
    temperature:units="K";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 1960-1-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1960-4-16", "1960-7-16", "1960-10-16", "1961-1-16" ;
  climatology_bounds="1960-3-1",  "1990-6-1",
                     "1960-6-1",  "1990-9-1",
                     "1960-9-1",  "1990-12-1",
                     "1960-12-1", "1991-3-1" ;
					</programlisting>
				</para>
			</example>
		</para>
		<para>
			<example>
				<title>Decadal averages for January</title>
				<para>
					Average January precipitation
					totals are given for each of the
					decades 1961-1970, 1971-1980,
					1981-1990.
				</para>
				<para>
					<programlisting>
dimensions:
  time=3;
  nv=2;
variables:
  float precipitation(time,lat,lon);
    precipitation:long_name="precipitation amount";
    precipitation:cell_methods="time: sum within years time: mean over years";
    precipitation:units="kg m-2";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 1901-1-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1965-1-15", "1975-1-15", "1985-1-15" ;
  climatology_bounds="1961-1-1", "1970-2-1",
                     "1971-1-1", "1980-2-1",
                     "1981-1-1", "1990-2-1" ;

					</programlisting>
				</para>
			</example>
		</para>
		<para>
			<example>
				<title>Temperature for each hour of the average day</title>
				<para>
					Hourly average temperatures are given for April 1997. 
				</para>
				<para>
					<programlisting>
dimensions:
  time=24;
  nv=2;
variables:
  float temperature(time,lat,lon);
    temperature:long_name="surface air temperature";
    temperature:cell_methods="time: mean within days time: mean over days";
    temperature:units="K";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="hours since 1997-4-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1997-4-1 0:30", "1997-4-1 1:30", ... "1997-4-1 23:30" ;
  climatology_bounds="1997-4-1 0:00",  "1997-4-30 1:00",
                     "1997-4-1 1:00",  "1997-4-30 2:00",
                      ...
                      "1997-4-1 23:00", "1997-5-1 0:00" ;

					</programlisting>
				</para>
			</example>
		</para>
		<para>
			<example>
				<title>Temperature for each hour of the typical climatological day</title>
				<para>
					This is a modified version
					of the previous example. It
					now applies to April from a
					1961-1990 climatology.
				</para>
				<para>
					<programlisting>
variables:
  float temperature(time,lat,lon);
    temperature:long_name="surface air temperature";
    temperature:cell_methods="time: mean within days ",
      "time: mean over days time: mean over years";
    temperature:units="K";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 1961-1-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1961-4-1 0:30", "1961-4-1 1:30", ..., "1961-4-1 23:30" ;
  climatology_bounds="1961-4-1 0:00", "1990-4-30 1:00",
                     "1961-4-1 1:00", "1990-4-30 2:00",
                     ...
                     "1961-4-1 23:00", "1990-5-1 0:00" ;
					</programlisting>
				</para>
			</example>
		</para>
		<para>
			<example>
				<title>Monthly-maximum daily precipitation totals</title>
				<para>
					Maximum of daily precipitation
					amounts for each of the three
					months June, July and August 2000
					are given. The first daily total
					applies to 6 a.m. on 1 June to
					6 a.m. on 2 June, the 30th from
					6 a.m. on 30 June to 6 a.m. on
					1 July. The maximum of these 30
					values is stored under time index
					0 in the precipitation array.
				</para>
				<para>
					<programlisting>
dimensions:
  time=3;
  nv=2;
variables:
  float precipitation(time,lat,lon);
    precipitation:long_name="Accumulated precipitation";
    precipitation:cell_methods="time: sum within days time: maximum over days"; 
    precipitation:units="kg";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 2000-6-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="2000-6-16", "2000-7-16", "2000-8-16" ;
  climatology_bounds="2000-6-1 6:00:00", "2000-7-1 6:00:00",
                     "2000-7-1 6:00:00", "2000-8-1 6:00:00",
                     "2000-8-1 6:00:00", "2000-9-1 6:00:00" ;
					</programlisting>
				</para>
			</example>
		</para>
	</section>
</chapter>


