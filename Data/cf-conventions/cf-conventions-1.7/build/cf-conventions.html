<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>NetCDF Climate and Forecast (CF) Metadata Conventions</title><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><meta name="description" content="Abstract This document describes the CF conventions for climate and forecast metadata designed to promote the processing and sharing of files created with the netCDF Application Programmer Interface . The conventions define metadata that provide a definitive description of what the data in each variable represents, and of the spatial and temporal properties of the data. This enables users of data from different sources to decide which quantities are comparable, and facilitates building applications with powerful extraction, regridding, and display capabilities. The CF conventions generalize and extend the COARDS conventions . The extensions include metadata that provides a precise definition of each variable via specification of a standard name, describes the vertical locations corresponding to dimensionless vertical coordinate values, and provides the spatial coordinates of non-rectilinear gridded data. Since climate and forecast data are often not simply representative of points in space/time, other extensions provide for the description of coordinate intervals, multidimensional cells and climatological time coordinates, and indicate how a data value is representative of an interval or cell. This standard also relaxes the COARDS constraints on dimension order and specifies methods for reducing the size of datasets."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div></div><div><h2 class="subtitle">Version 1.7.2 <span class="bold"><strong>DRAFT</strong></span>, 28 March,
  2014</h2></div><div><div class="authorgroup"><h1 class="title"><a name="idp3700576"></a>Original Authors</h1><div class="author"><h3 class="author"><span class="firstname">Brian</span> <span class="surname">Eaton</span></h3><div class="affiliation"><span class="orgname">NCAR<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Gregory</span></h3><div class="affiliation"><span class="orgname">Hadley Centre, UK Met Office<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Bob</span> <span class="surname">Drach</span></h3><div class="affiliation"><span class="orgname">PCMDI, LLNL<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Karl</span> <span class="surname">Taylor</span></h3><div class="affiliation"><span class="orgname">PCMDI, LLNL<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Steve</span> <span class="surname">Hankin</span></h3><div class="affiliation"><span class="orgname">PMEL, NOAA<br></span></div></div></div></div><div><div class="authorgroup"><h1 class="title"><a name="idp3767568"></a>Additional Authors</h1><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Caron</span></h3><div class="affiliation"><span class="orgname">UCAR<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Rich</span> <span class="surname">Signell</span></h3><div class="affiliation"><span class="orgname">USGS<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Bentley</span></h3><div class="affiliation"><span class="orgname">Hadley Centre, UK Met Office<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Greg</span> <span class="surname">Rappa</span></h3><div class="affiliation"><span class="orgname">MIT<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Heinke</span> <span class="surname">Höck</span></h3><div class="affiliation"><span class="orgname">DKRZ<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Alison</span> <span class="surname">Pamment</span></h3><div class="affiliation"><span class="orgname">BADC<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Martin</span> <span class="surname">Juckes</span></h3><div class="affiliation"><span class="orgname">BADC<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Andrew</span> <span class="surname">Walsh</span></h3><div class="affiliation"><span class="orgname">METOC<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Graybeal</span></h3><div class="affiliation"><span class="orgname">TBD<br></span></div></div></div></div><div><div class="othercredit"><h3 class="othercredit"></h3><span class="contrib"><p> Many others have contributed to the development of CF
    through their participation in discussions about proposed changes.
    </p></span> </div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This document describes the CF conventions for climate and forecast
    metadata designed to promote the processing and sharing of files created
    with the netCDF Application Programmer Interface [<a href="#netcdf" class="biblioref" title="[NetCDF]"><abbr class="abbrev">NetCDF</abbr></a>]. The conventions define metadata that provide a
    definitive description of what the data in each variable represents, and
    of the spatial and temporal properties of the data. This enables users of
    data from different sources to decide which quantities are comparable, and
    facilitates building applications with powerful extraction, regridding,
    and display capabilities.</p><p>The CF conventions generalize and extend the COARDS conventions
    [<a href="#coards" class="biblioref" title="[COARDS]"><abbr class="abbrev">COARDS</abbr></a>]. The extensions include metadata that
    provides a precise definition of each variable via specification of a
    standard name, describes the vertical locations corresponding to
    dimensionless vertical coordinate values, and provides the spatial
    coordinates of non-rectilinear gridded data. Since climate and forecast
    data are often not simply representative of points in space/time, other
    extensions provide for the description of coordinate intervals,
    multidimensional cells and climatological time coordinates, and indicate
    how a data value is representative of an interval or cell. This standard
    also relaxes the COARDS constraints on dimension order and specifies
    methods for reducing the size of datasets.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#idp5649536">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idp5627168">1.1. Goals</a></span></dt><dt><span class="section"><a href="#terminology">1.2. Terminology</a></span></dt><dt><span class="section"><a href="#idp5721024">1.3. Overview</a></span></dt><dt><span class="section"><a href="#coards-relationship">1.4. Relationship to the COARDS Conventions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp5858512">2. NetCDF Files and Components</a></span></dt><dd><dl><dt><span class="section"><a href="#idp5822368">2.1. Filename</a></span></dt><dt><span class="section"><a href="#idp5824272">2.2. Data Types</a></span></dt><dt><span class="section"><a href="#idp5866720">2.3. Naming Conventions</a></span></dt><dt><span class="section"><a href="#dimensions">2.4. Dimensions</a></span></dt><dt><span class="section"><a href="#variables">2.5. Variables</a></span></dt><dd><dl><dt><span class="section"><a href="#missing-data">2.5.1. Missing Data<font style="background-color:#ffccff">, valid and actual
      range</font></a></span></dt></dl></dd><dt><span class="section"><a href="#idp5908160">2.6. Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#identification-of-conventions">2.6.1. Identification of Conventions</a></span></dt><dt><span class="section"><a href="#description-of-file-contents">2.6.2. Description of file contents</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#idp6032096">3. Description of the Data</a></span></dt><dd><dl><dt><span class="section"><a href="#units">3.1. Units</a></span></dt><dt><span class="section"><a href="#long-name">3.2. Long Name</a></span></dt><dt><span class="section"><a href="#standard-name">3.3. Standard Name</a></span></dt><dt><span class="section"><a href="#ancillary-data">3.4. Ancillary Data</a></span></dt><dt><span class="section"><a href="#flags">3.5. Flags</a></span></dt></dl></dd><dt><span class="chapter"><a href="#coordinate-types">4. 
    Coordinate Types
  </a></span></dt><dd><dl><dt><span class="section"><a href="#latitude-coordinate">4.1. Latitude Coordinate</a></span></dt><dt><span class="section"><a href="#longitude-coordinate">4.2. Longitude Coordinate</a></span></dt><dt><span class="section"><a href="#vertical-coordinate">4.3. Vertical (Height or Depth) Coordinate</a></span></dt><dd><dl><dt><span class="section"><a href="#idp6406048">4.3.1. Dimensional Vertical Coordinate</a></span></dt><dt><span class="section"><a href="#dimensionless-vertical-coordinate">4.3.2. Dimensionless Vertical Coordinate</a></span></dt></dl></dd><dt><span class="section"><a href="#time-coordinate">4.4. Time Coordinate</a></span></dt><dd><dl><dt><span class="section"><a href="#calendar">4.4.1. Calendar</a></span></dt></dl></dd><dt><span class="section"><a href="#discrete-axis">4.5. <font style="background-color:#ffccff">Discrete Axis</font></a></span></dt></dl></dd><dt><span class="chapter"><a href="#coordinate-system">5. Coordinate Systems</a></span></dt><dd><dl><dt><span class="section"><a href="#idp6655904">5.1. Independent Latitude, Longitude, Vertical, and Time Axes</a></span></dt><dt><span class="section"><a href="#idp6661440">5.2. Two-Dimensional Latitude, Longitude, Coordinate Variables</a></span></dt><dt><span class="section"><a href="#reduced-horizontal-grid">5.3. Reduced Horizontal Grid</a></span></dt><dt><span class="section"><a href="#idp6679280">5.4. <font style="background-color:#ffff88; text-decoration:line-through">Timeseries of Station
    Data</font></a></span></dt><dt><span class="section"><a href="#idp6687840">5.5. <font style="background-color:#ffff88; text-decoration:line-through">Trajectories</font></a></span></dt><dt><span class="section"><a href="#grid-mappings-and-projections">5.6. <font style="background-color:#ffff88; text-decoration:line-through">Grid Mappings and
    Projections</font><font style="background-color:#ffccff">Horizontal Coordinate
    Reference Systems, Grid Mappings, and Projections</font></a></span></dt><dd><dl><dt><span class="section"><a href="#idp6737680">5.6.1. <font style="background-color:#ffccff">Use of the CRS Well-known Text
      Format</font></a></span></dt></dl></dd><dt><span class="section"><a href="#scalar-coordinate-variables">5.7. Scalar Coordinate Variables</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp6904240">6. 
        Labels and Alternative Coordinates
    </a></span></dt><dd><dl><dt><span class="section"><a href="#labels">6.1. Labels</a></span></dt><dd><dl><dt><span class="section"><a href="#geographic-regions">6.1.1. Geographic Regions</a></span></dt></dl></dd><dt><span class="section"><a href="#alternative-coordinates">6.2. Alternative Coordinates</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp6898192">7. Data Representative of Cells</a></span></dt><dd><dl><dt><span class="section"><a href="#cell-boundaries">7.1. Cell Boundaries</a></span></dt><dt><span class="section"><a href="#cell-measures">7.2. Cell Measures</a></span></dt><dt><span class="section"><a href="#cell-methods">7.3. Cell Methods</a></span></dt><dd><dl><dt><span class="section"><a href="#statistics-more-than-one-axis">7.3.1. <font style="background-color:#ffccff">Statistics for more than one
      axis</font></a></span></dt><dt><span class="section"><a href="#recording-spacing-original-data">7.3.2. <font style="background-color:#ffccff">Recording the spacing of the original
      data and other information</font></a></span></dt><dt><span class="section"><a href="#statistics-applying-portions">7.3.3. 
        <font style="background-color:#ffccff">Statistics applying to portions of
        cells</font>
      </a></span></dt><dt><span class="section"><a href="#cell-methods-no-coordinates">7.3.4. <font style="background-color:#ffccff">Cell methods when there are no
      coordinates</font></a></span></dt></dl></dd><dt><span class="section"><a href="#climatological-statistics">7.4. Climatological Statistics</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp7390416">8. 
		Reduction of Dataset Size
	</a></span></dt><dd><dl><dt><span class="section"><a href="#packed-data">8.1. Packed Data</a></span></dt><dt><span class="section"><a href="#compression-by-gathering">8.2. Compression by Gathering</a></span></dt></dl></dd><dt><span class="chapter"><a href="#discrete-sampling-geometries">9. <font style="background-color:#ffccff">Discrete Sampling Geometries</font></a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7424512">9.1. Features and feature types</a></span></dt><dt><span class="sect1"><a href="#idp7520656">9.2. Collections, instances and elements</a></span></dt><dt><span class="sect1"><a href="#representations-features">9.3. Representations of collections of features in data variables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp7543328">9.3.1. Orthogonal multidimensional array representation</a></span></dt><dt><span class="sect2"><a href="#idp7587200">9.3.2.  Incomplete multidimensional array representation</a></span></dt><dt><span class="sect2"><a href="#idp7622336">9.3.3.  Contiguous ragged array representation</a></span></dt><dt><span class="sect2"><a href="#idp7666048">9.3.4. Indexed ragged array representation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#featureType">9.4. The featureType  attribute</a></span></dt><dt><span class="sect1"><a href="#coordinates-metadata">9.5. Coordinates and metadata</a></span></dt><dt><span class="sect1"><a href="#idp7736784">9.6. Missing Data</a></span></dt></dl></dd><dt><span class="appendix"><a href="#attribute-appendix">A. Attributes</a></span></dt><dt><span class="appendix"><a href="#standard-name-table-format">B. Standard Name Table Format</a></span></dt><dt><span class="appendix"><a href="#standard-name-modifiers">C. Standard Name Modifiers</a></span></dt><dt><span class="appendix"><a href="#dimensionless-v-coord">D. Dimensionless Vertical Coordinates</a></span></dt><dt><span class="appendix"><a href="#appendix-cell-methods">E. Cell Methods</a></span></dt><dt><span class="appendix"><a href="#appendix-grid-mappings">F. Grid Mappings</a></span></dt><dt><span class="appendix"><a href="#revhistory">G. Revision History</a></span></dt><dt><span class="appendix"><a href="#appendix-examples-discrete-geometries">H. <font style="background-color:#ffccff">Annotated Examples of Discrete Geometries</font></a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9714416">H.1. Point Data</a></span></dt><dt><span class="sect1"><a href="#time-series-data">H.2. Time Series Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9763584">H.2.1. Orthogonal multidimensional array representation of time series</a></span></dt><dt><span class="sect2"><a href="#idp9772688">H.2.2. Incomplete multidimensional array representation of time series</a></span></dt><dt><span class="sect2"><a href="#idp9751936">H.2.3. Single time series, including deviations from a nominal fixed spatial location</a></span></dt><dt><span class="sect2"><a href="#idp9804080">H.2.4. Contiguous ragged array representation of time series</a></span></dt><dt><span class="sect2"><a href="#idp9819360">H.2.5. Indexed ragged array representation of time series</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9831536">H.3. Profile Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9836800">H.3.1. Orthogonal multidimensional array representation of profiles</a></span></dt><dt><span class="sect2"><a href="#idp9844272">H.3.2. Incomplete multidimensional array representation of profiles</a></span></dt><dt><span class="sect2"><a href="#idp9847344">H.3.3. Single profile</a></span></dt><dt><span class="sect2"><a href="#idp9853184">H.3.4. Contiguous ragged array representation of profiles</a></span></dt><dt><span class="sect2"><a href="#idp9860512">H.3.5. Indexed ragged array representation of profiles</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9867488">H.4. Trajectory Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9872416">H.4.1. Multidimensional array representation of trajectories</a></span></dt><dt><span class="sect2"><a href="#idp9880624">H.4.2. Single trajectory</a></span></dt><dt><span class="sect2"><a href="#idp9887728">H.4.3. Contiguous ragged array representation of trajectories</a></span></dt><dt><span class="sect2"><a href="#idp9895520">H.4.4. Indexed ragged array representation of trajectories</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9903584">H.5. Time Series of Profiles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9913136">H.5.1. Multidimensional array representations of time series profiles</a></span></dt><dt><span class="sect2"><a href="#idp9782384">H.5.2. Time series of profiles at a single station</a></span></dt><dt><span class="sect2"><a href="#idp9791328">H.5.3. Ragged array representation of time series profiles</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9970000">H.6. Trajectory of Profiles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9974768">H.6.1. Multidimensional array representation of trajectory profiles</a></span></dt><dt><span class="sect2"><a href="#idp9986752">H.6.2. Profiles along a single trajectory</a></span></dt><dt><span class="sect2"><a href="#idp9993472">H.6.3. Ragged array representation of trajectory profiles</a></span></dt></dl></dd></dl></dd><dt><span class="bibliography"><a href="#idp10201280">Bibliography</a></span></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>3.1. <a href="#table-supported-units">Supported Units</a></dt><dt>3.2. <a href="#idp6157920"><font style="background-color:#ffccff">Flag Variable Bits (from
      Example)</font></a></dt><dt>3.3. <a href="#idp6170016"><font style="background-color:#ffccff">Flag Variable Bit 2 and Bit 3 (from
      Example)</font></a></dt><dt>A.1. <a href="#idp8065200">Attributes</a></dt><dt>C.1. <a href="#idp8538784">Standard Name Modifiers</a></dt><dt>E.1. <a href="#idp8920288">Cell Methods</a></dt><dt>F.1. <a href="#idp9281904">Grid Mapping Attributes</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#idp6110352">Use of <code class="varname">standard_name</code></a></dt><dt>3.2. <a href="#idp6119600">Instrument data</a></dt><dt>3.3. <a href="#idp6130656">A flag variable<font style="background-color:#ffccff">, using
      <code class="varname">flag_values</code></font></a></dt><dt>3.4. <a href="#idp6140272"><font style="background-color:#ffccff">A flag variable, using
      <code class="varname">flag_masks</code></font></a></dt><dt>3.5. <a href="#idp6152064"><font style="background-color:#ffccff">A flag variable, using
      <code class="varname">flag_masks</code> and
      <code class="varname">flag_values</code></font></a></dt><dt>4.1. <a href="#idp6373840">Latitude axis</a></dt><dt>4.2. <a href="#idp6385584">Longitude axis</a></dt><dt>4.3. <a href="#atm-sigma-coord-ex">Atmosphere sigma coordinate</a></dt><dt>4.4. <a href="#idp6446256">Time axis</a></dt><dt>4.5. <a href="#idp6470624">Perpetual time axis</a></dt><dt>4.6. <a href="#idp6483520">Paleoclimate time axis</a></dt><dt>5.1. <a href="#idp6657200">Independent coordinate variables</a></dt><dt>5.2. <a href="#idp6663232">Two-dimensional coordinate variables</a></dt><dt>5.3. <a href="#idp6673280">Reduced horizontal grid</a></dt><dt>5.4. <a href="#idp6682224"><font style="background-color:#ffff88; text-decoration:line-through">Timeseries of station
      data</font></a></dt><dt>5.5. <a href="#idp6690736"><font style="background-color:#ffff88; text-decoration:line-through">Trajectories</font></a></dt><dt>5.6. <a href="#idp6634192">Rotated pole grid</a></dt><dt>5.7. <a href="#lambert-conformal-projection">Lambert conformal projection</a></dt><dt>5.8. <a href="#latitude-and-longitude-on-a-spherical-earth"><font style="background-color:#ffccff">Latitude and longitude on a spherical
      Earth</font></a></dt><dt>5.9. <a href="#latitude-and-longitude-on-the-wgs-1984-datum"><font style="background-color:#ffccff">Latitude and longitude on the WGS 1984
      datum</font></a></dt><dt>5.10. <a href="#british-national-grid"><font style="background-color:#ffccff">British National Grid</font></a></dt><dt>5.11. <a href="#idp6761312"><font style="background-color:#ffccff">British National Grid + Newlyn Datum
        in CRS WKT format</font></a></dt><dt>5.12. <a href="#multiple-forecasts-from-single-analysis">Multiple forecasts from a single analysis</a></dt><dt>6.1. <a href="#idp6912752"><font style="background-color:#ffff88; text-decoration:line-through">Several parcel trajectories</font></a></dt><dt>6.2. <a href="#idp6919936">Northward heat transport in Atlantic Ocean</a></dt><dt>6.3. <a href="#idp6924592">Model level numbers</a></dt><dt>7.1. <a href="#idp6985344">Cells on a latitude axis</a></dt><dt>7.2. <a href="#idp6950896">Cells in a non-rectangular grid</a></dt><dt>7.3. <a href="#idp7013360">Cell areas for a spherical geodesic grid</a></dt><dt>7.4. <a href="#idp7040736">Methods applied to a timeseries</a></dt><dt>7.5. <a href="#idp7072752">Surface air temperature variance</a></dt><dt>7.6. <a href="#mean-surface-temperature-sensible-heat-flux">Mean surface temperature over land and sensible heat flux
          averaged separately over land and sea.</a></dt><dt>7.7. <a href="#idp7106544">Thickness of sea-ice and snow on sea-ice averaged over sea
          area.</a></dt><dt>7.8. <a href="#idp7157216">Climatological seasons</a></dt><dt>7.9. <a href="#idp7160176">Decadal averages for January</a></dt><dt>7.10. <a href="#idp7162976">Temperature for each hour of the average day</a></dt><dt>7.11. <a href="#idp7165728"><font style="background-color:#ffccff">Extreme statistics and spell-lengths
        </font></a></dt><dt>7.12. <a href="#idp7171472">Temperature for each hour of the typical climatological
        day</a></dt><dt>7.13. <a href="#idp7175088">Monthly-maximum daily precipitation totals</a></dt><dt>8.1. <a href="#idp7408560">Horizontal compression of a three-dimensional array</a></dt><dt>8.2. <a href="#idp7415616">Compression of a three-dimensional field</a></dt><dt>B.1. <a href="#idp8526064">A name table containing three entries</a></dt><dt>H.1. <a href="#Example%20H.1.1">Point data.</a></dt><dt>H.2. <a href="#Example%20H2.1.1">Timeseries with common element times in a time coordinate variable using the orthogonal multidimensional array representation.</a></dt><dt>H.3. <a href="#Example%20H.2.2.1">Timeseries of station data in the incomplete multidimensional array representation.    </a></dt><dt>H.4. <a href="#Example%20H.2.3.1">A single timeseries.</a></dt><dt>H.5. <a href="#Example%20H.2.3.2">A single timeseries with time-varying deviations from a nominal point spatial location</a></dt><dt>H.6. <a href="#Example%20H.2.4.1">Timeseries of station data in the contiguous ragged array representation.</a></dt><dt>H.7. <a href="#Example%20H.2.5.1">Timeseries of station data in the indexed ragged array representation. </a></dt><dt>H.8. <a href="#Example%20H.3.1.1">Atmospheric sounding profiles for a common set of vertical coordinates stored in the orthogonal multidimensional array representation.</a></dt><dt>H.9. <a href="#Example%20H.3.3.1">Data from a single atmospheric sounding profile.</a></dt><dt>H.10. <a href="#Example%20H.3.4.1">Atmospheric sounding profiles for a common set of vertical coordinates stored in the contiguous ragged array representation.</a></dt><dt>H.11. <a href="#Example%20H.3.5.1">Atmospheric sounding profiles for a common set of vertical coordinates stored in the indexed ragged array representation.</a></dt><dt>H.12. <a href="#Example%20H.4.1.1">Trajectories recording atmospheric composition in the incomplete multidimensional array representation.</a></dt><dt>H.13. <a href="#Example%20H.4.2.1">A single trajectory recording atmospheric composition.</a></dt><dt>H.14. <a href="#Example%20H.4.3.1">Trajectories recording atmospheric composition in the contiguous ragged array representation.</a></dt><dt>H.15. <a href="#Example%20H.4.4.1">Trajectories recording atmospheric composition in the indexed ragged array representation. </a></dt><dt>H.16. <a href="#Example%20H.5.1.1">Time series of atmospheric sounding profiles from a set of locations stored in a multidimensional array representation.</a></dt><dt>H.17. <a href="#Example%20H.5.1.2">Time series of atmospheric sounding profiles from a set of locations stored in an orthogonal multidimensional array representation. </a></dt><dt>H.18. <a href="#Example%20H.5.2.1">Time series of atmospheric sounding profiles from a single location stored in a multidimensional array representation. </a></dt><dt>H.19. <a href="#Example%20H.5.3.1">Time series of atmospheric sounding profiles from a set of locations stored in a ragged array representation.</a></dt><dt>H.20. <a href="#Example%20H.6.1.1">Time series of atmospheric sounding profiles along a set of trajectories stored in a multidimensional array representation.</a></dt><dt>H.21. <a href="#Example%20H.6.2.1">Time series of atmospheric sounding profiles along a trajectory stored in a multidimensional array representation.</a></dt><dt>H.22. <a href="#Example%20H.6.3.1">Time series of atmospheric sounding profiles along a set of trajectories stored in a ragged array representation. </a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>
        </p><div class="variablelist"><dl><dt><span class="term">Home page:</span></dt><dd><p>
                        Contains links to: previous draft and current
                        working draft documents; applications for processing
                        CF conforming files; email list for discussion
                        about interpretation, clarification, and proposals
                        for changes or extensions to the current conventions.
                        <a class="ulink" href="http://www-pcmdi.llnl.gov/cf/" target="_top">http://www-pcmdi.llnl.gov/cf/</a>
                    </p></dd><dt><span class="term">Revision history:</span></dt><dd><p>
                        This document will be updated to reflect agreed changes to 
                        the standard and to correct mistakes according to the rules of 
                        <a class="ulink" href="http://cf-pcmdi.llnl.gov/governance" target="_top">CF governance</a>.
                        See <a class="xref" href="#revhistory" title="Appendix G. Revision History">Appendix G, <i>Revision History</i></a> for the full revision history.
                        Changes with provisional status use the following
                        mark-up style: <font style="background-color:#ffccff">new text</font>, 
                        <font style="background-color:#ffff88; text-decoration:line-through">deleted text</font>, and 
                        <font style="background-color:#88ff88; font-style:italic">[a comment]</font>.
                    </p></dd></dl></div><p>
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="idp5649536"></a>Chapter 1. Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idp5627168">1.1. Goals</a></span></dt><dt><span class="section"><a href="#terminology">1.2. Terminology</a></span></dt><dt><span class="section"><a href="#idp5721024">1.3. Overview</a></span></dt><dt><span class="section"><a href="#coards-relationship">1.4. Relationship to the COARDS Conventions</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5627168"></a>1.1. Goals</h2></div></div></div><p>The NetCDF library [<a href="#netcdf" class="biblioref" title="[NetCDF]"><abbr class="abbrev">NetCDF</abbr></a>] is designed to read
    and write data that has been structured according to well-defined rules
    and is easily ported across various computer platforms. The netCDF
    interface enables but does not require the creation of
    <span class="emphasis"><em>self-describing</em></span> datasets. The purpose of the CF
    conventions is to require conforming datasets to contain sufficient
    metadata that they are self-describing in the sense that each variable in
    the file has an associated description of what it represents, including
    physical units if appropriate, and that each value can be located in space
    (relative to earth-based coordinates) and time.</p><p>An important benefit of a convention is that it enables software
    tools to display data and perform operations on specified subsets of the
    data with minimal user intervention. It is possible to provide the
    metadata describing how a field is located in time and space in many
    different ways that a human would immediately recognize as equivalent. The
    purpose in restricting how the metadata is represented is to make it
    practical to write software that allows a machine to parse that metadata
    and to automatically associate each data value with its location in time
    and space. It is equally important that the metadata be easy for human
    users to write and to understand.</p><p>This standard is intended for use with climate and forecast data,
    for atmosphere, surface and ocean, and was designed with model-generated
    data particularly in mind. We recognise that there are limits to what a
    standard can practically cover; we restrict ourselves to issues that we
    believe to be of common and frequent concern in the design of climate and
    forecast metadata. Our main purpose therefore, is to propose a clear,
    adequate and flexible definition of the metadata needed for climate and
    forecast data. Although this is specifically a netCDF standard, we feel
    that most of the ideas are of wider application. The metadata objects
    could be contained in file formats other than netCDF. Conversion of the
    metadata between files of different formats will be facilitated if
    conventions for all formats are based on similar ideas.</p><p>This convention is designed to be backward compatible with the
    COARDS conventions [<a href="#coards" class="biblioref" title="[COARDS]"><abbr class="abbrev">COARDS</abbr></a>], by which we mean that a
    conforming COARDS dataset also conforms to the CF standard. Thus new
    applications that implement the CF conventions will be able to process
    COARDS datasets.</p><p>We have also striven to maximize conformance to the COARDS standard,
    that is, wherever the COARDS metadata conventions provide an adequate
    description we require their use. Extensions to COARDS are implemented in
    a manner such that the content that doesn't depend on the extensions is
    still accessible to applications that adhere to the COARDS
    standard.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="terminology"></a>1.2. Terminology</h2></div></div></div><p>The terms in this document that refer to components of a netCDF file
    are defined in the NetCDF User's Guide (NUG) [<a href="#nug" class="biblioref" title="[NUG]"><abbr class="abbrev">NUG</abbr></a>]
    NUG. Some of those definitions are repeated below for convenience.</p><div class="variablelist"><dl><dt><span class="term">auxiliary coordinate variable</span></dt><dd><p>Any netCDF variable that contains coordinate data, but is not
          a coordinate variable (in the sense of that term defined by the NUG
          and used by this standard - see below). Unlike coordinate variables,
          there is no relationship between the name of an auxiliary coordinate
          variable and the name(s) of its dimension(s).</p></dd><dt><span class="term">boundary variable</span></dt><dd><p>A boundary variable is associated with a variable that
          contains coordinate data. When a data value provides information
          about conditions in a cell occupying a region of space/time or some
          other dimension, the boundary variable provides a description of
          cell extent.</p></dd><dt><span class="term">CDL syntax</span></dt><dd><p>The ascii format used to describe the contents of a netCDF
          file is called CDL (network Common Data form Language). This format
          represents arrays using the indexing conventions of the C
          programming language, i.e., index values start at 0, and in
          multidimensional arrays, when indexing over the elements of the
          array, it is the last declared dimension that is the fastest varying
          in terms of file storage order. The netCDF utilities ncdump and
          ncgen use this format (see <font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-15.html#HEADING15-0" target="_top">
          chapter 10 of the NUG </a> </font> <font style="background-color:#ffccff">
          <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#NetCDF-Utilities" target="_top">
          chapter 10 of the NUG </a> </font> ). All examples in this
          document use CDL syntax.</p></dd><dt><span class="term">cell</span></dt><dd><p>A region in one or more dimensions whose boundary can be
          described by a set of vertices. The term
          <span class="emphasis"><em>interval</em></span> is sometimes used for one-dimensional
          cells.</p></dd><dt><span class="term">coordinate variable</span></dt><dd><p>We use this term precisely as it is defined in section
          <font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-7.html#HEADING7-67" target="_top">
          2.3.1 of the NUG </a></font> <font style="background-color:#ffccff">
          <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Variables" target="_top">
          2.3.1 of the NUG </a></font> . It is a one-dimensional
          variable with the same name as its dimension [e.g.,
          <code class="varname">time(time)</code>], and it is defined as a numeric data
          type with values that are ordered monotonically. Missing values are
          not allowed in coordinate variables.</p></dd><dt><span class="term">grid mapping variable</span></dt><dd><p>A variable used as a container for attributes that define a
          specific grid mapping. The type of the variable is arbitrary since
          it contains no data.</p></dd><dt><span class="term">latitude dimension</span></dt><dd><p>A dimension of a netCDF variable that has an associated
          latitude coordinate variable.</p></dd><dt><span class="term">longitude dimension</span></dt><dd><p>A dimension of a netCDF variable that has an associated
          longitude coordinate variable.</p></dd><dt><span class="term">multidimensional coordinate variable</span></dt><dd><p>An auxiliary coordinate variable that is
          multidimensional.</p></dd><dt><span class="term">recommendation</span></dt><dd><p>Recommendations in this convention are meant to provide advice
          that may be helpful for reducing common mistakes. In some cases we
          have recommended rather than required particular attributes in order
          to maintain backwards compatibility with COARDS. An application must
          not depend on a dataset's adherence to recommendations.</p></dd><dt><span class="term">scalar coordinate variable</span></dt><dd><p>A scalar variable that contains coordinate data. Functionally
          equivalent to either a size one coordinate variable or a size one
          auxiliary coordinate variable.</p></dd><dt><span class="term">spatiotemporal dimension</span></dt><dd><p>A dimension of a netCDF variable that is used to identify a
          location in time and/or space.</p></dd><dt><span class="term">time dimension</span></dt><dd><p>A dimension of a netCDF variable that has an associated time
          coordinate variable.</p></dd><dt><span class="term">vertical dimension</span></dt><dd><p>A dimension of a netCDF variable that has an associated
          vertical coordinate variable.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5721024"></a>1.3. Overview</h2></div></div></div><p>No variable or dimension names are standardized by this convention.
    Instead we follow the lead of the NUG and standardize only the names of
    attributes and some of the values taken by those attributes. The overview
    provided in this section will be followed with more complete descriptions
    in following sections. <a class="xref" href="#attribute-appendix" title="Appendix A. Attributes">Appendix A, <i>Attributes</i></a> contains a
    summary of all the attributes used in this convention.</p><p>We recommend that the NUG defined attribute
    <code class="varname">Conventions</code> be given the string value <font style="background-color:#ffff88; text-decoration:line-through">"<code class="varname">CF-1.4</code>"</font> <font style="background-color:#ffff88; text-decoration:line-through">"<code class="varname">CF-1.5</code>"</font> <font style="background-color:#ffccff">"<code class="varname">CF-1.6</code>"</font> to identify datasets
    that conform to these conventions.</p><p>The general description of a file's contents should be contained in
    the following attributes: <code class="varname">title</code>,
    <code class="varname">history</code>, <code class="varname">institution</code>,
    <code class="varname">source</code>, <code class="varname">comment</code> and
    <code class="varname">references</code> (<a class="xref" href="#description-of-file-contents" title="2.6.2. Description of file contents">Section 2.6.2, &#8220;Description of file contents&#8221;</a>). For backwards compatibility
    with COARDS none of these attributes is required, but their use is
    recommended to provide human readable documentation of the file
    contents.</p><p>Each variable in a netCDF file has an associated description which
    is provided by the attributes <code class="varname">units</code>,
    <code class="varname">long_name</code>, and <code class="varname">standard_name</code>. The
    <code class="varname">units</code>, and <code class="varname">long_name</code> attributes are
    defined in the NUG and the <code class="varname">standard_name</code> attribute is
    defined in this document.</p><p>The <code class="varname">units</code> attribute is required for all variables
    that represent dimensional quantities (except for boundary variables
    defined in <a class="xref" href="#cell-boundaries" title="7.1. Cell Boundaries">Section 7.1, &#8220;Cell Boundaries&#8221;</a>. The values of the
    <code class="varname">units</code> attributes are character strings that are
    recognized by UNIDATA's Udunits package [<span class="citation"><a class="link" href="#udunits" title="UDUNITS Software Package">UDUNITS</a></span>], (with exceptions allowed as
    discussed in <a class="xref" href="#units" title="3.1. Units">Section 3.1, &#8220;Units&#8221;</a>).</p><p>The <code class="varname">long_name</code> and
    <code class="varname">standard_name</code> attributes are used to describe the
    content of each variable. For backwards compatibility with COARDS neither
    is required, but use of at least one of them is strongly recommended. The
    use of standard names will facilitate the exchange of climate and forecast
    data by providing unambiguous identification of variables most commonly
    analyzed.</p><p>Four types of coordinates receive special treatment by these
    conventions: latitude, longitude, vertical, and time. Every variable must
    have associated metadata that allows identification of each such
    coordinate that is relevant. Two independent parts of the convention allow
    this to be done. There are conventions that identify the variables that
    contain the coordinate data, and there are conventions that identify the
    type of coordinate represented by that data.</p><p>There are two methods used to identify variables that contain
    coordinate data. The first is to use the NUG-defined "coordinate
    variables." <span class="emphasis"><em>The use of coordinate variables is required for all
    dimensions that correspond to one dimensional space or time
    coordinates</em></span>. In cases where coordinate variables are not
    applicable, the variables containing coordinate data are identified by the
    <code class="varname">coordinates</code> attribute.</p><p>Once the variables containing coordinate data are identified,
    further conventions are required to determine the type of coordinate
    represented by each of these variables. Latitude, longitude, and time
    coordinates are identified solely by the value of their
    <code class="varname">units</code> attribute. Vertical coordinates with units of
    pressure may also be identified by the <code class="varname">units</code> attribute.
    Other vertical coordinates must use the attribute
    <code class="varname">positive</code> which determines whether the direction of
    increasing coordinate value is up or down. Because identification of a
    coordinate type by its units involves the use of an external software
    package [<a href="#udunits" class="biblioref" title="[UDUNITS]"><abbr class="abbrev">UDUNITS</abbr></a>], we provide the optional attribute
    <code class="varname">axis</code> for a direct identification of coordinates that
    correspond to latitude, longitude, vertical, or time axes.</p><p>Latitude, longitude, and time are defined by internationally
    recognized standards, and hence, identifying the coordinates of these
    types is sufficient to locate data values uniquely with respect to time
    and a point on the earth's surface. On the other hand identifying the
    vertical coordinate is not necessarily sufficient to locate a data value
    vertically with respect to the earth's surface. In particular a model may
    output data on the dimensionless vertical coordinate used in its
    mathematical formulation. To achieve the goal of being able to spatially
    locate all data values, this convention includes the definitions of common
    dimensionless vertical coordinates in <a class="xref" href="#dimensionless-v-coord" title="Appendix D. Dimensionless Vertical Coordinates">Appendix D, <i>Dimensionless Vertical Coordinates</i></a>. These definitions provide a mapping
    between the dimensionless coordinate values and dimensional values that
    can be uniquely located with respect to a point on the earth's surface.
    The definitions are associated with a coordinate variable via the
    <code class="varname">standard_name</code> and <code class="varname">formula_terms</code>
    attributes. For backwards compatibility with COARDS use of these
    attributes is not required, but is strongly recommended.</p><p>It is often the case that data values are not representative of
    single points in time and/or space, but rather of intervals or
    multidimensional cells. This convention defines a
    <code class="varname">bounds</code> attribute to specify the extent of intervals or
    cells. When data that is representative of cells can be described by
    simple statistical methods, those methods can be indicated using the
    <code class="varname">cell_methods</code> attribute. An important application of
    this attribute is to describe climatological and diurnal
    statistics.</p><p>Methods for reducing the total volume of data include both packing
    and compression. Packing reduces the data volume by reducing the precision
    of the stored numbers. It is implemented using the attributes
    <code class="varname">add_offset</code> and <code class="varname">scale_factor</code> which
    are defined in the NUG. Compression on the other hand loses no precision,
    but reduces the volume by not storing missing data. The attribute
    <code class="varname">compress</code> is defined for this purpose.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="coards-relationship"></a>1.4. Relationship to the COARDS Conventions</h2></div></div></div><p>These conventions generalize and extend the COARDS conventions
    [<a href="#coards" class="biblioref" title="[COARDS]"><abbr class="abbrev">COARDS</abbr></a>]. A major design goal has been to maintain
    <span class="emphasis"><em>backward compatibility</em></span> with COARDS. Hence
    applications written to process datasets that conform to these conventions
    will also be able to process COARDS conforming datasets. We have also
    striven to maximize <span class="emphasis"><em>conformance</em></span> to the COARDS
    standard so that datasets that only require the metadata that was
    available under COARDS will still be able to be processed by COARDS
    conforming applications. But because of the extensions that provide new
    metadata content, and the relaxation of some COARDS requirements, datasets
    that conform to these conventions will not necessarily be recognized by
    applications that adhere to the COARDS conventions. The features of these
    conventions that allow writing netCDF files that are not COARDS conforming
    are summarized below.</p><p>COARDS standardizes the description of grids composed of independent
    latitude, longitude, vertical, and time axes. In addition to standardizing
    the metadata required to identify each of these axis types COARDS
    restricts the axis (equivalently dimension) ordering to be longitude,
    latitude, vertical, and time (with longitude being the most rapidly
    varying dimension). Because of I/O performance considerations it may not
    be possible for models to output their data in conformance with the COARDS
    requirement. The CF convention places no rigid restrictions on the order
    of dimensions, however we encourage data producers to make the extra
    effort to stay within the COARDS standard order. The use of non-COARDS
    axis ordering will render files inaccessible to some applications and
    limit interoperability. Often a buffering operation can be used to
    miminize performance penalties when axis ordering in model code does not
    match the axis ordering of a COARDS file.</p><p>COARDS addresses the issue of identifying dimensionless vertical
    coordinates, but does not provide any mechanism for mapping the
    dimensionless values to dimensional ones that can be located with respect
    to the earth's surface. For backwards compatibility we continue to allow
    (but do not require) the <code class="varname">units</code> attribute of
    dimensionless vertical coordinates to take the values "level", "layer", or
    "sigma_level." But we recommend that the <code class="varname">standard_name</code>
    and <code class="varname">formula_terms</code> attributes be used to identify the
    appropriate definition of the dimensionless vertical coordinate (see <a class="xref" href="#dimensionless-vertical-coordinate" title="4.3.2. Dimensionless Vertical Coordinate">Section 4.3.2, &#8220;Dimensionless Vertical Coordinate&#8221;</a>).</p><p>The CF conventions define attributes which enable the description of
    data properties that are outside the scope of the COARDS conventions.
    These new attributes do not violate the COARDS conventions, but
    applications that only recognize COARDS conforming datasets will not have
    the capabilities that the new attributes are meant to enable. Briefly the
    new attributes allow:</p><div class="itemizedlist"><ul type="disc"><li><p>Identification of quantities using standard names.</p></li><li><p>Description of dimensionless vertical coordinates.</p></li><li><p>Associating dimensions with auxiliary coordinate
        variables.</p></li><li><p>Linking data variables to scalar coordinate variables.</p></li><li><p>Associating dimensions with labels.</p></li><li><p>Description of intervals and cells.</p></li><li><p>Description of properties of data defined on intervals and
        cells.</p></li><li><p>Description of climatological statistics.</p></li><li><p>Data compression for variables with missing values.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="idp5858512"></a>Chapter 2. NetCDF Files and Components</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idp5822368">2.1. Filename</a></span></dt><dt><span class="section"><a href="#idp5824272">2.2. Data Types</a></span></dt><dt><span class="section"><a href="#idp5866720">2.3. Naming Conventions</a></span></dt><dt><span class="section"><a href="#dimensions">2.4. Dimensions</a></span></dt><dt><span class="section"><a href="#variables">2.5. Variables</a></span></dt><dd><dl><dt><span class="section"><a href="#missing-data">2.5.1. Missing Data<font style="background-color:#ffccff">, valid and actual
      range</font></a></span></dt></dl></dd><dt><span class="section"><a href="#idp5908160">2.6. Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#identification-of-conventions">2.6.1. Identification of Conventions</a></span></dt><dt><span class="section"><a href="#description-of-file-contents">2.6.2. Description of file contents</a></span></dt></dl></dd></dl></div><p>The components of a netCDF file are described in section 2 of the NUG
  [<a href="#nug" class="biblioref" title="[NUG]"><abbr class="abbrev">NUG</abbr></a>]. In this section we describe conventions
  associated with filenames and the basic components of a netCDF file. We also
  introduce new attributes for describing the contents of a file.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5822368"></a>2.1. Filename</h2></div></div></div><p>NetCDF files should have the file name extension
    "<code class="filename">.nc</code>".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5824272"></a>2.2. Data Types</h2></div></div></div><p>The netCDF data types <code class="varname">char</code>,
    <code class="varname">byte</code>, <code class="varname">short</code>, <code class="varname">int</code>,
    <code class="varname">float</code> or <code class="varname">real</code>, and
    <code class="varname">double</code> are all acceptable. The <code class="varname">char</code>
    type is not intended for numeric data. One byte numeric data should be
    stored using the <code class="varname">byte</code> data type. All integer types are
    treated by the netCDF interface as signed. It is possible to treat the
    <code class="varname">byte</code> type as unsigned by using the NUG convention of
    indicating the unsigned range using the <code class="varname">valid_min</code>,
    <code class="varname">valid_max</code>, or <code class="varname">valid_range</code>
    attributes.</p><p>NetCDF does not support a character string type, so these must be
    represented as character arrays. In this document, a one dimensional array
    of character data is simply referred to as a "string". An n-dimensional
    array of strings must be implemented as a character array of dimension
    (n,max_string_length), with the last (most rapidly varying) dimension
    declared large enough to contain the longest string in the array. All the
    strings in a given array are therefore defined to be equal in length. For
    example, an array of strings containing the names of the months would be
    dimensioned (12,9) in order to accommodate "September", the month with the
    longest name.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5866720"></a>2.3. Naming Conventions</h2></div></div></div><p>Variable, dimension and attribute names should begin with a letter
    and be composed of letters, digits, and underscores. Note that this is in
    conformance with the COARDS conventions, but is more restrictive than the
    netCDF interface which allows use of the hyphen character. The netCDF
    interface also allows leading underscores in names, but the NUG states
    that this is reserved for system use.</p><p>Case is significant in netCDF names, but it is recommended that
    names should not be distinguished purely by case, i.e., if case is
    disregarded, no two names should be the same. It is also recommended that
    names should be obviously meaningful, if possible, as this renders the
    file more effectively self-describing.</p><p>This convention does not standardize any variable or dimension
    names. Attribute names and their contents, where standardized, are given
    in English in this document and should appear in English in conforming
    netCDF files for the sake of portability. Languages other than English are
    permitted for variables, dimensions, and non-standardized attributes. The
    content of some standardized attributes are string values that are not
    standardized, and thus are not required to be in English. For example, a
    description of what a variable represents may be given in a non-English
    language using the <code class="varname">long_name</code> attribute (see <a class="xref" href="#long-name" title="3.2. Long Name">Section 3.2, &#8220;Long Name&#8221;</a>) whose contents are not standardized, but a
    description given by the <code class="varname">standard_name</code> attribute (see
    <a class="xref" href="#standard-name" title="3.3. Standard Name">Section 3.3, &#8220;Standard Name&#8221;</a>) must be taken from the standard name
    table which is in English.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dimensions"></a>2.4. Dimensions</h2></div></div></div><p>A variable may have any number of dimensions, including zero, and
    the dimensions must all have different names. <span class="emphasis"><em>COARDS strongly
    recommends limiting the number of dimensions to four, but we wish to allow
    greater flexibility</em></span>. The dimensions of the variable define the
    axes of the quantity it contains. Dimensions other than those of space and
    time may be included. Several examples can be found in this document.
    Under certain circumstances, one may need more than one dimension in a
    particular quantity. For instance, a variable containing a two-dimensional
    probability density function might correlate the temperature at two
    different vertical levels, and hence would have temperature on both
    axes.</p><p>If any or all of the dimensions of a variable have the
    interpretations of "date or time" (<code class="varname">T</code>), "height or
    depth" (<code class="varname">Z</code>), "latitude" (<code class="varname">Y</code>), or
    "longitude" (<code class="varname">X</code>) then we recommend, but do not require
    (see <a class="xref" href="#coards-relationship" title="1.4. Relationship to the COARDS Conventions">Section 1.4, &#8220;Relationship to the COARDS Conventions&#8221;</a>), those dimensions to appear in
    the relative order <code class="varname">T</code>, then <code class="varname">Z</code>, then
    <code class="varname">Y</code>, then <code class="varname">X</code> in the CDL definition
    corresponding to the file. All other dimensions should, whenever possible,
    be placed to the left of the spatiotemporal dimensions.</p><p>Dimensions may be of any size, including unity. When a single value
    of some coordinate applies to all the values in a variable, the
    recommended means of attaching this information to the variable is by use
    of a dimension of size unity with a one-element coordinate variable. It is
    also acceptable to use a scalar coordinate variable which eliminates the
    need for an associated size one dimension in the data variable. The
    advantage of using either a coordinate variable or an auxiliary coordinate
    variable is that all its attributes can be used to describe the
    single-valued quantity, including boundaries. For example, a variable
    containing data for temperature at 1.5 m above the ground has a
    single-valued coordinate supplying a height of 1.5 m, and a time-mean
    quantity has a single-valued time coordinate with an associated boundary
    variable to record the start and end of the averaging period.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="variables"></a>2.5. Variables</h2></div></div></div><p>This convention does not standardize variable names.</p><p>NetCDF variables that contain coordinate data are referred to as
    <span class="emphasis"><em>coordinate variables</em></span>, <span class="emphasis"><em>auxiliary coordinate
    variables</em></span>, <span class="emphasis"><em>scalar coordinate variables</em></span>, or
    <span class="emphasis"><em>multidimensional coordinate variables</em></span>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="missing-data"></a>2.5.1. Missing Data<font style="background-color:#ffccff">, valid and actual
      range</font></h3></div></div></div><p>The NUG conventions ( <font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">
      NUG section 8.1</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">
      NUG section 8.1</a></font> ) provide the
      <code class="varname">_FillValue</code>, <font style="background-color:#ffccff"><code class="varname">missing_value</code>,</font>
      <code class="varname">valid_min</code>, <code class="varname">valid_max</code>, and
      <code class="varname">valid_range</code> attributes to indicate missing
      data.</p><p>The NUG conventions for missing data changed significantly between
      version 2.3 and version 2.4. Since version 2.4 the NUG defines missing
      data as all values outside of the <code class="varname">valid_range</code>, and
      specifies how the <code class="varname">valid_range</code> should be defined from
      the <code class="varname">_FillValue</code> (which has library specified default
      values) if it hasn't been explicitly specified. If only one missing
      value is needed for a variable then we recommend <font style="background-color:#ffff88; text-decoration:line-through">strongly</font> that this value be specified
      using the <code class="varname">_FillValue</code> attribute. Doing this guarantees
      that the missing value will be recognized by generic applications that
      follow either the before or after version 2.4 conventions.</p><p>The scalar attribute with the name <code class="varname">_FillValue</code>
      and of the same type as its variable is recognized by the netCDF library
      as the value used to pre-fill disk space allocated to the variable. This
      value is considered to be a special value that indicates undefined or
      missing data, and is returned when reading values that were not written.
      The <code class="varname">_FillValue</code> should be outside the range specified
      by <code class="varname">valid_range</code> (if used) for a variable. The netCDF
      library defines a default fill value for each data type ( <font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-12.html#HEADING12-1381" target="_top">
      NUG section 7.16</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#NetCDF-Classic-Format" target="_top">
      NUG section 7.16</a></font> ).</p><p><font style="background-color:#ffff88; text-decoration:line-through"> The <code class="varname">missing_value</code>
      attribute is considered deprecated by the NUG and we do not recommend
      its use. However for backwards compatibility with COARDS this standard
      continues to recognize the use of the <code class="varname"> missing_value</code>
      attribute to indicate undefined or missing data. </font></p><p>The missing values of a variable with
      <code class="varname">scale_factor</code> and/or <code class="varname">add_offset</code>
      attributes (see section <a class="xref" href="#packed-data" title="8.1. Packed Data">Section 8.1, &#8220;Packed Data&#8221;</a>) are interpreted
      relative to the variable's external values <font style="background-color:#ffff88; text-decoration:line-through">
      , i.e., the values stored in the netCDF file.</font> <font style="background-color:#ffccff">(a.k.a. the packed values, the raw values, the values
      stored in the netCDF file), not the values that result after the scale
      and offset are applied.</font> Applications that process variables
      that have attributes to indicate both a transformation (via a scale
      and/or offset) and missing values should first check that a data value
      is valid, and then apply the transformation. Note that values that are
      identified as missing should not be transformed. Since the missing value
      is outside the valid range it is possible that applying a transformation
      to it could result in an invalid operation. For example, the default
      <code class="varname">_FillValue</code> is very close to the maximum representable
      value of IEEE single precision floats, and multiplying it by 100
      produces an "Infinity" (using single precision arithmetic).</p><p><a name="actual_range"></a><font style="background-color:#ffccff">This convention defines
      a two-element vector attribute <code class="varname">actual_range </code>for
      variables containing numeric data. If the variable is packed using the
      <code class="varname">scale_factor</code> and <code class="varname">add_offset</code>
      attributes (see section 8.1), the elements of the
      <code class="varname">actual_range</code> should have the type intended for the
      unpacked data. The elements of <code class="varname">actual_range</code> must be
      exactly equal to the minimum and the maximum data values which occur in
      the variable (when unpacked if packing is used), and both must be within
      the <code class="varname">valid_range</code> if specified. If the data is all
      missing or invalid, the <code class="varname">actual_range</code> attribute cannot
      be used. </font></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp5908160"></a>2.6. Attributes</h2></div></div></div><p>This standard describes many attributes (some mandatory, others
    optional), but a file may also contain non-standard attributes. Such
    attributes do not represent a violation of this standard. Application
    programs should ignore attributes that they do not recognise or which are
    irrelevant for their purposes. Conventional attribute names should be used
    wherever applicable. Non-standard names should be as meaningful as
    possible. Before introducing an attribute, consideration should be given
    to whether the information would be better represented as a variable. In
    general, if a proposed attribute requires ancillary data to describe it,
    is multidimensional, requires any of the defined netCDF dimensions to
    index its values, or requires a significant amount of storage, a variable
    should be used instead. When this standard defines string attributes that
    may take various prescribed values, the possible values are generally
    given in lower case. However, applications programs should not be
    sensitive to case in these attributes. Several string attributes are
    defined by this standard to contain "blank-separated lists". Consecutive
    words in such a list are separated by one or more adjacent spaces. The
    list may begin and end with any number of spaces. See <a class="xref" href="#attribute-appendix" title="Appendix A. Attributes">Appendix A, <i>Attributes</i></a> for a list of attributes described by this
    standard.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="identification-of-conventions"></a>2.6.1. Identification of Conventions</h3></div></div></div><p>We recommend that netCDF files that follow these conventions
      indicate this by setting the NUG defined global attribute
      <code class="varname">Conventions</code> to the string value <font style="background-color:#ffff88; text-decoration:line-through">"<code class="varname">CF-1.3</code>"</font> <font style="background-color:#ffff88; text-decoration:line-through">"<code class="varname">CF-1.4</code>"</font> <font style="background-color:#ffff88; text-decoration:line-through">"<code class="varname">CF-1.5</code>"</font> <font style="background-color:#ffff88; text-decoration:line-through">"<code class="varname">CF-1.6</code>"</font><font style="background-color:#ffccff">"<code class="varname">CF-1.7</code>"</font> . The string is
      interpreted as a directory name relative to a directory that is a
      repository of documents describing sets of discipline-specific
      conventions. The conventions directory name is currently interpreted
      relative to the directory <code class="filename">pub/netcdf/Conventions/</code> on the host machine
      <code class="computeroutput">ftp.unidata.ucar.edu</code>. The web based
      versions of this document are linked from the <font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/packages/conventions.html" target="_top">
      netCDF Conventions web page </a>. </font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/conventions.html" target="_top"> netCDF
      Conventions web page </a>. </font></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="description-of-file-contents"></a>2.6.2. Description of file contents</h3></div></div></div><p>The following attributes are intended to provide information about
      where the data came from and what has been done to it. This information
      is mainly for the benefit of human readers. The attribute values are all
      character strings. For readability in ncdump outputs it is recommended
      to embed newline characters into long strings to break them into lines.
      For backwards compatibility with COARDS none of these global attributes
      is required.</p><p>The NUG defines <code class="varname">title</code> and
      <code class="varname">history</code> to be global attributes. We wish to allow the
      newly defined attributes, i.e., <code class="varname">institution</code>,
      <code class="varname">source</code>, <code class="varname">references</code>, and
      <code class="varname">comment</code>, to be either global or assigned to
      individual variables. When an attribute appears both globally and as a
      variable attribute, the variable's version has precedence.</p><div class="variablelist"><dl><dt><span class="term"><code class="varname"> title </code></span></dt><dd><p>A succinct description of what is in the dataset.</p></dd><dt><span class="term"><code class="varname"> institution </code></span></dt><dd><p>Specifies where the original data was produced.</p></dd><dt><span class="term"><code class="varname"> source </code></span></dt><dd><p>The method of production of the original data. If it was
              model-generated, <code class="varname">source</code> should name the model
              and its version, as specifically as could be useful. If it is
              observational, <code class="varname">source</code> should characterize it
              (e.g., "<code class="varname">surface observation</code>" or
              "<code class="varname">radiosonde</code>").</p></dd><dt><span class="term"><code class="varname"> history </code></span></dt><dd><p>Provides an audit trail for modifications to the original
              data. Well-behaved generic netCDF filters will automatically
              append their name and the parameters with which they were
              invoked to the global history attribute of an input netCDF file.
              We recommend that each line begin with a timestamp indicating
              the date and time of day that the program was executed.</p></dd><dt><span class="term"><code class="varname"> references </code></span></dt><dd><p>Published or web-based references that describe the data
              or methods used to produce it.</p></dd><dt><span class="term"><code class="varname"> comment </code></span></dt><dd><p>Miscellaneous information about the data or methods used
              to produce it.</p></dd></dl></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="idp6032096"></a>Chapter 3. Description of the Data</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#units">3.1. Units</a></span></dt><dt><span class="section"><a href="#long-name">3.2. Long Name</a></span></dt><dt><span class="section"><a href="#standard-name">3.3. Standard Name</a></span></dt><dt><span class="section"><a href="#ancillary-data">3.4. Ancillary Data</a></span></dt><dt><span class="section"><a href="#flags">3.5. Flags</a></span></dt></dl></div><p>The attributes described in this section are used to provide a
  description of the content and the units of measurement for each variable.
  We continue to support the use of the <code class="varname">units</code> and
  <code class="varname">long_name</code> attributes as defined in COARDS. We extend
  COARDS by adding the optional <code class="varname">standard_name</code> attribute
  which is used to provide unique identifiers for variables. This is important
  for data exchange since one cannot necessarily identify a particular
  variable based on the name assigned to it by the institution that provided
  the data.</p><p>The <code class="varname">standard_name</code> attribute can be used to identify
  variables that contain coordinate data. But since it is an optional
  attribute, applications that implement these standards must continue to be
  able to identify coordinate types based on the COARDS conventions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="units"></a>3.1. Units</h2></div></div></div><p>The <code class="varname">units</code> attribute is required for all variables
    that represent dimensional quantities (except for boundary variables
    defined in <a class="xref" href="#cell-boundaries" title="7.1. Cell Boundaries">Section 7.1, &#8220;Cell Boundaries&#8221;</a> and climatology variables
    defined in <a class="xref" href="#climatological-statistics" title="7.4. Climatological Statistics">Section 7.4, &#8220;Climatological Statistics&#8221;</a>). The value of the
    <code class="varname">units</code> attribute is a string that can be recognized by
    UNIDATA"s Udunits package [<a href="#udunits" class="biblioref" title="[UDUNITS]"><abbr class="abbrev">UDUNITS</abbr></a>], with a few
    exceptions that are given below. The <a class="ulink" href="http://www.unidata.ucar.edu/software/udunits/" target="_top">Udunits
    package</a> includes a file <code class="filename">udunits.dat</code>, which
    lists its supported unit names. Note that case is significant in the
    <code class="varname">units</code> strings.</p><p>The COARDS convention prohibits the unit
    <code class="constant">degrees</code> altogether, but this unit is not forbidden by
    the CF convention because it may in fact be appropriate for a variable
    containing, say, solar zenith angle. The unit <code class="constant">degrees</code>
    is also allowed on coordinate variables such as the latitude and longitude
    coordinates of a transformed grid. In this case the coordinate values are
    not true latitudes and longitudes which must always be identified using
    the more specific forms of <code class="constant">degrees</code> as described in
    <a class="xref" href="#latitude-coordinate" title="4.1. Latitude Coordinate">Section 4.1, &#8220;Latitude Coordinate&#8221;</a> and <a class="xref" href="#longitude-coordinate" title="4.2. Longitude Coordinate">Section 4.2, &#8220;Longitude Coordinate&#8221;</a>.</p><p>Units are not required for dimensionless quantities. A variable with
    no units attribute is assumed to be dimensionless. However, a units
    attribute specifying a dimensionless unit may optionally be included. The
    Udunits package defines a few dimensionless units, such as
    <code class="constant">percent</code>, but is lacking commonly used units such as
    ppm (parts per million). This convention does not support the addition of
    new dimensionless units that are not udunits compatible. The conforming
    unit for quantities that represent fractions, or parts of a whole, is "1".
    The conforming unit for parts per million is "1e-6". Descriptive
    information about dimensionless quantities, such as sea-ice concentration,
    cloud fraction, probability, etc., should be given in the
    <code class="varname">long_name</code> or <code class="varname">standard_name</code>
    attributes (see below) rather than the <code class="varname">units</code>.</p><p>The units <code class="constant">level</code>, <code class="constant">layer</code>,
    and <code class="constant">sigma_level</code> are allowed for dimensionless
    vertical coordinates to maintain backwards compatibility with COARDS.
    These units are not compatible with Udunits and are deprecated by this
    standard because conventions for more precisely identifying dimensionless
    vertical coordinates are introduced (see <a class="xref" href="#dimensionless-vertical-coordinate" title="4.3.2. Dimensionless Vertical Coordinate">Section 4.3.2, &#8220;Dimensionless Vertical Coordinate&#8221;</a>).</p><p>The Udunits syntax that allows scale factors and offsets to be
    applied to a unit is not supported by this standard. The application of
    any scale factors or offsets to data should be indicated by the
    <code class="varname">scale_factor</code> and <code class="varname">add_offset</code>
    attributes. Use of these attributes for data packing, which is their most
    important application, is discussed in detail in <a class="xref" href="#packed-data" title="8.1. Packed Data">Section 8.1, &#8220;Packed Data&#8221;</a>.</p><p>Udunits recognizes the following prefixes and their abbreviations.
    </p><div class="table"><a name="table-supported-units"></a><p class="title"><b>Table 3.1. Supported Units</b></p><div class="table-contents"><table summary="Supported Units" border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th align="left">Factor</th><th align="left">Prefix</th><th align="left">Abbreviation</th><th align="left"> </th><th align="left">Factor</th><th align="left">Prefix</th><th align="left">Abbreviation</th></tr></thead><tbody><tr><td align="left">1e1</td><td align="left">deca,deka</td><td align="left">da</td><td align="left"> </td><td align="left">1e-1</td><td align="left">deci</td><td align="left">d</td></tr><tr><td align="left">1e2</td><td align="left">hecto</td><td align="left">h</td><td align="left"> </td><td align="left">1e-2</td><td align="left">centi</td><td align="left">c</td></tr><tr><td align="left">1e3</td><td align="left">kilo</td><td align="left">k</td><td align="left"> </td><td align="left">1e-3</td><td align="left">milli</td><td align="left">m</td></tr><tr><td align="left">1e6</td><td align="left">mega</td><td align="left">M</td><td align="left"> </td><td align="left">1e-6</td><td align="left">micro</td><td align="left">u</td></tr><tr><td align="left">1e9</td><td align="left">giga</td><td align="left">G</td><td align="left"> </td><td align="left">1e-9</td><td align="left">nano</td><td align="left">n</td></tr><tr><td align="left">1e12</td><td align="left">tera</td><td align="left">T</td><td align="left"> </td><td align="left">1e-12</td><td align="left">pico</td><td align="left">p</td></tr><tr><td align="left">1e15</td><td align="left">peta</td><td align="left">P</td><td align="left"> </td><td align="left">1e-15</td><td align="left">femto</td><td align="left">f</td></tr><tr><td align="left">1e18</td><td align="left">exa</td><td align="left">E</td><td align="left"> </td><td align="left">1e-18</td><td align="left">atto</td><td align="left">a</td></tr><tr><td align="left">1e21</td><td align="left">zetta</td><td align="left">Z</td><td align="left"> </td><td align="left">1e-21</td><td align="left">zepto</td><td align="left">z</td></tr><tr><td align="left">1e24</td><td align="left">yotta</td><td align="left">Y</td><td align="left"> </td><td align="left">1e-24</td><td align="left">yocto</td><td align="left">y</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="long-name"></a>3.2. Long Name</h2></div></div></div><p>The <code class="varname">long_name</code> attribute is defined by the NUG to
    contain a long descriptive name which may, for example, be used for
    labeling plots. For backwards compatibility with COARDS this attribute is
    optional. But it is highly recommended that either this or the
    <code class="varname">standard_name</code> attribute defined in the next section be
    provided to make the file self-describing. If a variable has no
    <code class="varname">long_name</code> attribute then an application may use, as a
    default, the <code class="varname">standard_name</code> if it exists, or the
    variable name itself.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="standard-name"></a>3.3. Standard Name</h2></div></div></div><p>A fundamental requirement for exchange of scientific data is the
    ability to describe precisely the physical quantities being represented.
    To some extent this is the role of the <code class="varname">long_name</code>
    attribute as defined in the NUG. However, usage of
    <code class="varname">long_name</code> is completely ad-hoc. For some applications
    it would be desirable to have a more definitive description of the
    quantity, which would allow users of data from different sources to
    determine whether quantities were in fact comparable. For this reason an
    optional mechanism for uniquely associating each variable with a standard
    name is provided.</p><p>A standard name is associated with a variable via the attribute
    <code class="varname">standard_name</code> which takes a string value comprised of a
    standard name optionally followed by one or more blanks and a standard
    name modifier (a string value from <a class="xref" href="#standard-name-modifiers" title="Appendix C. Standard Name Modifiers">Appendix C, <i>Standard Name Modifiers</i></a>).</p><p>The set of permissible standard names is contained in the standard
    name table. The table entry for each standard name contains the
    following:</p><div class="variablelist"><dl><dt><span class="term">standard name</span></dt><dd><p>The name used to identify the physical quantity. A standard
          name contains no whitespace and is case sensitive.</p></dd><dt><span class="term">canonical units</span></dt><dd><p>Representative units of the physical quantity. Unless it is
          dimensionless, a variable with a <code class="varname">standard_name</code>
          attribute must have units which are physically equivalent (not
          necessarily identical) to the canonical units, possibly modified by
          an operation specified by <font style="background-color:#ffff88; text-decoration:line-through">either</font> the standard name modifier (see
          below and <a class="xref" href="#standard-name-modifiers" title="Appendix C. Standard Name Modifiers">Appendix C, <i>Standard Name Modifiers</i></a>) or by the
          <code class="varname">cell_methods</code> attribute (see <a class="xref" href="#cell-methods" title="7.3. Cell Methods">Section 7.3, &#8220;Cell Methods&#8221;</a> and <a class="xref" href="#appendix-cell-methods" title="Appendix E. Cell Methods">Appendix E, <i>Cell Methods</i></a>)<font style="background-color:#ffccff">, or both
          (with the <code class="varname">standard_name</code> modifier operating
          first)</font>.</p></dd><dt><span class="term">description</span></dt><dd><p>The description is meant to clarify the qualifiers of the
          fundamental quantities such as which surface a quantity is defined
          on or what the flux sign conventions are. We don"t attempt to
          provide precise definitions of fundumental physical quantities
          (e.g., temperature) which may be found in the literature.</p></dd></dl></div><p>When appropriate, the table entry also contains the corresponding
    GRIB parameter code(s) (from ECMWF and NCEP) and AMIP identifiers.</p><p>The standard name table is located at <a class="ulink" href="http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/cf-standard-name-table.xml" target="_top">http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/cf-standard-name-table.xml</a>
    , written in compliance with the XML format, as described in <a class="xref" href="#standard-name-table-format" title="Appendix B. Standard Name Table Format">Appendix B, <i>Standard Name Table Format</i></a>. Knowledge of the XML format is
    only necessary for application writers who plan to directly access the
    table. A formatted text version of the table is provided at <a class="ulink" href="http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/standard-name-table" target="_top">http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/standard-name-table</a>
    , and this table may be consulted in order to find the standard name that
    should be assigned to a variable. Some standard names (e.g.
    <code class="varname">region</code> and <code class="varname">area_type</code>) are used to
    indicate quantities which are permitted to take only certain standard
    values. This is indicated in the definition of the quantity in the
    standard name table, accompanied by a list or a link to a list of the
    permitted values.</p><p>Standard names by themselves are not always sufficient to describe a
    quantity. For example, a variable may contain data to which spatial or
    temporal operations have been applied. Or the data may represent an
    uncertainty in the measurement of a quantity. These quantity attributes
    are expressed as modifiers of the standard name. Modifications due to
    common statistical operations are expressed via the
    <code class="varname">cell_methods</code> attribute (see <a class="xref" href="#cell-methods" title="7.3. Cell Methods">Section 7.3, &#8220;Cell Methods&#8221;</a> and <a class="xref" href="#appendix-cell-methods" title="Appendix E. Cell Methods">Appendix E, <i>Cell Methods</i></a>).
    Other types of quantity modifiers are expressed using the optional
    modifier part of the <code class="varname">standard_name</code> attribute. The
    permissible values of these modifiers are given in <a class="xref" href="#standard-name-modifiers" title="Appendix C. Standard Name Modifiers">Appendix C, <i>Standard Name Modifiers</i></a>.</p><div class="example"><a name="idp6110352"></a><p class="title"><b>Example 3.1. Use of <code class="varname">standard_name</code></b></p><div class="example-contents"><pre class="programlisting">
float psl(lat,lon) ;
  psl:long_name = "mean sea level pressure" ;
  psl:units = "hPa" ;
  psl:standard_name = "air_pressure_at_sea_level" ;
      </pre><p>The description in the standard name table entry for
      <code class="varname">air_pressure_at_sea_level</code> clarifies that "sea level"
      refers to the mean sea level, which is close to the geoid in sea
      areas.</p></div></div><br class="example-break"><p>Here are lists of equivalences between the CF standard names and the
    standard names from the <a class="ulink" href="http://cf-pcmdi.llnl.gov/documents/cf-standard-names/ecmwf-grib-mapping" target="_top">ECMWF
    GRIB tables</a>, the <a class="ulink" href="http://cf-pcmdi.llnl.gov/documents/cf-standard-names/ncep-grib-code-cf-standard-name-mapping" target="_top">NCEP
    GRIB tables</a>, and the <a class="ulink" href="http://cf-pcmdi.llnl.gov/documents/cf-standard-names/pcmdi-name-cf-standard-name-mapping" target="_top">PCMDI
    tables</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ancillary-data"></a>3.4. Ancillary Data</h2></div></div></div><p>When one data variable provides metadata about the individual values
    of another data variable it may be desirable to express this association
    by providing a link between the variables. For example, instrument data
    may have associated measures of uncertainty. The attribute
    <code class="varname">ancillary_variables</code> is used to express these types of
    relationships. It is a string attribute whose value is a blank separated
    list of variable names. The nature of the relationship between variables
    associated via <code class="varname">ancillary_variables</code> must be determined
    by other attributes. The variables listed by the
    <code class="varname">ancillary_variables</code> attribute will often have the
    standard name of the variable which points to them including a modifier
    (<a class="xref" href="#standard-name-modifiers" title="Appendix C. Standard Name Modifiers">Appendix C, <i>Standard Name Modifiers</i></a>) to indicate the
    relationship.</p><div class="example"><a name="idp6119600"></a><p class="title"><b>Example 3.2. Instrument data</b></p><div class="example-contents"><pre class="programlisting">
  float q(time) ;
    q:standard_name = "specific_humidity" ;
    q:units = "g/g" ;
    q:ancillary_variables = "q_error_limit q_detection_limit" ;
  float q_error_limit(time)
    q_error_limit:standard_name = "specific_humidity standard_error" ;
    q_error_limit:units = "g/g" ;
  float q_detection_limit(time)
    q_detection_limit:standard_name = "specific_humidity detection_minimum" ;
    q_detection_limit:units = "g/g" ;
      </pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="flags"></a>3.5. Flags</h2></div></div></div><p>The attributes <code class="varname">flag_values</code><font style="background-color:#ffccff">, <code class="varname">flag_masks</code></font> and
    <code class="varname">flag_meanings</code> are intended to make variables that
    contain flag values self describing. <font style="background-color:#ffccff">Status codes
    and Boolean (binary) condition flags may be expressed with different
    combinations of <code class="varname">flag_values</code> and
    <code class="varname">flag_masks</code> attribute definitions.</font></p><p><font style="background-color:#ffccff">The <code class="varname">flag_values</code> and
    <code class="varname">flag_meanings</code> attributes describe a status flag
    consisting of mutually exclusive coded values.</font> The
    <code class="varname">flag_values</code> attribute is the same type as the variable
    to which it is attached, and contains a list of the possible flag values.
    The <code class="varname">flag_meanings</code> attribute is a string whose value is
    a blank separated list of descriptive words or phrases, one for each flag
    value. <font style="background-color:#ffccff">Each word or phrase should consist of
    characters from the alphanumeric set and the following five: '_', '-',
    '.', '+', '@'.</font> If multi-word phrases are used to describe the
    flag values, then the words within a phrase should be connected with
    underscores. <font style="background-color:#ffccff">The following example illustrates
    the use of flag values to express a speed quality with an enumerated
    status code.</font></p><div class="example"><a name="idp6130656"></a><p class="title"><b>Example 3.3. A flag variable<font style="background-color:#ffccff">, using
      <code class="varname">flag_values</code></font></b></p><div class="example-contents"><pre class="programlisting">
  byte current_speed_qc(time, depth, lat, lon) ;
    current_speed_qc:long_name = "Current Speed Quality" ;
    <font style="background-color:#ffccff">current_speed_qc:standard_name = "sea_water_speed status_flag" ;</font>
    current_speed_qc:_FillValue = -128b ;
    current_speed_qc:valid_range = <font style="background-color:#ffccff">0b, 2b</font><font style="background-color:#ffff88; text-decoration:line-through">-127b, 127b</font> ;
    current_speed_qc:flag_values = 0b, 1b, 2b ;
    current_speed_qc:flag_meanings = "quality_good sensor_nonfunctional 
                                      outside_valid_range" ;
      </pre></div></div><br class="example-break"><p><font style="background-color:#ffccff">The <code class="varname">flag_masks</code> and
    <code class="varname">flag_meanings</code> attributes describe a number of
    independent Boolean conditions using bit field notation by setting unique
    bits in each <code class="varname">flag_masks</code> value. <code class="varname">The
    flag_masks</code> attribute is the same type as the variable to which
    it is attached, and contains a list of values matching unique bit fields.
    The <code class="varname">flag_meanings</code> attribute is defined as above, one
    for each <code class="varname">flag_masks</code> value. A flagged condition is
    identified by performing a bitwise AND of the variable value and each
    <code class="varname">flag_masks</code> value; a non-zero result indicates a
    <code class="varname">true</code> condition. Thus, any or all of the flagged
    conditions may be <code class="varname">true</code>, depending on the variable bit
    settings. The following example illustrates the use of
    <code class="varname">flag_masks</code> to express six sensor status
    conditions.</font></p><div class="example"><a name="idp6140272"></a><p class="title"><b>Example 3.4. <font style="background-color:#ffccff">A flag variable, using
      <code class="varname">flag_masks</code></font></b></p><div class="example-contents"><pre class="programlisting"><font style="background-color:#ffccff">
  byte sensor_status_qc(time, depth, lat, lon) ;
    sensor_status_qc:long_name = "Sensor Status" ;
    sensor_status_qc:_FillValue = 0b ;
    sensor_status_qc:valid_range = 1b, 63b ;
    sensor_status_qc:flag_masks = 1b, 2b, 4b, 8b, 16b, 32b ;
    sensor_status_qc:flag_meanings = "low_battery processor_fault
                                      memory_fault disk_fault
                                      software_fault
                                      maintenance_required" ;</font>
      </pre></div></div><br class="example-break"><p><font style="background-color:#ffccff">The <code class="varname">flag_masks</code>,
    <code class="varname">flag_values</code> and <code class="varname">flag_meanings</code>
    attributes, used together, describe a blend of independent Boolean
    conditions and enumerated status codes. The <code class="varname">flag_masks</code>
    and <code class="varname">flag_values</code> attributes are both the same type as
    the variable to which they are attached. A flagged condition is identified
    by a bitwise AND of the variable value and each
    <code class="varname">flag_masks</code> value; a result that matches the
    <code class="varname">flag_values</code> value indicates a <code class="varname">true</code>
    condition. Repeated <code class="varname">flag_masks</code> define a bit field mask
    that identifies a number of status conditions with different
    <code class="varname">flag_values</code>. The <code class="varname">flag_meanings</code>
    attribute is defined as above, one for each <code class="varname">flag_masks</code>
    bit field and <code class="varname">flag_values</code> definition. Each
    <code class="varname">flag_values</code> and <code class="varname">flag_masks</code> value
    must coincide with a <code class="varname">flag_meanings</code> value. The following
    example illustrates the use of <code class="varname">flag_masks</code> and
    <code class="varname">flag_values</code> to express two sensor status conditions and
    one enumerated status code.</font></p><div class="example"><a name="idp6152064"></a><p class="title"><b>Example 3.5. <font style="background-color:#ffccff">A flag variable, using
      <code class="varname">flag_masks</code> and
      <code class="varname">flag_values</code></font></b></p><div class="example-contents"><pre class="programlisting"><font style="background-color:#ffccff">
  byte sensor_status_qc(time, depth, lat, lon) ;
    sensor_status_qc:long_name = "Sensor Status" ;
    sensor_status_qc:_FillValue = 0b ;
    sensor_status_qc:valid_range = 1b, 15b ;
    sensor_status_qc:flag_masks = 1b, 2b, 12b, 12b, 12b ;
    sensor_status_qc:flag_values = 1b, 2b, 4b, 8b, 12b ;
    sensor_status_qc:flag_meanings =
         "low_battery
          hardware_fault
          offline_mode calibration_mode maintenance_mode" ;</font>
      </pre></div></div><br class="example-break"><p><font style="background-color:#ffccff">In this case, mutually exclusive values are
    blended with Boolean values to maximize use of the available bits in a
    flag value. The table below represents the four binary digits (bits)
    expressed by the <code class="varname">sensor_status_qc</code> variable in the
    previous example.</font></p><p><font style="background-color:#ffccff">Bit 0 and Bit 1 are Boolean values
    indicating a low battery condition and a hardware fault, respectively. The
    next two bits (Bit 2 and Bit 3) express an enumeration indicating abnormal
    sensor operating modes. Thus, if Bit 0 is set, the battery is low and if
    Bit 1 is set, there is a hardware fault - independent of the current
    sensor operating mode.</font></p><div class="table"><a name="idp6157920"></a><p class="title"><b>Table 3.2. <font style="background-color:#ffccff">Flag Variable Bits (from
      Example)</font></b></p><div class="table-contents"><table summary="Flag Variable Bits (from
      Example)" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><font style="background-color:#ffccff">Bit 3 (MSB)</font></th><th align="left"><font style="background-color:#ffccff">Bit 2</font></th><th align="left"><font style="background-color:#ffccff">Bit 1</font></th><th align="left"><font style="background-color:#ffccff">Bit 0 (LSB)</font></th></tr></thead><tbody><tr><td align="left"> </td><td align="left"> </td><td align="left"><font style="background-color:#ffccff">H/W Fault</font></td><td align="left"><font style="background-color:#ffccff">Low Batt</font></td></tr></tbody></table></div></div><br class="table-break"><p><font style="background-color:#ffccff">The remaining bits (Bit 2 and Bit 3) are
    decoded as follows:</font></p><div class="table"><a name="idp6170016"></a><p class="title"><b>Table 3.3. <font style="background-color:#ffccff">Flag Variable Bit 2 and Bit 3 (from
      Example)</font></b></p><div class="table-contents"><table summary="Flag Variable Bit 2 and Bit 3 (from
      Example)" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><font style="background-color:#ffccff">Bit 3</font></th><th align="left"><font style="background-color:#ffccff">Bit 2</font></th><th align="left"><font style="background-color:#ffccff">Mode</font></th></tr></thead><tbody><tr><td align="left"><font style="background-color:#ffccff">0</font></td><td align="left"><font style="background-color:#ffccff">1</font></td><td align="left"><font style="background-color:#ffccff">offline_mode</font></td></tr><tr><td align="left"><font style="background-color:#ffccff">1</font></td><td align="left"><font style="background-color:#ffccff">0</font></td><td align="left"><font style="background-color:#ffccff">calibration_mode</font></td></tr><tr><td align="left"><font style="background-color:#ffccff">1</font></td><td align="left"><font style="background-color:#ffccff">1</font></td><td align="left"><font style="background-color:#ffccff">maintenance_mode</font></td></tr></tbody></table></div></div><br class="table-break"><p><font style="background-color:#ffccff">The "12b" flag mask is repeated in the
    <code class="varname">sensor_status_qc</code> <code class="varname">flag_masks</code>
    definition to explicitly declare the recommended bit field masks to
    repeatedly AND with the variable value while searching for matching
    enumerated values. An application determines if any of the conditions
    declared in the <code class="varname">flag_meanings</code> list are
    <code class="varname">true</code> by simply iterating through each of the
    <code class="varname">flag_masks</code> and AND'ing them with the variable. When a
    result is equal to the corresponding <code class="varname">flag_values</code>
    element, that condition is <code class="varname">true</code>. The repeated
    <code class="varname">flag_masks</code> enable a simple mechanism for clients to
    detect all possible conditions.</font></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="coordinate-types"></a>Chapter 4. 
    Coordinate Types
  </h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#latitude-coordinate">4.1. Latitude Coordinate</a></span></dt><dt><span class="section"><a href="#longitude-coordinate">4.2. Longitude Coordinate</a></span></dt><dt><span class="section"><a href="#vertical-coordinate">4.3. Vertical (Height or Depth) Coordinate</a></span></dt><dd><dl><dt><span class="section"><a href="#idp6406048">4.3.1. Dimensional Vertical Coordinate</a></span></dt><dt><span class="section"><a href="#dimensionless-vertical-coordinate">4.3.2. Dimensionless Vertical Coordinate</a></span></dt></dl></dd><dt><span class="section"><a href="#time-coordinate">4.4. Time Coordinate</a></span></dt><dd><dl><dt><span class="section"><a href="#calendar">4.4.1. Calendar</a></span></dt></dl></dd><dt><span class="section"><a href="#discrete-axis">4.5. <font style="background-color:#ffccff">Discrete Axis</font></a></span></dt></dl></div><p>
    Four types of coordinates receive special treatment by these
    conventions: latitude, longitude, vertical, and time.
    We continue to support the special role that the
    <code class="varname">units</code> and <code class="varname">positive</code> attributes
    play in the COARDS convention to identify coordinate type.
    We extend COARDS by providing explicit definitions of dimensionless
    vertical coordinates. The definitions are associated with a coordinate
    variable via the <code class="varname">standard_name</code> and
    <code class="varname">formula_terms</code> attributes. For backwards compatibility
    with COARDS use of these attributes is not required, but is strongly recommended.
  </p><p>
    Because identification of a coordinate type by its units is complicated
    by requiring the use of an external software
    package [<a href="#udunits" class="biblioref" title="[UDUNITS]"><abbr class="abbrev">UDUNITS</abbr></a>], we provide two optional
    methods that yield a direct identification.
    The attribute <code class="varname">axis</code> may be attached to a coordinate
    variable and given one of the values <code class="varname">X</code>, <code class="varname">Y</code>,
    <code class="varname">Z</code> or <code class="varname">T</code> which stand for a longitude,
    latitude, vertical, or time axis respectively.
    Alternatively the <code class="varname">standard_name</code> attribute may be used
    for direct identification. But note that these optional
    attributes are in addition to the required COARDS metadata.
  </p><p>
    Coordinate types other than latitude, longitude, vertical, and time
    are allowed. To identify generic spatial coordinates we recommend
    that the <code class="varname">axis</code> attribute be attached to these
    coordinates and given one of the values <code class="varname">X</code>, 
    <code class="varname">Y</code> or <code class="varname">Z</code>. 
    The values <code class="varname">X</code> and <code class="varname">Y</code>
    for the axis attribute should be used to identify horizontal coordinate
    variables. If both X- and Y-axis are identified, <code class="varname">X-Y-up</code>
    should define a right-handed coordinate system, i.e. rotation from the
    positive X direction to the positive Y direction is anticlockwise if 
    viewed from above.
    We strongly recommend that coordinate
    variables be used for all coordinate types whenever they are applicable.
  </p><p>
	  The methods of identifying coordinate types described in this
      section apply both to coordinate variables and to auxiliary
      coordinate variables named by the <code class="varname">coordinates</code>
      attribute (see <a class="xref" href="#coordinate-system" title="Chapter 5. Coordinate Systems">Chapter 5, <i>Coordinate Systems</i></a>).
  </p><p>
    The values of a coordinate variable or auxiliary coordinate variable 
    indicate the locations of the gridpoints. The locations of the boundaries 
    between cells are indicated by bounds variables 
    (see <a class="xref" href="#cell-boundaries" title="7.1. Cell Boundaries">Section 7.1, &#8220;Cell Boundaries&#8221;</a>). If bounds are not provided, 
    an application might reasonably assume the gridpoints to be at the 
    centers of the cells, but we do not require that in this standard.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="latitude-coordinate"></a>4.1. Latitude Coordinate</h2></div></div></div><p>
      Variables representing latitude must always explicitly include the
      <code class="varname">units</code> attribute; there is no default value.
      The <code class="varname">units</code> attribute will be a string formatted
      as per the
      <a class="ulink" href="http://www.unidata.ucar.edu/software/udunits/" target="_top"><code class="filename">udunits.dat</code></a> file.
      The recommended unit of latitude
      is <code class="varname">degrees_north</code>. Also acceptable 
      are <code class="varname">degree_north</code>, <code class="varname">degree_N</code>,
      <code class="varname">degrees_N</code>, <code class="varname">degreeN</code>,
      and <code class="varname">degreesN</code>.
    </p><div class="example"><a name="idp6373840"></a><p class="title"><b>Example 4.1. Latitude axis</b></p><div class="example-contents"><pre class="programlisting">
float lat(lat) ;
  lat:long_name = "latitude" ;
  lat:units = "degrees_north" ;
  lat:standard_name = "latitude" ;
      </pre></div></div><br class="example-break"><p>
      Application writers should note that the Udunits package does not
      recognize the directionality implied by the "north" part of the unit
      specification. It only recognizes its size, i.e., 1 degree is defined
      to be pi/180 radians. Hence, determination that a coordinate is a
      latitude type should be done via a string match between the given unit
      and one of the acceptable forms of <code class="varname">degrees_north</code>.
    </p><p>
    Optionally, the latitude type may be indicated additionally by providing
    the <code class="varname">standard_name</code> attribute with the value
    <code class="varname">latitude</code>, and/or the <code class="varname">axis</code> attribute
    with the value <code class="varname">Y</code>.
    </p><p>
    Coordinates of latitude with respect to a rotated pole should be given
    units of <code class="varname">degrees</code>, not <code class="varname">degrees_north</code>
    or equivalents, because applications which use the units to identify
    axes would have no means of distinguishing such an axis from real
    latitude, and might draw incorrect coastlines, for instance. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="longitude-coordinate"></a>4.2. Longitude Coordinate</h2></div></div></div><p>
      Variables representing longitude must always explicitly include
      the <code class="varname">units</code> attribute; there is no default value.
      The units <code class="varname">attribute</code> will be a string formatted
      as per the
      <a class="ulink" href="http://www.unidata.ucar.edu/software/udunits/" target="_top"><code class="filename">udunits.dat</code></a> file.
      The recommended unit of longitude is
      <code class="varname">degrees_east</code>. Also acceptable
      are <code class="varname">degree_east</code>, <code class="varname">degree_E</code>,
      <code class="varname">degrees_E</code>,  <code class="varname">degreeE</code>,
      and  <code class="varname">degreesE</code>.
    </p><div class="example"><a name="idp6385584"></a><p class="title"><b>Example 4.2. Longitude axis</b></p><div class="example-contents"><pre class="programlisting">
float lon(lon) ;
  lon:long_name = "longitude" ;
  lon:units = "degrees_east" ;
  lon:standard_name = "longitude" ;
      </pre></div></div><br class="example-break"><p>
      Application writers should note that the Udunits package has limited
      recognition of the directionality implied by the "east" part of the
      unit specification. It defines <code class="varname">degrees_east</code> to be
      pi/180 radians, and hence equivalent to <code class="varname">degrees_north</code>.
      We recommend the determination that a coordinate is a longitude type
      should be done via a string match between the given unit and one of the
      acceptable forms of <code class="varname">degrees_east</code>.
    </p><p>
      Optionally, the longitude type may be indicated additionally by
      providing the <code class="varname">standard_name</code> attribute with the
      value <code class="varname">longitude</code>, and/or the <code class="varname">axis</code>
      attribute with the value <code class="varname">X</code>.
    </p><p>
      Coordinates of longitude with respect to a rotated pole should be
      given units of <code class="varname">degrees</code>, not
      <code class="varname">degrees_east</code> or equivalents, because applications
      which use the units to identify axes would have no means of
      distinguishing such an axis from real longitude, and might draw
      incorrect coastlines, for instance. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="vertical-coordinate"></a>4.3. Vertical (Height or Depth) Coordinate</h2></div></div></div><p>
      Variables representing dimensional height or depth axes must always
      explicitly include the <code class="varname">units</code> attribute; there is
      no default value.
    </p><p>
      The direction of positive (i.e., the direction in which the coordinate
      values are increasing), whether up or down, cannot in all cases be
      inferred from the units. The direction of positive is useful for
      applications displaying the data. For this reason the attribute
      <code class="varname">positive</code> as defined in the COARDS standard is
      required if the vertical axis units are not a valid unit of pressure
      (a determination which can be made using the udunits routine, utScan)
      -- otherwise its inclusion is optional. The <code class="varname">positive</code>
      attribute may have the value <code class="varname">up</code> or
      <code class="varname">down</code> (case insensitive). This attribute may be
      applied to either coordinate variables or auxillary coordinate
      variables that contain vertical coordinate data.
    </p><p>
      For example, if an oceanographic netCDF file encodes the depth of
      the surface as 0 and the depth of 1000 meters as 1000 then the axis
      would use attributes as follows:
      </p><pre class="programlisting">
axis_name:units = "meters" ; 
axis_name:positive = "down" ; 	
      </pre><p>
    </p><p>
      If, on the other hand, the depth of 1000 meters were represented
      as -1000 then the value of the <code class="varname">positive</code> attribute
      would have been <code class="varname">up</code>. If the <code class="varname">units</code>
      attribute value is a valid pressure unit the default value of the
      <code class="varname">positive</code> attribute is <code class="varname">down</code>.
    </p><p>
      A vertical coordinate will be identifiable by:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	    units of pressure; or
	  </p></li><li><p>
	    the presence of the positive attribute with a value of
        <code class="varname">up</code> or <code class="varname">down</code> (case insensitive).
	  </p></li></ul></div><p>
    </p><p>
      Optionally, the vertical type may be indicated additionally by
      providing the <code class="varname">standard_name</code> attribute with an
      appropriate value, and/or the <code class="varname">axis</code> attribute
      with the value <code class="varname">Z</code>.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp6406048"></a>4.3.1. Dimensional Vertical Coordinate</h3></div></div></div><p>
	The <code class="varname">units</code> attribute for dimensional coordinates will
    be a string formatted as per the
    <a class="ulink" href="http://www.unidata.ucar.edu/software/udunits/" target="_top"><code class="filename">udunits.dat</code></a> file.
    The acceptable units for vertical (depth or height) coordinate variables are:
	</p><div class="itemizedlist"><ul type="disc"><li><p>
	      units of pressure as listed in the file <code class="filename">udunits.dat</code>.
          For vertical axes the most commonly used of these include
          include <code class="varname">bar</code>, <code class="varname">millibar</code>,
          <code class="varname">decibar</code>, <code class="varname">atmosphere (atm)</code>,
          <code class="varname">pascal (Pa)</code>, and <code class="varname">hPa</code>.
	    </p></li><li><p>
	      units of length as listed in the file udunits.dat. For vertical axes the most commonly used of these include <code class="varname">meter (metre, m)</code>, and <code class="varname">kilometer (km)</code>.
	    </p></li><li><p>
	      other units listed in the file udunits.dat that may under certain circumstances reference vertical position such as units of density or temperature.
	    </p></li></ul></div><p>
	Plural forms are also acceptable.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dimensionless-vertical-coordinate"></a>4.3.2. Dimensionless Vertical Coordinate</h3></div></div></div><p>
	The <code class="varname">units</code> attribute is not required for dimensionless coordinates. For backwards compatibility with COARDS we continue to allow the <code class="varname">units</code> attribute to take one of the values: <code class="varname">level</code>, <code class="varname">layer</code>, or <code class="varname">sigma_level</code>. These values are not recognized by the Udunits package, and are considered a deprecated feature in the CF standard.
      </p><p>
	For dimensionless vertical coordinates we extend the COARDS standard by making use of the <code class="varname">standard_name</code> attribute to associate a coordinate with its definition from <a class="xref" href="#dimensionless-v-coord" title="Appendix D. Dimensionless Vertical Coordinates">Appendix D, <i>Dimensionless Vertical Coordinates</i></a>. The definition provides a mapping between the dimensionless coordinate values and dimensional values that can positively and uniquely indicate the location of the data. A new attribute, <code class="varname">formula_terms</code>, is used to associate terms in the definitions with variables in a netCDF file. To maintain backwards compatibility with COARDS the use of these attributes is not required, but is strongly recommended.
      </p><div class="example"><a name="atm-sigma-coord-ex"></a><p class="title"><b>Example 4.3. Atmosphere sigma coordinate</b></p><div class="example-contents"><pre class="programlisting">
float lev(lev) ;
  lev:long_name = "sigma at layer midpoints" ;
  lev:positive = "down" ;
  lev:standard_name = "atmosphere_sigma_coordinate" ;
  lev:formula_terms = "sigma: lev ps: PS ptop: PTOP" ;
	</pre></div></div><br class="example-break"><p>
	 In this example the <code class="varname">standard_name</code> value 
         <code class="varname">atmosphere_sigma_coordinate</code> identifies the following 
         definition from <a class="xref" href="#dimensionless-v-coord" title="Appendix D. Dimensionless Vertical Coordinates">Appendix D, <i>Dimensionless Vertical Coordinates</i></a> which specifies 
         how to compute pressure at gridpoint <code class="varname">(n,k,j,i)</code> where 
         <code class="varname">j</code> and <code class="varname">i</code> are horizontal indices, 
         <code class="varname">k</code> is a vertical index, and <code class="varname">n</code> is a time index:
	</p><pre class="programlisting">
p(n,k,j,i) = ptop + sigma(k)*(ps(n,j,i)-ptop)
	</pre><p>
      </p><p>
	The <code class="varname">formula_terms</code> attribute associates the variable <code class="varname">lev</code> with the term <code class="varname">sigma</code>, the variable <code class="varname">PS</code> with the term <code class="varname">ps</code>, and the variable <code class="varname">PTOP</code> with the term <code class="varname">ptop</code>. Thus the pressure at gridpoint <code class="varname">(n,k,j,i)</code> would be calculated by
	</p><pre class="programlisting">
p(n,k,j,i) = PTOP + lev(k)*(PS(n,j,i)-PTOP)
	</pre><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="time-coordinate"></a>4.4. Time Coordinate</h2></div></div></div><p>
      Variables representing time must always explicitly include
      the <code class="varname">units</code> attribute; there is no default value.
      The <code class="varname">units</code> attribute takes a string value formatted
      as per the recommendations in the Udunits package [<a href="#udunits" class="biblioref" title="[UDUNITS]"><abbr class="abbrev">UDUNITS</abbr></a>].
      The following excerpt from the Udunits documentation explains the time unit encoding by example:
      </p><pre class="programlisting">
	The specification:

    seconds since 1992-10-8 15:15:42.5 -6:00

indicates seconds since October 8th, 1992  at  3  hours,  15
minutes  and  42.5 seconds in the afternoon in the time zone
which is six hours to the west of Coordinated Universal Time
(i.e.  Mountain Daylight Time).  The time zone specification
can also be written without a colon using one or  two-digits
(indicating hours) or three or four digits (indicating hours
and minutes).
      </pre><p>
    </p><p>
      The acceptable units for time are listed in the
      <a class="ulink" href="http://www.unidata.ucar.edu/software/udunits/" target="_top"><code class="filename">udunits.dat</code></a> file.
      The most commonly used of these strings (and their abbreviations)
      includes <code class="varname">day (d)</code>, <code class="varname">hour (hr, h)</code>,
      <code class="varname">minute (min)</code> and <code class="varname">second (sec, s)</code>.
      Plural forms are also acceptable. The reference time string
      (appearing after the identifier <code class="varname">since</code>) may
      include date alone; date and time; or date, time, and time zone.
      The reference time is required. A reference time in year 0 has a
      special meaning (see <a class="xref" href="#climatological-statistics" title="7.4. Climatological Statistics">Section 7.4, &#8220;Climatological Statistics&#8221;</a>).
    </p><p>
      <span class="emphasis"><em>Note: if the time zone is omitted the default is UTC, and if both time and time zone are omitted the default is 00:00:00 UTC.</em></span>
    </p><p>
      We recommend that the unit <code class="varname">year</code> be used with caution. The Udunits package defines a <code class="varname">year</code> to be exactly 365.242198781 days (the interval between 2 successive passages of the sun through vernal equinox). <span class="emphasis"><em>It is not a calendar year.</em></span> Udunits includes the following definitions for years: a <code class="varname">common_year</code> is 365 days, a <code class="varname">leap_year</code> is 366 days, a <code class="varname">Julian_year</code> is 365.25 days, and a <code class="varname">Gregorian_year</code> is 365.2425 days.
    </p><p>
      For similar reasons the unit <code class="varname">month</code>, which is defined in
      <a class="ulink" href="http://www.unidata.ucar.edu/software/udunits/" target="_top"><code class="filename">udunits.dat</code></a>
      to be exactly <code class="varname">year/12</code>, should also be used with caution.
    </p><div class="example"><a name="idp6446256"></a><p class="title"><b>Example 4.4. Time axis</b></p><div class="example-contents"><pre class="programlisting">
double time(time) ;
  time:long_name = "time" ;
  time:units = "days since 1990-1-1 0:0:0" ;
      </pre></div></div><br class="example-break"><p>
      A time coordinate is identifiable from its units string alone. The Udunits routines <code class="varname">utScan()</code> and <code class="varname">utIsTime()</code> can be used to make this determination.
    </p><p>
      Optionally, the time coordinate may be indicated additionally by providing the <code class="varname">standard_name</code> attribute with an appropriate value, and/or the <code class="varname">axis</code> attribute with the value <code class="varname">T</code>.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="calendar"></a>4.4.1. Calendar</h3></div></div></div><p>
	In order to calculate a new date and time given a base date, base time and a time increment one must know what calendar to use. For this purpose we recommend that the calendar be specified by the attribute <code class="varname">calendar</code> which is assigned to the time coordinate variable. The values currently defined for <code class="varname">calendar</code> are:
	</p><div class="variablelist"><dl><dt><span class="term"> <code class="varname">gregorian</code> or <code class="varname">standard</code> </span></dt><dd><p>
		Mixed Gregorian/Julian calendar as defined by Udunits. <span class="emphasis"><em>This is the default.</em></span>
	      </p></dd><dt><span class="term"> <code class="varname">proleptic_gregorian</code> </span></dt><dd><p>
		A Gregorian calendar extended to dates before 1582-10-15. That is, a year is a leap year if either (i) it is divisible by 4 but not by 100 or (ii) it is divisible by 400.
	      </p></dd><dt><span class="term"> <code class="varname">noleap</code> or <code class="varname">365_day</code> </span></dt><dd><p>
		Gregorian calendar without leap years, i.e., all years are 365 days long. 
	      </p></dd><dt><span class="term"> <code class="varname">all_leap</code> or <code class="varname">366_day</code> </span></dt><dd><p>
		Gregorian calendar with every year being a leap year, i.e., all years are 366 days long.
	      </p></dd><dt><span class="term"> <code class="varname">360_day</code> </span></dt><dd><p>
		All years are 360 days divided into 30 day months.
	      </p></dd><dt><span class="term"> <code class="varname">julian</code> </span></dt><dd><p>
		Julian calendar. 
	      </p></dd><dt><span class="term"> <code class="varname">none</code> </span></dt><dd><p>
		No calendar.
	      </p></dd></dl></div><p>
      </p><p>
	The <code class="varname">calendar</code> attribute may be set to <code class="varname">none</code> in climate experiments that simulate a fixed time of year. The time of year is indicated by the date in the reference time of the <code class="varname">units</code> attribute. The time coordinate that might apply in a perpetual July experiment are given in the following example.
      </p><div class="example"><a name="idp6470624"></a><p class="title"><b>Example 4.5. Perpetual time axis</b></p><div class="example-contents"><pre class="programlisting">
variables:
  double time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1-7-15 0:0:0" ;
    time:calendar = "none" ;
data:
  time = 0., 1., 2., ...;
      </pre></div></div><br class="example-break"><p>
	Here, all days simulate the conditions of 15th July, so it does not make sense to give them different dates. The time coordinates are interpreted as 0, 1, 2, etc. days since the start of the experiment.
      </p><p>
	If none of the calendars defined above applies (e.g., calendars appropriate to a different paleoclimate era), a non-standard calendar can be defined. The lengths of each month are explicitly defined with the <code class="varname">month_lengths</code> attribute of the time axis: 
	</p><div class="variablelist"><dl><dt><span class="term"><code class="varname">month_lengths</code></span></dt><dd><p>
		A vector of size 12, specifying the number of days in the months from January to December (in a non-leap year).
	      </p></dd></dl></div><p>
      </p><p>
	If leap years are included, then two other attributes of the time axis should also be defined:
	</p><div class="variablelist"><dl><dt><span class="term"><code class="varname">leap_year</code></span></dt><dd><p>
		An example of a leap year. It is assumed that all years that differ from this year by a multiple of four are also leap years. If this attribute is absent, it is assumed there are no leap years.
	      </p></dd><dt><span class="term"><code class="varname">leap_month</code></span></dt><dd><p>
		A value in the range 1-12, specifying which month is lengthened by a day in leap years (1=January). If this attribute is not present, February (2) is assumed. This attribute is ignored if <code class="varname">leap_year</code> is not specified.
	      </p></dd></dl></div><p>
      </p><p>
	The <code class="varname">calendar</code> attribute is not required when a non-standard calendar is being used. It is sufficient to define the calendar using the <code class="varname">month_lengths</code> attribute, along with <code class="varname">leap_year</code>, and <code class="varname">leap_month</code> as appropriate. However, the <code class="varname">calendar</code> attribute is allowed to take non-standard values and in that case defining the non-standard calendar using the appropriate attributes is required.
      </p><div class="example"><a name="idp6483520"></a><p class="title"><b>Example 4.6. Paleoclimate time axis</b></p><div class="example-contents"><pre class="programlisting">
double time(time) ;
  time:long_name = "time" ;
  time:units = "days since 1-1-1 0:0:0" ;
  time:calendar = "126 kyr B.P." ;
  time:month_lengths = 34, 31, 32, 30, 29, 27, 28, 28, 28, 32, 32, 34 ;
	</pre></div></div><br class="example-break"><p>
	The mixed Gregorian/Julian calendar used by Udunits is explained in the following excerpt from the udunits(3) man page:
	</p><pre class="programlisting">
The udunits(3) package uses a mixed Gregorian/Julian  calen-
dar  system.   Dates  prior to 1582-10-15 are assumed to use
the Julian calendar, which was introduced by  Julius  Caesar
in 46 BCE and is based on a year that is exactly 365.25 days
long.  Dates on and after 1582-10-15 are assumed to use  the
Gregorian calendar, which was introduced on that date and is
based on a year that is exactly 365.2425 days long.  (A year
is  actually  approximately 365.242198781 days long.)  Seem-
ingly strange behavior of the udunits(3) package can  result
if  a user-given time interval includes the changeover date.
For example, utCalendar() and utInvCalendar() can be used to
show that 1582-10-15 *preceded* 1582-10-14 by 9 days.
	</pre><p>
      </p><p>
	Due to problems caused by the discontinuity in the default mixed Gregorian/Julian calendar, we strongly recommend that this calendar should only be used when the time coordinate does not cross the discontinuity. For time coordinates that do cross the discontinuity the <code class="varname">proleptic_gregorian</code> calendar should be used instead.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="discrete-axis"></a>4.5. <font style="background-color:#ffccff">Discrete Axis</font></h2></div></div></div><p><font style="background-color:#ffccff">The spatiotemporal coordinates described in sections 4.1-4.4 are continuous variables, and other geophysical quantities may likewise serve as continuous coordinate variables, for instance density, temperature or radiation wavelength. By contrast, for some purposes there is a need for an axis of a data variable which indicates either an ordered list or an unordered collection, and does not correspond to any continuous coordinate variable. Consequently such an axis may be called &#8220;discrete&#8221;. A discrete axis has a dimension but might not have a coordinate variable. Instead, there might be one or more auxiliary coordinate variables with this dimension (see preamble to section 5). Following sections define various applications of discrete axes, for instance section 6.1.1 &#8220;Geographical regions&#8221;, section 7.3.3 &#8220;Statistics applying to portions of cells&#8221;, section 9.3 &#8220;Representation of collections of features in data variables&#8221;.</font></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="coordinate-system"></a>Chapter 5. Coordinate Systems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idp6655904">5.1. Independent Latitude, Longitude, Vertical, and Time Axes</a></span></dt><dt><span class="section"><a href="#idp6661440">5.2. Two-Dimensional Latitude, Longitude, Coordinate Variables</a></span></dt><dt><span class="section"><a href="#reduced-horizontal-grid">5.3. Reduced Horizontal Grid</a></span></dt><dt><span class="section"><a href="#idp6679280">5.4. <font style="background-color:#ffff88; text-decoration:line-through">Timeseries of Station
    Data</font></a></span></dt><dt><span class="section"><a href="#idp6687840">5.5. <font style="background-color:#ffff88; text-decoration:line-through">Trajectories</font></a></span></dt><dt><span class="section"><a href="#grid-mappings-and-projections">5.6. <font style="background-color:#ffff88; text-decoration:line-through">Grid Mappings and
    Projections</font><font style="background-color:#ffccff">Horizontal Coordinate
    Reference Systems, Grid Mappings, and Projections</font></a></span></dt><dd><dl><dt><span class="section"><a href="#idp6737680">5.6.1. <font style="background-color:#ffccff">Use of the CRS Well-known Text
      Format</font></a></span></dt></dl></dd><dt><span class="section"><a href="#scalar-coordinate-variables">5.7. Scalar Coordinate Variables</a></span></dt></dl></div><p>A variable's spatiotemporal dimensions are used to locate data values
  in time and space. This is accomplished by associating these dimensions with
  the relevant set of latitude, longitude, vertical, and time coordinates.
  This section presents two methods for making that association: the use of
  <span class="emphasis"><em>coordinate variables</em></span>, and the use of
  <span class="emphasis"><em>auxiliary coordinate variables</em></span>.</p><p>All of a variable's dimensions that are latitude, longitude, vertical,
  or time dimensions (see <a class="xref" href="#terminology" title="1.2. Terminology">Section 1.2, &#8220;Terminology&#8221;</a>) must have
  corresponding coordinate variables, i.e., one-dimensional variables with the
  same name as the dimension (see examples in <a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a>). This is the only method of associating
  dimensions with coordinates that is supported by [<a href="#coards" class="biblioref" title="[COARDS]"><abbr class="abbrev">COARDS</abbr></a>].</p><p>All of a variable's spatiotemporal dimensions that are not latitude,
  longitude, vertical, or time dimensions are required to be associated with
  the relevant latitude, longitude, vertical, or time coordinates via the new
  <code class="varname">coordinates</code> attribute of the variable. The value of the
  <code class="varname">coordinates</code> attribute is <span class="emphasis"><em>a blank separated list
  of the names of auxiliary coordinate variables</em></span>. There is no
  restriction on the order in which the auxiliary coordinate variables appear
  in the <code class="varname">coordinates</code> attribute string. <font style="background-color:#ffff88; text-decoration:line-through"> The dimensions of an auxiliary coordinate variable must
  be a subset of the dimensions of the variable with which the coordinate is
  associated (an exception is label coordinates (<a class="xref" href="#labels" title="6.1. Labels">Section 6.1, &#8220;Labels&#8221;</a>)
  which contain a dimension for maximum string length).</font> <font style="background-color:#ffccff"> The dimensions of an auxiliary coordinate variable must be a
  subset of the dimensions of the variable with which the coordinate is
  associated, with two exceptions. First, string-valued coordinates (<a class="xref" href="#labels" title="6.1. Labels">Section 6.1, &#8220;Labels&#8221;</a>) have a dimension for maximum string length. Second, in
  the ragged array representations of data (<a class="xref" href="#discrete-sampling-geometries" title="Chapter 9. Discrete Sampling Geometries">Chapter 9, <i><font style="background-color:#ffccff">Discrete Sampling Geometries</font></i></a>), special methods are needed to
  connect the data and coordinates </font></p><p>We recommend that the name of a multidimensional coordinate variable
  should not match the name of any of its dimensions because that precludes
  supplying a coordinate variable for the dimension. This practice also avoids
  potential bugs in applications that determine coordinate variables by only
  checking for a name match between a dimension and a variable and not
  checking that the variable is one dimensional.</p><p>The use of coordinate variables is required whenever they are
  applicable. That is, auxiliary coordinate variables may not be used as the
  only way to identify latitude and longitude coordinates that could be
  identified using coordinate variables. This is both to enhance conformance
  to COARDS and to facilitate the use of generic applications that recognize
  the NUG convention for coordinate variables. An application that is trying
  to find the latitude coordinate of a variable should always look first to
  see if any of the variable's dimensions correspond to a latitude coordinate
  variable. If the latitude coordinate is not found this way, then the
  auxiliary coordinate variables listed by the <code class="varname">coordinates</code>
  attribute should be checked. Note that it is permissible, but optional, to
  list coordinate variables as well as auxiliary coordinate variables in the
  <code class="varname">coordinates</code> attribute.</p><p>If an <code class="varname">axis</code> attribute is attached to an auxiliary
  coordinate variable, it can be used by applications in the same way the
  <code class="varname">axis</code> attribute attached to a coordinate variable is used.
  However, it is not permissible for a data variable to have both a coordinate
  variable and an auxiliary coordinate variable, or more than one of either
  type of variable, having an <code class="varname">axis</code> attribute with any given
  value e.g. there must be no more than one <code class="varname">axis</code> attribute
  for <code class="varname">X</code> for any data variable. Note that if the
  <code class="varname">axis</code> attribute is not specified for an auxiliary
  coordinate variable, it may still be possible to determine if it is a
  spatiotemporal dimension from its own units or standard_name, or from the
  units and standard_name of the coordinate variable corresponding to its
  dimensions (see <a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a> ). For instance,
  auxiliary coordinate variables which lie on the horizontal surface can be
  identified as such by their dimensions being horizontal. Horizontal
  dimensions are those whose coordinate variables have an
  <code class="varname">axis</code> attribute of <code class="varname">X</code> or
  <code class="varname">Y</code>, or a <code class="varname">units</code> attribute indicating
  latitude and longitude.</p><p>If the coordinate variables for a horizontal grid are not longitude
  and latitude, it is recommended that they be supplied <span class="emphasis"><em>in
  addition</em></span> to the required coordinates. For example, the Cartesian
  coordinates of a map projection should be supplied as coordinate variables
  in addition to the required two-dimensional latitude and longitude variables
  that are identified via the <code class="varname">coordinates</code> attribute. The
  use of the <code class="varname">axis</code> attribute with values
  <code class="varname">X</code> and <code class="varname">Y</code> is recommended for the
  coordinate variables(see <a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a>).</p><p>It is sometimes not practical to specify the latitude-longitude
  location of data which is representative of geographic regions with complex
  boundaries. For this purpose, provision is made in <a class="xref" href="#geographic-regions" title="6.1.1. Geographic Regions">Section 6.1.1, &#8220;Geographic Regions&#8221;</a> for indicating the region by a standardized
  name.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6655904"></a>5.1. Independent Latitude, Longitude, Vertical, and Time Axes</h2></div></div></div><p>When each of a variable's spatiotemporal dimensions is a latitude,
    longitude, vertical, or time dimension, then each axis is identified by a
    coordinate variable.</p><div class="example"><a name="idp6657200"></a><p class="title"><b>Example 5.1. Independent coordinate variables</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  lat = 18 ;
  lon = 36 ;
  pres = 15 ;
  time = 4 ;
variables:
  float xwind(time,pres,lat,lon) ;
    xwind:long_name = "zonal wind" ;
    xwind:units = "m/s" ;
  float lon(lon) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
  float lat(lat) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
  float pres(pres) ;
    pres:long_name = "pressure" ;
    pres:units = "hPa" ;
  double time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1990-1-1 0:0:0" ;
      </pre></div></div><br class="example-break"><p><code class="varname">xwind(n,k,j,i)</code> is associated with the coordinate
    values <code class="varname">lon(i)</code>, <code class="varname">lat(j)</code>,
    <code class="varname">pres(k)</code>, and <code class="varname">time(n)</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6661440"></a>5.2. Two-Dimensional Latitude, Longitude, Coordinate Variables</h2></div></div></div><p>The latitude and longitude coordinates of a horizontal grid that was
    not defined as a Cartesian product of latitude and longitude axes, can
    sometimes be represented using two-dimensional coordinate variables. These
    variables are identified as coordinates by use of the
    <code class="varname">coordinates</code> attribute.</p><div class="example"><a name="idp6663232"></a><p class="title"><b>Example 5.2. Two-dimensional coordinate variables</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  xc = 128 ;
  yc = 64 ;
  lev = 18 ;
variables:
  float T(lev,yc,xc) ;
    T:long_name = "temperature" ;
    T:units = "K" ;
    T:coordinates = "lon lat" ;
  float xc(xc) ;
    xc:axis = "X" ;
    xc:long_name = "x-coordinate in Cartesian system" ;
    xc:units = "m" ;
  float yc(yc) ;
    yc:axis = "Y" ;
    yc:long_name = "y-coordinate in Cartesian system" ;
    yc:units = "m" ;
  float lev(lev) ;
    lev:long_name = "pressure level" ;
    lev:units = "hPa" ;
  float lon(yc,xc) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
  float lat(yc,xc) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
      </pre></div></div><br class="example-break"><p><code class="varname">T(k,j,i)</code> is associated with the coordinate values
    <code class="varname">lon(j,i)</code>, <code class="varname">lat(j,i)</code>, and
    <code class="varname">lev(k)</code>. The vertical coordinate is represented by the
    coordinate variable <code class="varname">lev(lev)</code> and the latitude and
    longitude coordinates are represented by the auxiliary coordinate
    variables <code class="varname">lat(yc,xc)</code> and <code class="varname">lon(yc,xc)</code>
    which are identified by the <code class="varname">coordinates</code>
    attribute.</p><p>Note that coordinate variables are also defined for the
    <code class="varname">xc</code> and <code class="varname">yc</code> dimensions. This
    faciliates processing of this data by generic applications that don't
    recognize the multidimensional latitude and longitude coordinates.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reduced-horizontal-grid"></a>5.3. Reduced Horizontal Grid</h2></div></div></div><p>A "reduced" longitude-latitude grid is one in which the points are
    arranged along constant latitude lines with the number of points on a
    latitude line decreasing toward the poles. Storing this type of gridded
    data in two-dimensional arrays wastes space, and results in the presence
    of missing values in the 2D coordinate variables. We recommend that this
    type of gridded data be stored using the compression scheme described in
    <a class="xref" href="#compression-by-gathering" title="8.2. Compression by Gathering">Section 8.2, &#8220;Compression by Gathering&#8221;</a>. Compression by gathering
    preserves structure by storing a set of indices that allows an application
    to easily scatter the compressed data back to two-dimensional arrays. The
    compressed latitude and longitude auxiliary coordinate variables are
    identified by the <code class="varname">coordinates</code> attribute.</p><div class="example"><a name="idp6673280"></a><p class="title"><b>Example 5.3. Reduced horizontal grid</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  londim = 128 ;
  latdim = 64 ;
  rgrid = 6144 ;
variables:
  float PS(rgrid) ;
    PS:long_name = "surface pressure" ;
    PS:units = "Pa" ;
    PS:coordinates = "lon lat" ;
  float lon(rgrid) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
  float lat(rgrid) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
  int rgrid(rgrid);
    rgrid:compress = "latdim londim";
      </pre></div></div><br class="example-break"><p><code class="varname">PS(n)</code> is associated with the coordinate values
    <code class="varname">lon(n)</code>, <code class="varname">lat(n)</code>. Compressed grid
    index <code class="varname">(n)</code> would be assigned to 2D index
    <code class="varname">(j,i)</code> (C index conventions) where </p><pre class="programlisting">
j = rgrid(n) / 128
i = rgrid(n) - 128*j
      </pre><p>Notice that even if an application does not recognize the
    <code class="varname">compress</code> attribute, the grids stored in this format can
    still be handled, by an application that recognizes the
    <code class="varname">coordinates</code> attribute.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6679280"></a>5.4. <font style="background-color:#ffff88; text-decoration:line-through">Timeseries of Station
    Data</font></h2></div></div></div><p><font style="background-color:#88ff88; font-style:italic">This section has been superseded by the
    treatment of time series as a type of discrete sampling geometry in
    Chapter 9.</font></p><p><font style="background-color:#ffff88; text-decoration:line-through"> To represent data at scattered points
    it is convenient to use a variable with one dimension to represent the
    measurement locations. Auxiliary coordinate variables are used to
    associate a single spatial dimension with multiple independent
    coordinates. </font></p><div class="example"><a name="idp6682224"></a><p class="title"><b>Example 5.4. <font style="background-color:#ffff88; text-decoration:line-through">Timeseries of station
      data</font></b></p><div class="example-contents"><pre class="programlisting"><font style="background-color:#ffff88; text-decoration:line-through">
dimensions:
  station = 10 ;  // measurement locations
  pressure = 11 ; // pressure levels
  time = UNLIMITED ;
variables:
  float humidity(time,pressure,station) ;
    humidity:long_name = "specific humidity" ;
    humidity:coordinates = "lat lon" ;
  double time(time) ;
    time:long_name = "time of measurement" ;
    time:units = "days since 1970-01-01 00:00:00" ;
  float lon(station) ;
    lon:long_name = "station longitude";
    lon:units = "degrees_east";
  float lat(station) ;
    lat:long_name = "station latitude" ;
    lat:units = "degrees_north" ;
  float pressure(pressure) ;
    pressure:long_name = "pressure" ;
    pressure:units = "hPa" ;
      </font></pre></div></div><br class="example-break"><p><font style="background-color:#ffff88; text-decoration:line-through"> <code class="varname">humidity(n,k,i)</code> is
    associated with the coordinate values <code class="varname">time(n)</code>,
    <code class="varname">pressure(k)</code>, <code class="varname">lat(i)</code>, and
    <code class="varname">lon(i)</code>. </font></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp6687840"></a>5.5. <font style="background-color:#ffff88; text-decoration:line-through">Trajectories</font></h2></div></div></div><p><font style="background-color:#88ff88; font-style:italic">This section has been superseded by the
    treatment of trajectories as a type of discrete sampling geometry in
    Chapter 9.</font></p><p><font style="background-color:#ffff88; text-decoration:line-through"> A possible representation of the
    spatiotemporal locations of measurements along a flight path is to use
    time to parameterize the trajectory and use auxiliary coordinate variables
    to provide the spatial locations. </font></p><div class="example"><a name="idp6690736"></a><p class="title"><b>Example 5.5. <font style="background-color:#ffff88; text-decoration:line-through">Trajectories</font></b></p><div class="example-contents"><pre class="programlisting"><font style="background-color:#ffff88; text-decoration:line-through">
dimensions:
  time = 1000 ;
variables:
  float O3(time) ;
    O3:long_name = "ozone concentration" ;
    O3:units = "1e-9" ;
    O3:coordinates = "lon lat z" ;
  double time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1970-01-01 00:00:00" ;
  float lon(time) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
  float lat(time) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
  float z(time) ;
    z:long_name = "height above mean sea level" ;
    z:units = "km" ;
    z:positive = "up" ;
      </font></pre></div></div><br class="example-break"><p><font style="background-color:#ffff88; text-decoration:line-through"> <code class="varname">O3(n)</code> is associated
    with the coordinate values <code class="varname">time(n)</code>,
    <code class="varname">z(n)</code>, <code class="varname">lat(n)</code>, and
    <code class="varname">lon(n)</code>. </font></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="grid-mappings-and-projections"></a>5.6. <font style="background-color:#ffff88; text-decoration:line-through">Grid Mappings and
    Projections</font><font style="background-color:#ffccff">Horizontal Coordinate
    Reference Systems, Grid Mappings, and Projections</font></h2></div></div></div><p>When the coordinate variables for a horizontal grid are not
    longitude and latitude, it is required that the true latitude and
    longitude coordinates be supplied via the <code class="varname">coordinates</code>
    attribute. If in addition it is desired to describe the mapping between
    the given coordinate variables and the true latitude and longitude
    coordinates, the attribute <code class="varname">grid_mapping</code> may be used to
    supply this description. This attribute is attached to data variables so
    that variables with different mappings may be present in a single file.
    The attribute takes a string value which is the name of another variable
    in the file that provides the description of the mapping via a collection
    of attached attributes. This variable is called <span class="emphasis"><em>a grid mapping
    variable</em></span> and is of arbitrary type since it contains no data.
    Its purpose is to act as a container for the attributes that define the
    mapping. The one attribute that all grid mapping variables must have is
    <code class="varname">grid_mapping_name</code> which takes a string value that
    contains the mapping's name. The other attributes that define a specific
    mapping depend on the value of <code class="varname">grid_mapping_name</code>. The
    valid values of <code class="varname">grid_mapping_name</code> along with the
    attributes that provide specific map parameter values are described in
    <a class="xref" href="#appendix-grid-mappings" title="Appendix F. Grid Mappings">Appendix F, <i>Grid Mappings</i></a>.</p><p><font style="background-color:#ffccff">When the coordinate variables for a
    horizontal grid are longitude and latitude, a grid mapping variable with
    <code class="varname">grid_mapping_name</code> of
    <code class="varname">latitude_longitude</code> may be used to specify the ellipsoid
    and prime meridian.</font></p><p>In order to make use of a grid mapping to directly calculate
    latitude and longitude values it is necessary to associate the coordinate
    variables with the independent variables of the mapping. This is done by
    assigning a <code class="varname">standard_name</code> to the coordinate variable.
    The appropriate values of the <code class="varname">standard_name</code> depend on
    the grid mapping and are given in <a class="xref" href="#appendix-grid-mappings" title="Appendix F. Grid Mappings">Appendix F, <i>Grid Mappings</i></a>.</p><div class="example"><a name="idp6634192"></a><p class="title"><b>Example 5.6. Rotated pole grid</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  rlon = 128 ;
  rlat = 64 ;
  lev = 18 ;
variables:
  float T(lev,rlat,rlon) ;
    T:long_name = "temperature" ;
    T:units = "K" ;
    T:coordinates = "lon lat" ;
    T:grid_mapping = "rotated_pole" ;
  char rotated_pole
    rotated_pole:grid_mapping_name = "rotated_latitude_longitude" ;
    rotated_pole:grid_north_pole_latitude = 32.5 ;
    rotated_pole:grid_north_pole_longitude = 170. ;
  float rlon(rlon) ;
    rlon:long_name = "longitude in rotated pole grid" ;
    rlon:units = "degrees" ;
    rlon:standard_name = "grid_longitude";
  float rlat(rlat) ;
    rlat:long_name = "latitude in rotated pole grid" ;
    rlat:units = "degrees" ;
    rlon:standard_name = "grid_latitude";
  float lev(lev) ;
    lev:long_name = "pressure level" ;
    lev:units = "hPa" ;
  float lon(rlat,rlon) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
  float lat(rlat,rlon) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
      </pre></div></div><br class="example-break"><p>A CF compliant application can determine that rlon and rlat are
    longitude and latitude values in the rotated grid by recognizing the
    standard names <code class="varname">grid_longitude</code> and
    <code class="varname">grid_latitude</code>. Note that the units of the rotated
    longitude and latitude axes are given as <code class="varname">degrees</code>. This
    should prevent a COARDS compliant application from mistaking the variables
    <code class="varname">rlon</code> and <code class="varname">rlat</code> to be actual longitude
    and latitude coordinates. The entries for these names in the standard name
    table indicate the appropriate sign conventions for the units of
    <code class="varname">degrees</code>.</p><div class="example"><a name="lambert-conformal-projection"></a><p class="title"><b>Example 5.7. Lambert conformal projection</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  y = 228;
  x = 306;
  time = 41;

variables:
  int Lambert_Conformal;
    Lambert_Conformal:grid_mapping_name = "lambert_conformal_conic";
    Lambert_Conformal:standard_parallel = 25.0;
    Lambert_Conformal:longitude_of_central_meridian = 265.0;
    Lambert_Conformal:latitude_of_projection_origin = 25.0;
  double y(y);
    y:units = "km";
    y:long_name = "y coordinate of projection";
    y:standard_name = "projection_y_coordinate";
  double x(x);
    x:units = "km";
    x:long_name = "x coordinate of projection";
    x:standard_name = "projection_x_coordinate";
  double lat(y, x);
    lat:units = "degrees_north";
    lat:long_name = "latitude coordinate";
    lat:standard_name = "latitude";
  double lon(y, x);
    lon:units = "degrees_east";
    lon:long_name = "longitude coordinate";
    lon:standard_name = "longitude";
  int time(time);
    time:long_name = "forecast time";
    time:units = "hours since 2004-06-23T22:00:00Z";
  float Temperature(time, y, x);
    Temperature:units = "K";
    Temperature:long_name = "Temperature @ surface";
    Temperature:missing_value = 9999.0;
    Temperature:coordinates = "lat lon";
    Temperature:grid_mapping = "Lambert_Conformal";
      </pre><p>An application can determine that <code class="varname">x</code> and
      <code class="varname">y</code> are the projection coordinates by recognizing the
      standard names <code class="varname">projection_x_coordinate</code> and
      <code class="varname">projection_y_coordinate</code>. The grid mapping variable
      <code class="varname">Lambert_Conformal</code> contains the mapping parameters as
      attributes, and is associated with the <code class="varname">Temperature</code>
      variable via its <code class="varname">grid_mapping attribute</code>.</p></div></div><br class="example-break"><div class="example"><a name="latitude-and-longitude-on-a-spherical-earth"></a><p class="title"><b>Example 5.8. <font style="background-color:#ffccff">Latitude and longitude on a spherical
      Earth</font></b></p><div class="example-contents"><pre class="programlisting">
<font style="background-color:#ffccff">dimensions:
  lat = 18 ;
  lon = 36 ;
variables:
  double lat(lat) ;
  double lon(lon) ;
  float temp(lat, lon) ;
    temp:long_name = "temperature" ;
    temp:units = "K" ;
    temp:grid_mapping = "crs" ;
  int crs ;
    crs:grid_mapping_name = "latitude_longitude"
    crs:semi_major_axis = 6371000.0 ;
    crs:inverse_flattening = 0 ;</font>
      </pre></div></div><br class="example-break"><div class="example"><a name="latitude-and-longitude-on-the-wgs-1984-datum"></a><p class="title"><b>Example 5.9. <font style="background-color:#ffccff">Latitude and longitude on the WGS 1984
      datum</font></b></p><div class="example-contents"><pre class="programlisting">
<font style="background-color:#ffccff">dimensions:
  lat = 18 ;
  lon = 36 ;
variables:
  double lat(lat) ;
  double lon(lon) ;
  float temp(lat, lon) ;
    temp:long_name = "temperature" ;
    temp:units = "K" ;
    temp:grid_mapping = "crs" ;
  int crs ;
    crs:grid_mapping_name = "latitude_longitude";
    crs:longitude_of_prime_meridian = 0.0 ;
    crs:semi_major_axis = 6378137.0 ;
    crs:inverse_flattening = 298.257223563 ;</font>
      </pre></div></div><br class="example-break"><div class="example"><a name="british-national-grid"></a><p class="title"><b>Example 5.10. <font style="background-color:#ffccff">British National Grid</font></b></p><div class="example-contents"><pre class="programlisting">
<font style="background-color:#ffccff">dimensions:
  lat = 648 ;
  lon = 648 ;
  y = 18 ;
  x = 36 ;
variables:
  double x(x) ;
    x:standard_name = "projection_x_coordinate" ;
    x:units = "m" ;
  double y(y) ;
    y:standard_name = "projection_y_coordinate" ;
    y:units = "m" ;
  double lat(y, x) ;
  double lon(y, x) ;
  float temp(y, x) ;
    temp:long_name = "temperature" ;
    temp:units = "K" ;
    temp:coordinates = "lat lon" ;
    temp:grid_mapping = "crs" ;
  int crs ;
    crs:grid_mapping_name = "transverse_mercator";
    crs:semi_major_axis = 6377563.396 ;
    crs:semi_minor_axis = 6356256.910 ;
    crs:inverse_flattening = 299.3249646 ;
    crs:latitude_of_projection_origin = 49.0 ;
    crs:longitude_of_projection_origin = -2.0 ;
    crs:false_easting = 400000.0 ;
    crs:false_northing = -100000.0 ;
    crs:scale_factor_at_central_meridian = 0.9996012717 ;</font>
      </pre></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp6737680"></a>5.6.1. <font style="background-color:#ffccff">Use of the CRS Well-known Text
      Format</font></h3></div></div></div><p><font style="background-color:#ffccff">An optional grid mapping attribute called
      <code class="varname">crs_wkt</code> may be used to specify multiple coordinate
      system properties in so-called <span class="emphasis"><em>well-known text</em></span>
      format (usually abbreviated to CRS WKT or OGC WKT). The CRS WKT format
      is widely recognised and used within the geoscience software community.
      As such it represents a versatile mechanism for encoding information
      about a variety of coordinate reference system parameters in a highly
      compact notational form.</font></p><p><font style="background-color:#ffccff">The <code class="varname">crs_wkt </code>attribute
      should comprise a text string that conforms to the WKT syntax as
      specified in reference [[<a href="#OGC_CTS" class="biblioref" title="[OGC_CTS]"><abbr class="abbrev"><font style="background-color:#ffccff">OGC_CTS</font></abbr></a>]]. If desired the
      text string may contain embedded newline characters to aid human
      readability. However, any such characters are purely cosmetic and do not
      alter the meaning of the attribute value. It is envisaged that the value
      of the <code class="varname">crs_wkt</code> attribute typically will be a single
      line of text, one intended primarily for machine processing. Other than
      the requirement to be a valid WKT string, the CF convention does not
      prescribe the content of the <code class="varname">crs_wkt</code> attribute since
      it will necessarily be context-dependent.</font></p><p><font style="background-color:#ffccff">The <code class="varname">crs_wkt</code> attribute
      is intended to act as a supplement to other single-property CF grid
      mapping attributes (as described in Appendix F); it is not intended to
      replace those attributes. If data producers omit the single-property
      grid mapping attributes in favour of the compound
      <code class="varname">crs_wkt</code> attribute, software which cannot interpret
      <code class="varname">crs_wkt</code> will be unable to use the grid_mapping
      information. Therefore the CRS should be described as thoroughly as
      possible with the single-property attributes as well as by
      <code class="varname">crs_wkt</code>.</font></p><p><font style="background-color:#ffccff">There will be occasions when a given CRS
      property value is duplicated in both a single-property grid mapping
      attribute and the <code class="varname">crs_wkt</code> attribute. In such cases
      the onus is on data producers to ensure that the property values are
      consistent. However, in those situations where two values of a given
      property are different, then the value specified by the single-property
      attribute shall take precedence. For example, if the semi-major axis
      length of the ellipsoid is defined by the grid mapping attribute
      <code class="varname">semi_major_axis</code> and also by the
      <code class="varname">crs_wkt</code> attribute (via the WKT
      <code class="varname">SPHEROID</code>[...] element) then the former, being the
      more specific attribute, takes precedence. Naturally if the two values
      are equal then no ambiguity arises.</font></p><p><font style="background-color:#ffccff">Likewise, in those cases where the value
      of a CRS WKT element should be used consistently across the CF-netCDF
      community (names of projections and projection parameters, for example)
      then, the values shown in &lt;<a class="ulink" href="https://cf-pcmdi.llnl.gov/trac/wiki/Cf2CrsWkt" target="_top">https://cf-pcmdi.llnl.gov/trac/wiki/Cf2CrsWkt</a>&gt;<sup>[<a name="idp6751360" href="#ftn.idp6751360" class="footnote">1</a>]</sup> should be preferred; these are derived from the OGP/EPSG
      registry of geodetic parameters, which is considered to represent the
      definitive authority as regards CRS property names and
      values.</font></p><p><font style="background-color:#ffccff">Example 5.11 illustrates how the
      coordinate system properties specified via the <code class="varname">crs</code>
      grid mapping variable in Example 5.10 might be expressed using a
      <code class="varname">crs_wkt</code> attribute (it also represents a slightly
      modified version of the WKT example shown in section 7.4 of [[<a href="#OGC_CTS" class="biblioref" title="[OGC_CTS]"><abbr class="abbrev"><font style="background-color:#ffccff">OGC_CTS</font></abbr></a>]]). For brevity only the grid mapping variable is
      included in this example; all other elements are as per the earlier
      example. Names of projection PARAMETERs follow the spellings used in the
      EPSG geodetic parameter registry. Example 5.11 illustrates how certain
      WKT elements - all of which are optional - can be used to specify CRS
      properties not covered by existing CF grid mapping attributes,
      including:</font></p><div class="itemizedlist"><ul type="disc"><li><p><font style="background-color:#ffccff">use of the TOWGS84 element to specify
          horizontal datum transformation parameters (to WGS 1984
          datum)</font></p></li><li><p><font style="background-color:#ffccff">use of the VERT_DATUM element to
          specify vertical datum information</font></p></li><li><p><font style="background-color:#ffccff">use of additional PARAMETER elements
          (albeit not essential ones in this example) to define the location
          of the false origin of the projection</font></p></li><li><p><font style="background-color:#ffccff">use of AUTHORITY elements to specify
          object identifier codes assigned by an external authority, OGP/EPSG
          in this instance</font></p></li></ul></div><div class="example"><a name="idp6761312"></a><p class="title"><b>Example 5.11. <font style="background-color:#ffccff">British National Grid + Newlyn Datum
        in CRS WKT format</font></b></p><div class="example-contents"><pre class="programlisting"> <font style="background-color:#ffccff">...
  int crs ;
    crs:grid_mapping_name = "transverse_mercator" ;
    crs:crs_wkt = "COMPD_CS ["OSGB 1936 / British National Grid + ODN",
      PROJCS ["OSGB 1936 / British National Grid",
        GEOGCS ["OSGB 1936",
          DATUM ["OSGB 1936",
            SPHEROID ["Airy 1830", 6377563.396, 299.3249646],
            TOWGS84[375, -111, 431, 0, 0, 0, 0]
          ],
          PRIMEM ["Greenwich", 0],
          UNIT ["degree", 0.0174532925199433]
        ],
        PROJECTION ["Transverse Mercator"],
        PARAMETER ["False easting", 400000],
        PARAMETER ["False northing", -100000],
        PARAMETER ["Longitude of natural origin", -2.0],
        PARAMETER ["Latitude of natural origin", 49.0],
        PARAMETER ["Longitude of false origin", -7.556],
        PARAMETER ["Latitude of false origin", 49.766],
        PARAMETER ["Scale factor at natural origin", 0.9996012717],
        UNIT ["metre", 1.0],
        AUTHORITY ["EPSG", "27700"]
      ],
      VERT_CS ["Newlyn",
        VERT_DATUM ["Ordnance Datum Newlyn", 2005],
        UNIT ["metre", 1.0]",
        AXIS ["Gravity-related height", UP],
        AUTHORITY ["EPSG", "5701"]
      ]]" ;
  ...</font></pre></div></div><br class="example-break"><p><font style="background-color:#ffccff"><span class="bold"><strong>Note:</strong></span> To
      enhance readability the WKT value has been split across multiple lines
      and embedded quotation marks (") left unescaped - in real netCDF files
      such characters would need to be escaped. The WKT specification in
      [OGC_CTS] appears to silent be as regards which character(s) may be used
      to delimit text-valued properties; however, since all the examples in
      that specification use quotation marks, the use of that particular
      delimiting character is mandated by the CF convention.</font></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scalar-coordinate-variables"></a>5.7. Scalar Coordinate Variables</h2></div></div></div><p>When a variable has an associated coordinate which is single-valued,
    that coordinate may be represented as a scalar variable. Since there is no
    associated dimension these scalar coordinate variables should be attached
    to a data variable via the <code class="varname">coordinates</code>
    attribute.</p><p>Under COARDS the method of providing a single valued coordinate was
    to add a dimension of size one to the variable, and supply the
    corresponding coordinate variable. The new scalar coordinate variable is a
    convenience feature which avoids adding size one dimensions to variables.
    Scalar coordinate variables have the same information content and can be
    used in the same contexts as a size one coordinate variable. Note however
    that use of this feature with a latitude, longitude, vertical, or time
    coordinate will inhibit COARDS conforming applications from recognizing
    them.</p><p>Once a name is used for a scalar coordinate variable it can not be
    used for a 1D coordinate variable. For this reason we strongly recommend
    against using a name for a scalar coordinate variable that matches the
    name of any dimension in the file.</p><div class="example"><a name="multiple-forecasts-from-single-analysis"></a><p class="title"><b>Example 5.12. Multiple forecasts from a single analysis</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  lat = 180 ;
  lon = 360 ;
  time = UNLIMITED ;
variables:
  double atime
    atime:standard_name = "forecast_reference_time" ;
    atime:units = "hours since 1999-01-01 00:00" ;
  double time(time);
    time:standard_name = "time" ;
    time:units = "hours since 1999-01-01 00:00" ;
  double lon(lon) ;
    lon:long_name = "station longitude";
    lon:units = "degrees_east";
  double lat(lat) ;
    lat:long_name = "station latitude" ;
    lat:units = "degrees_north" ;
  double p500
    p500:long_name = "pressure" ;
    p500:units = "hPa" ;
    p500:positive = "down" ;
  float height(time,lat,lon);
    height:long_name = "geopotential height" ;
    height:standard_name = "geopotential_height" ;
    height:units = "m" ;
    height:coordinates = "atime p500" ;
data:
  time = 6., 12., 18., 24. ;
  atime = 0. ;
  p500 = 500. ;
      </pre></div></div><br class="example-break"><p>In this example both the analysis time and the single pressure level
    are represented using scalar coordinate variables. The analysis time is
    identified by the standard name "forecast_reference_time" while the valid
    time of the forecast is identified by the standard name "time".</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.idp6751360" href="#idp6751360" class="para">1</a>] </sup>This reference should be treated carefully because it is
          subject to change.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="idp6904240"></a>Chapter 6. 
        Labels and Alternative Coordinates
    </h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#labels">6.1. Labels</a></span></dt><dd><dl><dt><span class="section"><a href="#geographic-regions">6.1.1. Geographic Regions</a></span></dt></dl></dd><dt><span class="section"><a href="#alternative-coordinates">6.2. Alternative Coordinates</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="labels"></a>6.1. Labels</h2></div></div></div><p><font style="background-color:#ffff88; text-decoration:line-through">
      The previous section contained several examples in which measurements from scattered sites were grouped using a single dimension. Coordinates of the site locations can be provided using auxiliary coordinate variables, but it is often desirable to identify measurement sites by name, or some other unique string. Other purposes for string identifiers are also described in <a class="xref" href="#geographic-regions" title="6.1.1. Geographic Regions">Section 6.1.1, &#8220;Geographic Regions&#8221;</a>, and <a class="xref" href="#statistics-applying-portions" title="7.3.3.  Statistics applying to portions of cells">Section 7.3.3, &#8220;
        <font style="background-color:#ffccff">Statistics applying to portions of
        cells</font>
      &#8221;</a>.
    </font></p><p><font style="background-color:#ffff88; text-decoration:line-through">
      The list of string identifiers plays an analogous role to a coordinate variable, hence we have chosen to use the <code class="varname">coordinates</code> attribute to provide the name of the variable that contains the string array. An application processing the variables listed in the <code class="varname">coordinates</code> attribute can recognize a labeled axis by checking whether or not a given variable contains character data. If a character variable has only one dimension (the length of the string), it is regarded as a string-valued scalar coordinate variable, analogous to a numeric scalar coordinate variable (see <a class="xref" href="#coordinate-system" title="Chapter 5. Coordinate Systems">Chapter 5, <i>Coordinate Systems</i></a>.)
    </font></p><p><font style="background-color:#ffccff">
      Character strings can be used to provide a name or label for each
      element of an axis. This is particularly useful for discrete axes
      (section 4.5). For instance, if a data variable contains time series of
      observational data from a number of observing stations, it may be
      convenient to provide the names of the stations as labels for the
      elements of the station dimension (<a class="xref" href="#time-series-data" title="H.2. Time Series Data">Section H.2, &#8220;Time Series Data&#8221;</a>).
      <a class="xref" href="#Example%20H.1.1" title="Example H.1. Point data.">Example H.1, &#8220;Point data.&#8221;</a> illustrates another application for labels.
      </font></p><p><font style="background-color:#ffccff">
      Character strings labelling the elements of an axis are regarded as
      string-valued auxiliary coordinate variables. The <code class="varname">coordinates</code> attribute
      of the data variable names the variable that contains the string
      array. An application processing the variables listed in the <code class="varname">coordinates</code>
      attribute can recognize a string-valued auxiliary coordinate variable
      because it contains an array of character data. The inner dimension (last
      dimension in CDL terms) is the maximum length of each string, and the
      other dimensions are axis dimensions. If a character variable has only
      one dimension (the maximum length of the string), it is regarded as a
      string-valued scalar coordinate variable, analogous to a numeric scalar
      coordinate variable (see <a class="xref" href="#scalar-coordinate-variables" title="5.7. Scalar Coordinate Variables">Section 5.7, &#8220;Scalar Coordinate Variables&#8221;</a>)
    </font></p><div class="example"><a name="idp6912752"></a><p class="title"><b>Example 6.1. <font style="background-color:#ffff88; text-decoration:line-through">Several parcel trajectories</font></b></p><div class="example-contents"><p><font style="background-color:#ffff88; text-decoration:line-through">
Consider a set of ocean floats that follow parcel trajectories and simultaneously measure temperature at fixed times. We wish to identify the floats by name. The temperature data is a function of parcel (i.e., <code class="constant">float</code>) and time. The location of each sample is also a function of parcel and time, so the position information is stored in a multidimensional coordinate variable.
      </font></p><pre class="programlisting"><font style="background-color:#ffff88; text-decoration:line-through">
dimensions:
  parcel = 15 ; // number of trajectories
  times = 20 ;
  max_len_parcel_name = 64 ; // max length of trajectory name
variables:
  float temperature(parcel,times) ;
    temperature:coordinates = "parcel_name lat lon" ;
  float times(times) ;
  char parcel_name(parcel,max_len_parcel_name) ;
  float lon(parcel,times) ;
  float lat(parcel,times) ;
      </font></pre></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="geographic-regions"></a>6.1.1. Geographic Regions</h3></div></div></div><p>
	When data is representative of geographic regions which can be identified by names but which have complex boundaries that cannot practically be specified using longitude and latitude boundary coordinates, a labeled axis should be used to identify the regions. We recommend that the names be chosen from the list of <a class="ulink" href="http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standardized-region-names" target="_top">standardized region names</a> whenever possible. To indicate that the label values are standardized the variable that contains the labels must be given the <code class="varname">standard_name</code> attribute with the value <code class="constant">region</code>.
      </p><div class="example"><a name="idp6919936"></a><p class="title"><b>Example 6.2. Northward heat transport in Atlantic Ocean</b></p><div class="example-contents"><p>
	  Suppose we have data representing northward heat transport across a set of zonal slices in the Atlantic Ocean. Note that the standard names to describe this quantity do not include location information. That is provided by the latitude coordinate and the labeled axis:
	</p><pre class="programlisting">
dimensions:
  times = 20 ;
  lat = 5
  lbl = 1 ;
  strlen = 64 ;
variables:
  float n_heat_transport(time,lat,lbl);
    n_heat_transport:units="W";
    n_heat_transport:coordinates="geo_region";
    n_heat_transport:standard_name="northward_ocean_heat_transport";
  double time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1990-1-1 0:0:0" ;
  float lat(lat) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
  char geo_region(lbl,strlen) ;
    geo_region:standard_name="region"
data:
  geo_region = "atlantic_ocean" ;
  lat = 10., 20., 30., 40., 50. ;
	</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="alternative-coordinates"></a>6.2. Alternative Coordinates</h2></div></div></div><p>
      In some situations a dimension may have alternative sets of coordinates values. Since there can only be one coordinate variable for the dimension (the variable with the same name as the dimension), any alternative sets of values have to be stored in auxiliary coordinate variables. For such alternative coordinate variables, there are no mandatory attributes, but they may have any of the attributes allowed for coordinate variables.
    </p><div class="example"><a name="idp6924592"></a><p class="title"><b>Example 6.3. Model level numbers</b></p><div class="example-contents"><p>
	Levels on a vertical axis may be described by both the physical coordinate and the ordinal model level number.
      </p><pre class="programlisting">
float xwind(sigma,lat);
  xwind:coordinates="model_level";
float sigma(sigma); // physical height coordinate
  sigma:long_name="sigma";
  sigma:positive="down";
int model_level(sigma); // model level number at each height
  model_level:long_name="model level number";
  model_level:positive="up";
      </pre></div></div><br class="example-break"></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="idp6898192"></a>Chapter 7. Data Representative of Cells</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#cell-boundaries">7.1. Cell Boundaries</a></span></dt><dt><span class="section"><a href="#cell-measures">7.2. Cell Measures</a></span></dt><dt><span class="section"><a href="#cell-methods">7.3. Cell Methods</a></span></dt><dd><dl><dt><span class="section"><a href="#statistics-more-than-one-axis">7.3.1. <font style="background-color:#ffccff">Statistics for more than one
      axis</font></a></span></dt><dt><span class="section"><a href="#recording-spacing-original-data">7.3.2. <font style="background-color:#ffccff">Recording the spacing of the original
      data and other information</font></a></span></dt><dt><span class="section"><a href="#statistics-applying-portions">7.3.3. 
        <font style="background-color:#ffccff">Statistics applying to portions of
        cells</font>
      </a></span></dt><dt><span class="section"><a href="#cell-methods-no-coordinates">7.3.4. <font style="background-color:#ffccff">Cell methods when there are no
      coordinates</font></a></span></dt></dl></dd><dt><span class="section"><a href="#climatological-statistics">7.4. Climatological Statistics</a></span></dt></dl></div><p>When gridded data does not represent the point values of a field but
  instead represents some characteristic of the field within cells of finite
  "volume," a complete description of the variable should include metadata
  that describes the domain or extent of each cell, and the characteristic of
  the field that the cell values represent. It is possible for a single data
  value to be the result of an operation whose domain is a disjoint set of
  cells. This is true for many types of climatological averages, for example,
  the mean January temperature for the years 1970-2000. The methods that we
  present below for describing cells only provides an association of a grid
  point with a single cell, not with a collection of cells. However,
  climatological statistics are of such importance that we provide special
  methods for describing their associated computational domains in <a class="xref" href="#climatological-statistics" title="7.4. Climatological Statistics">Section 7.4, &#8220;Climatological Statistics&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cell-boundaries"></a>7.1. Cell Boundaries</h2></div></div></div><p>To represent cells we add the attribute <code class="varname">bounds</code> to
    the appropriate coordinate variable(s). The value of
    <code class="varname">bounds</code> is the name of the variable that contains the
    vertices of the cell boundaries. We refer to this type of variable as a
    "boundary variable." <span class="emphasis"><em> A boundary variable will have one more
    dimension than its associated coordinate or auxiliary coordinate variable.
    </em></span> The additional dimension should be the most rapidly varying
    one, and its size is the maximum number of cell vertices. Since a boundary
    variable is considered to be part of a coordinate variable's metadata, it
    is not necessary to provide it with attributes such as
    <code class="varname">long_name</code> and <code class="varname">units</code>.</p><p>Note that the boundary variable for a set of N contiguous intervals
    is an array of shape (N,2). Although in this case there will be a
    duplication of the boundary coordinates between adjacent intervals, this
    representation has the advantage that it is general enough to handle,
    without modification, non-contiguous intervals, as well as intervals on an
    axis using the unlimited dimension.</p><p>Applications that process cell boundary data often times need to
    determine whether or not adjacent cells share an edge. In order to
    facilitate this type of processing the following restrictions are placed
    on the data in boundary variables.</p><div class="variablelist"><dl><dt><span class="term">Bounds for 1-D coordinate variables</span></dt><dd><p>For a coordinate variable such as
            <code class="varname">lat(lat)</code> with associated boundary variable
            <code class="varname">latbnd(x,2)</code>, the interval endpoints must be
            ordered consistently with the associated coordinate, e.g., for an
            increasing coordinate, <code class="varname">lat(1)</code> &gt;
            <code class="varname">lat(0)</code> implies <code class="varname">latbnd(i,1)</code>
            &gt;= <code class="varname">latbnd(i,0)</code> for all
            <code class="varname">i</code></p><p>If adjacent intervals are contiguous, the shared endpoint
            must be represented indentically in each instance where it occurs
            in the boundary variable. For example, if the intervals that
            contain grid points <code class="varname">lat(i)</code> and
            <code class="varname">lat(i+1)</code> are contiguous, then
            <code class="varname">latbnd(i+1,0)</code> =
            <code class="varname">latbnd(i,1)</code>.</p></dd><dt><span class="term">Bounds for 2-D coordinate variables with 4-sided cells</span></dt><dd><p>In the case where the horizontal grid is described by
            two-dimensional auxiliary coordinate variables in latitude
            <code class="varname">lat(n,m)</code> and longitude
            <code class="varname">lon(n,m)</code>, and the associated cells are
            four-sided, then the boundary variables are given in the form
            <code class="varname">latbnd(n,m,4)</code> and
            <code class="varname">lonbnd(n,m,4)</code>, where the trailing index runs
            over the four vertices of the cells. Let us call the side of cell
            <code class="varname">(j,i)</code> facing cell <code class="varname">(j,i-1)</code>
            the "<code class="varname">i-1</code>" side, the side facing cell
            <code class="varname">(j,i+1)</code> the "<code class="varname">i+1</code>" side, and
            similarly for "<code class="varname">j-1</code>" and
            "<code class="varname">j+1</code>". Then we can refer to the vertex formed
            by sides <code class="varname">i-1</code> and <code class="varname">j-1</code> as
            <code class="varname">(j-1,i-1)</code>. With this notation, the four
            vertices are indexed as follows: <code class="varname">0=(j-1,i-1)</code>,
            <code class="varname">1=(j-1,i+1)</code>, <code class="varname">2=(j+1,i+1)</code>,
            <code class="varname">3=(j+1,i-1)</code>.</p><p>If i-j-upward is a right-handed coordinate system (like
            lon-lat-upward), this ordering means the vertices will be
            traversed anticlockwise on the lon-lat surface seen from above. If
            i-j-upward is left-handed, they will be traversed clockwise on the
            lon-lat surface.</p><p>The bounds can be used to decide whether cells are
            contiguous via the following relationships. In these equations the
            variable <code class="varname">bnd</code> is used generically to represent
            either the latitude or longitude boundary variable.
            </p><pre class="programlisting">
For 0 &lt; j &lt; n and 0 &lt; i &lt; m,
	If cells (j,i) and (j,i+1) are contiguous, then
		bnd(j,i,1)=bnd(j,i+1,0) 
		bnd(j,i,2)=bnd(j,i+1,3)
	If cells (j,i) and (j+1,i) are contiguous, then	
		bnd(j,i,3)=bnd(j+1,i,0) and bnd(j,i,2)=bnd(j+1,i,1)
							</pre></dd><dt><span class="term">Bounds for multi-dimensional coordinate variables with p-sided
          cells</span></dt><dd><p>In all other cases, the bounds should be dimensioned
            <code class="varname">(...,n,p)</code>, where <code class="varname">(...,n)</code> are
            the dimensions of the auxiliary coordinate variables, and
            <code class="varname">p</code> the number of vertices of the cells. The
            vertices must be traversed anticlockwise in the lon-lat plane as
            viewed from above. The starting vertex is not specified.</p></dd></dl></div><div class="example"><a name="idp6985344"></a><p class="title"><b>Example 7.1. Cells on a latitude axis</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  lat = 64;
  nv = 2;    // number of vertices
variables:
  float lat(lat);
    lat:long_name = "latitude";
    lat:units = "degrees_north";
    lat:bounds = "lat_bnds";
  float lat_bnds(lat,nv);
					</pre><p>The boundary variable <code class="varname">lat_bnds</code> associates a
        latitude gridpoint <code class="varname">i</code> with the interval whose
        boundaries are <code class="varname">lat_bnds(i,0)</code> and
        <code class="varname">lat_bnds(i,1)</code>. The gridpoint location,
        <code class="varname">lat(i)</code>, should be contained within this
        interval.</p></div></div><p><br class="example-break"></p><p>For rectangular grids, two-dimensional cells can be expressed as
    Cartesian products of one-dimensional cells of the type in the preceding
    example. However for non-rectangular grids a "rectangular" cell will in
    general require specifying all four vertices for each cell.</p><div class="example"><a name="idp6950896"></a><p class="title"><b>Example 7.2. Cells in a non-rectangular grid</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  imax = 128;
  jmax = 64;
  nv = 4;
variables:
  float lat(jmax,imax);
    lat:long_name = "latitude";
    lat:units = "degrees_north";
    lat:bounds = "lat_bnds";
  float lon(jmax,imax);
    lon:long_name = "longitude";
    lon:units = "degrees_east";
    lon:bounds = "lon_bnds";
  float lat_bnds(jmax,imax,nv);
  float lon_bnds(jmax,imax,nv);
					</pre><p>The boundary variables <code class="varname">lat_bnds</code> and
        <code class="varname">lon_bnds</code> associate a gridpoint
        <code class="varname">(j,i)</code> with the cell determined by the vertices
        <code class="varname">(lat_bnds(j,i,n),lon_bnds(j,i,n))</code>,
        <code class="varname">n=0,..,3</code>. The gridpoint location,
        <code class="varname">(lat(j,i),lon(j,i))</code>, should be contained within
        this region.</p></div></div><p><br class="example-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cell-measures"></a>7.2. Cell Measures</h2></div></div></div><p>For some calculations, information is needed about the size, shape
    or location of the cells that cannot be deduced from the coordinates and
    bounds without special knowledge that a generic application cannot be
    expected to have. For instance, in computing the mean of several cell
    values, it is often appropriate to "weight" the values by area. When
    computing an area-mean each grid cell value is multiplied by the grid-cell
    area before summing, and then the sum is divided by the sum of the
    grid-cell areas. Area weights may also be needed to map data from one grid
    to another in such a way as to preserve the area mean of the field. The
    preservation of area-mean values while regridding may be essential, for
    example, when calculating surface heat fluxes in an atmospheric model with
    a grid that differs from the ocean model grid to which it is
    coupled.</p><p>In many cases the areas can be calculated from the cell bounds, but
    there are exceptions. Consider, for example, a spherical geodesic grid
    composed of contiguous, roughly hexagonal cells. The vertices of the cells
    can be stored in the variable identified by the <code class="varname">bounds </code>
    attribute, but the cell perimeter is not uniquely defined by its vertices
    (because the vertices could, for example, be connected by straight lines,
    or, on a sphere, by lines following a great circle, or, in general, in
    some other way). Thus, given the cell vertices alone, it is generally
    impossible to calculate the area of a grid cell. This is why it may be
    necessary to store the grid-cell areas in addition to the cell
    vertices.</p><p>In other cases, the grid cell-volume might be needed and might not
    be easily calculated from the coordinate information. In ocean models, for
    example, it is not uncommon to find "partial" grid cells at the bottom of
    the ocean. In this case, rather than (or in addition to) indicating grid
    cell area, it may be necessary to indicate volume.</p><p>To indicate extra information about the spatial properties of a
    variable's grid cells, a <code class="varname">cell_measures</code> attribute may be
    defined for a variable. This is a string attribute comprising a list of
    blank-separated pairs of words of the form "<code class="varname">measure:
    name</code>". For the moment, "<code class="varname">area</code>" and
    "<code class="varname">volume</code>" are the only defined measures, but others may
    be supported in future. The "name" is the name of the variable containing
    the measure values, which we refer to as a "measure variable". The
    dimensions of the measure variable should be the same as or a subset of
    the dimensions of the variable to which they are related, but their order
    is not restricted. In the case of area, for example, the field itself
    might be a function of longitude, latitude, and time, but the variable
    containing the area values would only include longitude and latitude
    dimensions (and the dimension order could be reversed, although this is
    not recommended). The variable must have a <code class="varname">units</code>
    attribute and may have other attributes such as a
    <code class="varname">standard_name</code>.</p><p>For rectangular longitude-latitude grids, the area of grid cells can
    be calculated from the bounds: the area of a cell is proportional to the
    product of the difference in the longitude bounds of the cell and the
    difference between the sine of each latitude bound of the cell. In this
    case supplying grid-cell areas via the <code class="varname">cell_measures</code>
    attribute is unnecessary because it may be assumed that applications can
    perform this calculation, using their own value for the radius of the
    Earth.</p><div class="example"><a name="idp7013360"></a><p class="title"><b>Example 7.3. Cell areas for a spherical geodesic grid</b></p><div class="example-contents"><pre class="programlisting">
dimensions:
  cell = 2562 ;  // number of grid cells
  time = 12 ;
  nv = 6 ;       // maximum number of cell vertices 
variables:
  float PS(time,cell) ;
    PS:units = "Pa" ;
    PS:coordinates = "lon lat" ;
    PS:cell_measures = "area: cell_area" ;
  float lon(cell) ;
    lon:long_name = "longitude" ;
    lon:units = "degrees_east" ;
    lon:bounds="lon_vertices" ;
  float lat(cell) ;
    lat:long_name = "latitude" ;
    lat:units = "degrees_north" ;
    lat:bounds="lat_vertices" ;
  float time(time) ;
    time:long_name = "time" ;
    time:units = "days since 1979-01-01 0:0:0" ;
  float cell_area(cell) ;
    cell_area:long_name = "area of grid cell" ;
    cell_area:standard_name="area";
    cell_area:units = "m2"
  float lon_vertices(cell,nv) ;
  float lat_vertices(cell,nv) ;
					</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cell-methods"></a>7.3. Cell Methods</h2></div></div></div><p>To describe the characteristic of a field that is represented by
    cell values, we define the <code class="varname">cell_methods</code> attribute of
    the variable. This is a string attribute comprising a list of
    blank-separated words of the form "<span class="emphasis"><em>name: method</em></span>".
    Each "<span class="emphasis"><em>name: method</em></span>" pair indicates that for an axis
    identified by <span class="emphasis"><em>name</em></span>, the cell values representing the
    field have been determined or derived by the specified
    <span class="emphasis"><em>method</em></span>. For example, if data values have been
    generated by computing time means, then this could be indicated with
    <code class="varname">cell_methods="t: mean"</code>, assuming here that the name of
    the time dimension variable is "t". <font style="background-color:#ffff88; text-decoration:line-through">The token
    name can be a dimension of the variable, a scalar coordinate variable, or
    a valid standard name.</font></p><p><font style="background-color:#ffccff">In the specification of this attribute,
    <span class="emphasis"><em>name</em></span> can be a dimension of the variable, a scalar
    coordinate variable, a valid standard name, or the word
    "<code class="varname">area</code>". (See <a class="xref" href="#cell-methods-no-coordinates" title="7.3.4. Cell methods when there are no coordinates">Section 7.3.4, &#8220;<font style="background-color:#ffccff">Cell methods when there are no
      coordinates</font>&#8221;</a> concerning the use of standard
    names in cell_methods.)</font> The values of
    <span class="emphasis"><em>method</em></span> should be selected from the list in <a class="xref" href="#appendix-cell-methods" title="Appendix E. Cell Methods">Appendix E, <i>Cell Methods</i></a>, which includes
    <code class="constant">point</code>, <code class="constant">sum</code>,
    <code class="constant">mean</code>, <code class="constant">maximum</code>,
    <code class="constant">minimum</code>, <code class="constant">mid_range</code>,
    <code class="constant">standard_deviation</code>, <code class="constant">variance</code>,
    <code class="constant">mode</code>, and <code class="constant">median</code>. Case is not
    significant in the method name. Some methods (e.g.,
    <code class="constant">variance</code>) imply a change of units of the variable, as
    is indicated in <a class="xref" href="#appendix-cell-methods" title="Appendix E. Cell Methods">Appendix E, <i>Cell Methods</i></a>.</p><p>It must be remembered that the method applies only to the axis
    designated in <code class="varname">cell_methods</code> by
    <span class="emphasis"><em>name</em></span>, and different methods may apply to other axes.
    If, for instance, a precipitation value in a longitude-latitude cell is
    given the method <code class="varname">maximum</code> for these axes, it means that
    it is the maximum within these spatial cells, and does not imply that it
    is also the maximum in time. Furthermore, it should be noted that if any
    <span class="emphasis"><em>method</em></span> other than "<code class="varname">point</code>" is
    specified for a given axis, then <font style="background-color:#ffff88; text-decoration:line-through"><code class="varname">cell_bounds</code></font> <font style="background-color:#ffccff"><code class="varname">bounds</code></font> should also be
    provided for that axis (except for the relatively rare exceptions
    described in <a class="xref" href="#cell-methods-no-coordinates" title="7.3.4. Cell methods when there are no coordinates">Section 7.3.4, &#8220;<font style="background-color:#ffccff">Cell methods when there are no
      coordinates</font>&#8221;</a>).</p><p>The default interpretation for variables that do not have the
    <code class="varname">cell_methods</code> attribute specified depends on whether the
    quantity is extensive (which depends on the size of the cell) or intensive
    (which does not). Suppose, for example, the quantities "accumulated
    precipitation" and "precipitation rate" each have a time axis. A variable
    representing accumulated precipitation is extensive in time because it
    depends on the length of the time interval over which it is accumulated.
    For correct interpretation, it therefore requires a time interval to be
    completely specified via a boundary variable (i.e., via a <font style="background-color:#ffff88; text-decoration:line-through"><code class="varname">cell_bounds</code></font> <font style="background-color:#ffccff"><code class="varname">bounds</code></font> attribute for the time
    axis). In this case the default interpretation is that the cell method is
    a sum over the specified time interval. This can be (optionally) indicated
    explicitly by setting the cell method to <code class="varname">sum</code>. A
    precipitation rate on the other hand is intensive in time and could
    equally well represent either an instantaneous value or a mean value over
    the time interval specified by the cell. In this case the default
    interpretation for the quantity would be "instantaneous" (which,
    optionally, can be indicated explicitly by setting the cell method to
    <code class="varname">point</code>). More often, however, cell values for intensive
    quantities are means, and this should be indicated explicitly by setting
    the cell method to <code class="varname">mean</code> and specifying the cell
    bounds.</p><p><font style="background-color:#ffccff">Because the default interpretation for an
    intensive quantity differs from that of an extensive quantity and because
    this distinction may not be understood by some users of the data, it is
    recommended that every data variable include for each of its dimensions
    and each of its scalar coordinate variables the
    <code class="varname">cell_methods</code> information of interest (unless this
    information would not be meaningful). It is especially recommended that
    <code class="varname">cell_methods</code> be explicitly specified for each
    spatio-temporal dimension and each spatio-temporal scalar coordinate
    variable.</font></p><div class="example"><a name="idp7040736"></a><p class="title"><b>Example 7.4. Methods applied to a timeseries</b></p><div class="example-contents"><p>Consider 12-hourly timeseries of pressure, temperature and
        precipitation from a number of stations, where pressure is measured
        instantaneously, maximum temperature for the preceding 12 hours is
        recorded, and precipitation is accumulated in a rain gauge. For a
        period of 48 hours from 6 a.m. on 19 April 1998, the data is
        structured as follows:</p><pre class="programlisting">
dimensions:
  time = UNLIMITED; // (5 currently)
  station = 10;
  nv = 2;
variables:
  float pressure<font style="background-color:#ffff88; text-decoration:line-through">(station,time)</font><font style="background-color:#ffccff">(time,station)</font>;
    pressure:long_name = "pressure";
    pressure:units = "kPa";
    pressure:cell_methods = "time: point";
  float maxtemp<font style="background-color:#ffff88; text-decoration:line-through">(station,time)</font><font style="background-color:#ffccff">(time,station)</font>;
    maxtemp:long_name = "temperature";
    maxtemp:units = "K";
    maxtemp:cell_methods = "time: maximum";
  float ppn<font style="background-color:#ffff88; text-decoration:line-through">(station,time)</font><font style="background-color:#ffccff">(time,station)</font>;
    ppn:long_name = "depth of water-equivalent precipitation";
    ppn:units = "mm";
    ppn:cell_methods = "time: sum";
  double time(time);
    time:long_name = "time";
    time:units = "h since 1998-4-19 6:0:0";
    time:bounds = "time_bnds";
  double time_bnds(time,nv);
data:
  time = 0., 12., 24., 36., 48.;
  time_bnds = -12.,0., 0.,12., 12.,24., 24.,36., 36.,48.; 
					</pre><p>Note that in this example the time axis values coincide with the
        end of each interval. It is sometimes desirable, however, to use the
        midpoint of intervals as coordinate values for variables that are
        representative of an interval. An application may simply obtain the
        midpoint values by making use of the boundary data in
        <code class="constant">time_bnds</code>.</p></div></div><p><br class="example-break"></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="statistics-more-than-one-axis"></a>7.3.1. <font style="background-color:#ffccff">Statistics for more than one
      axis</font></h3></div></div></div><p>If more than one cell method is to be indicated, they should be
      arranged in the order they were applied. The left-most operation is
      assumed to have been applied first. Suppose, for example, that within
      each grid cell a quantity varies in both longitude and time and that
      these dimensions are named "lon" and "time", respectively. Then values
      representing the time-average of the zonal maximum are labeled
      <code class="varname">cell_methods="lon: maximum time: mean"</code> (i.e. find the
      largest value at each instant of time over all longitudes, then average
      these maxima over time); values of the zonal maximum of time-averages
      are labeled <code class="varname">cell_methods="time: mean lon: maximum"</code>.
      If the methods could have been applied in any order without affecting
      the outcome, they may be put in any order in the
      <code class="varname">cell_methods</code> attribute.</p><p>If a data value is representative of variation over a combination
      of axes, a single method should be prefixed by the names of all the
      dimensions involved (listed in any order, since in this case the order
      must be immaterial). Dimensions should be grouped in this way only if
      there is an essential difference from treating the dimensions
      individually. For instance, the standard deviation of topographic height
      within a longitude-latitude gridbox <font style="background-color:#ffccff">could</font> <font style="background-color:#ffff88; text-decoration:line-through">would</font> have <code class="varname">cell_methods="lat:
      lon: standard_deviation"</code>. (Note also, that in accordance with
      the recommendation of the following paragraph, this could be
      equivalently and preferably indicated by <code class="varname">cell_methods="area:
      standard_deviation"</code>.) This is not the same as
      <code class="varname">cell_methods="lon: standard_deviation lat:
      standard_deviation"</code>, which would mean finding the standard
      deviation along each parallel of latitude within the zonal extent of the
      gridbox, and then the standard deviation of these values over
      latitude.</p><p><font style="background-color:#ffccff">To indicate variation over horizontal
      area, it is recommended that instead of specifying the combination of
      horizontal dimensions, the special string "<code class="varname">area</code>" be
      used. The common case of an area-mean can thus be indicated by
      <code class="varname">cell_methods="area: mean"</code> (rather than, for example,
      "<code class="varname">lon: lat: mean</code>"). The horizontal coordinate
      variables to which "<code class="varname">area</code>" refers are in this case not
      explicitly indicated in <code class="varname">cell_methods</code> but can be
      identified, if necessary, from attributes attached to the coordinate
      variables, scalar coordinate variables, or auxiliary coordinate
      variables, as described in <a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a>.</font></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="recording-spacing-original-data"></a>7.3.2. <font style="background-color:#ffccff">Recording the spacing of the original
      data and other information</font></h3></div></div></div><p>To indicate more precisely how the cell method was applied, extra
      information may be included in parentheses () after the identification
      of the method. This information includes standardized and
      non-standardized parts. Currently the only standardized information is
      to provide the typical interval between the original data values to
      which the method was applied, in the situation where the present data
      values are statistically representative of original data values which
      had a finer spacing. The syntax is (<code class="varname">interval</code>:
      <span class="emphasis"><em>value unit</em></span>), where <span class="emphasis"><em>value</em></span> is a
      numerical value and <span class="emphasis"><em>unit</em></span> is a string that can be
      recognized by UNIDATA's Udunits package [<a href="#udunits" class="biblioref" title="[UDUNITS]"><abbr class="abbrev">UDUNITS</abbr></a>].
      The <span class="emphasis"><em>unit</em></span> will usually be dimensionally equivalent
      to the unit of the corresponding dimension, but this is not required
      (which allows, for example, the interval for a standard deviation
      calculated from points evenly spaced in distance along a parallel to be
      reported in units of length even if the zonal coordinate of the cells is
      given in degrees). Recording the original interval is particularly
      important for standard deviations. For example, the standard deviation
      of daily values could be indicated by <code class="varname">cell_methods="time:
      standard_deviation (interval: 1 day)"</code> and of annual values by
      <code class="varname">cell_methods="time: standard_deviation (interval: 1
      year)"</code>.</p><p>If the cell method applies to a combination of axes, they may have
      a common original interval e.g. <code class="varname">cell_methods="lat: lon:
      standard_deviation (interval: 10 km)"</code>. Alternatively, they may
      have separate intervals, which are matched to the names of axes by
      position e.g. <code class="varname">cell_methods="lat: lon: standard_deviation
      (interval: 0.1 degree_N interval: 0.2 degree_E)"</code>, in which 0.1
      degree applies to latitude and 0.2 degree to longitude.</p><p>If there is both standardized and non-standardized information,
      the non-standardized follows the standardized information and the
      keyword <code class="varname">comment:</code>. If there is no standardized
      information, the keyword <code class="varname">comment:</code> should be omitted.
      For instance, an area-weighted mean over latitude could be indicated as
      <code class="varname">lat: mean (area-weighted)</code> or <code class="varname">lat: mean
      (interval: 1 degree_north comment: area-weighted)</code>.</p><p>A dimension of size one may be the result of "collapsing" an axis
      by some statistical operation, for instance by calculating a variance
      from time series data. We strongly recommend that dimensions of size one
      be retained (or scalar coordinate variables be defined) to enable
      documentation of the method (through the <code class="varname">cell_methods</code>
      attribute) and its domain (through the <font style="background-color:#ffff88; text-decoration:line-through"><code class="varname">cell_bounds</code></font> <font style="background-color:#ffccff"><code class="varname">bounds</code></font> attribute).</p><div class="example"><a name="idp7072752"></a><p class="title"><b>Example 7.5. Surface air temperature variance</b></p><div class="example-contents"><p>The variance of the diurnal cycle on 1 January 1990 has been
          calculated from hourly instantaneous surface air temperature
          measurements. The time dimension of size one has been
          retained.</p><pre class="programlisting">
dimensions:
  lat=90;
  lon=180;
  time=1;
  nv=2;
variables:
  float TS_var(time,lat,lon);
    TS_var:long_name="surface air temperature variance"
    TS_var:units="K2";
    TS_var:cell_methods="time: variance (interval: 1 hr comment: sampled instantaneously)";
  float time(time);
    time:units="days since 1990-01-01 00:00:00";
    time:bounds="time_bnds";
  float time_bnds(time,nv);
data:
  time=.5;
  time_bnds=0.,1.;
	    </pre><p>Notice that a parenthesized comment in the
          <code class="varname">cell_methods</code> attribute provides the nature of the
          samples used to calculate the variance.</p></div></div><p><br class="example-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="statistics-applying-portions"></a>7.3.3. 
        <font style="background-color:#ffccff">Statistics applying to portions of
        cells</font>
      </h3></div></div></div><font style="background-color:#ffccff">
        <p>By default, the statistical method indicated by
        <code class="varname">cell_methods</code> is assumed to have been evaluated over
        the entire horizontal area of the cell. Sometimes, however, it is
        useful to limit consideration to only a portion of a cell (e.g. a mean
        over the sea-ice area). To indicate this, one of two conventions may
        be used.</p>

        <p>The first convention is a method that can be used for the common
        case of a single area-type. In this case, the
        <code class="varname">cell_methods</code> attribute may include a string of the
        form "<span class="emphasis"><em>name: method</em></span> <code class="varname">where</code>
        <span class="emphasis"><em>type</em></span>". Here <span class="emphasis"><em>name</em></span> could, for
        example, be <code class="varname">area</code> and <span class="emphasis"><em>type</em></span> may
        be any of the strings permitted for a variable with a
        <code class="varname">standard_name</code> of <code class="varname">area_type</code>. As
        an example, if the method were <code class="varname">mean</code> and the
        <code class="varname">area_type</code> were <code class="varname">sea_ice</code>, then the
        data would represent a mean over only the sea ice portion of the grid
        cell. If the data writer expects <span class="emphasis"><em>type</em></span> to be
        interpreted as one of the standard <code class="varname">area_type</code>
        strings, then none of the variables in the netCDF file should be given
        a name identical to that of the string (because the second convention,
        described in the next paragraph, takes precedence).</p>

        <p>The second convention is the more general. In this case, the
        <code class="varname">cell_methods</code> entry is of the form "<span class="emphasis"><em>name:
        method</em></span> <code class="varname">where</code>
        <span class="emphasis"><em>typevar</em></span>". Here <span class="emphasis"><em>typevar</em></span> is a
        string-valued auxiliary coordinate variable or string-valued scalar
        coordinate variable (see <a class="xref" href="#labels" title="6.1. Labels">Section 6.1, &#8220;Labels&#8221;</a>) with a
        <code class="varname">standard_name</code> of <code class="varname">area_type</code>. The
        variable <span class="emphasis"><em>typevar</em></span> contains the name(s) of the
        selected portion(s) of the grid cell to which the
        <span class="emphasis"><em>method</em></span> is applied. This convention can
        accommodate cases in which a method is applied to more than one area
        type and the result is stored in a single data variable (with a
        dimension which ranges across the various area types). It provides a
        convenient way to store output from land surface models, for example,
        since they deal with many area types within each surface gridbox
        (e.g., <code class="varname">vegetation</code>, <code class="varname">bare_ground</code>,
        <code class="varname">snow</code>, etc.).</p>

        <div class="example"><a name="mean-surface-temperature-sensible-heat-flux"></a><p class="title"><b>Example 7.6. Mean surface temperature over land and sensible heat flux
          averaged separately over land and sea.</b></p><div class="example-contents"><p>
            </p><pre class="programlisting">
dimensions:
  lat=73;
  lon=96;
  maxlen=20;
  ls=2;
variables:
  float surface_temperature(lat,lon);
    surface_temperature:cell_methods="area: mean where land";
  float surface_upward_sensible_heat_flux(ls,lat,lon);
    surface_upward_sensible_heat_flux:coordinates="land_sea";
    surface_upward_sensible_heat_flux:cell_methods="area: mean where land_sea";
  char land_sea(ls,maxlen);
    land_sea:standard_name="area_type";
data:
  land_sea="land","sea";
           </pre><p>
          </p><p>If the <span class="emphasis"><em>method</em></span> is <code class="varname">mean</code>,
          various ways of calculating the mean can be distinguished in the
          <code class="varname">cell_methods</code> attribute with a string of the form
          "<code class="varname">mean where</code> <span class="emphasis"><em>type1</em></span>
          [<code class="varname">over</code> <span class="emphasis"><em>type2</em></span>]". Here,
          <span class="emphasis"><em>type1</em></span> can be any of the possibilities allowed
          for <span class="emphasis"><em>typevar</em></span> or <span class="emphasis"><em>type</em></span> (as
          specified in the two paragraphs preceding above Example). The same
          options apply to <span class="emphasis"><em>type2</em></span>, except it is not
          allowed to be the name of an auxiliary coordinate variable with a
          dimension greater than one (ignoring the dimension accommodating the
          maximum string length). A <code class="varname">cell_methods</code> attribute
          with a string of the form "<code class="varname">mean where</code>
          <span class="emphasis"><em>type1</em></span> <code class="varname">over</code>
          <span class="emphasis"><em>type2</em></span>" indicates the mean is calculated by
          summing over the <span class="emphasis"><em>type1</em></span> portion of the cell and
          dividing by the area of the <span class="emphasis"><em>type2</em></span> portion. In
          particular, a <code class="varname">cell_methods</code> string of the form
          "<code class="varname">mean where all_area_types over</code>
          <span class="emphasis"><em>type2</em></span>" indicates the mean is calculated by
          summing over all types of area within the cell and dividing by the
          area of the <span class="emphasis"><em>type2</em></span> portion. (Note that
          "<code class="varname">all_area_types</code>" is one of the valid strings
          permitted for a variable with the <code class="varname">standard_name
          area_type</code>.) If "<code class="varname">over</code>
          <span class="emphasis"><em>type2</em></span>" is omitted, the mean is calculated by
          summing over the <span class="emphasis"><em>type1</em></span> portion of the cell and
          dividing by the area of this portion.</p></div></div><br class="example-break">

        <div class="example"><a name="idp7106544"></a><p class="title"><b>Example 7.7. Thickness of sea-ice and snow on sea-ice averaged over sea
          area.</b></p><div class="example-contents"><p>
            </p><pre class="programlisting">
variables:
  float sea_ice_thickness(lat,lon);
    sea_ice_thickness:cell_methods="area: mean where sea_ice over sea";
    sea_ice_thickness:standard_name="sea_ice_thickness";
    sea_ice_thickness:units="m";
  float snow_thickness(lat,lon);
    snow_thickness:cell_methods="area: mean where sea_ice over sea";
   snow_thickness:standard_name="lwe_thickness_of_surface_snow_amount";
    snow_thickness:units="m";
           </pre><p>
          </p><p>In the case of sea-ice thickness, the phrase "<code class="varname">where
          sea_ice</code>" could be replaced by "<code class="varname">where
          all_area_types</code>" without changing the meaning since the
          integral of sea-ice thickness over all area types is obviously the
          same as the integral over the sea-ice area only. In the case of snow
          thickness, "<code class="varname">where sea_ice</code>" differs from
          "<code class="varname">where all_area_types</code>" because "<code class="varname">where
          sea_ice</code>" excludes snow on land from the average.</p></div></div><br class="example-break">
      </font></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cell-methods-no-coordinates"></a>7.3.4. <font style="background-color:#ffccff">Cell methods when there are no
      coordinates</font></h3></div></div></div><p>To provide an indication that a particular cell method is relevant
      to the data without having to provide a precise description of the
      corresponding cell, the "<span class="emphasis"><em>name</em></span>" that appears in a
      "<span class="emphasis"><em>name</em></span>: <span class="emphasis"><em>method</em></span>" pair may be an
      appropriate <code class="varname">standard_name</code> (which identifies the
      dimension) <font style="background-color:#ffccff">or the string,
      "<span class="emphasis"><em>area</em></span>"</font> (rather than the name of a scalar
      coordinate variable or a dimension with a coordinate variable). This
      convention cannot be used, however, if the name of a dimension or scalar
      coordinate variable is identical to <span class="emphasis"><em>name</em></span>. There are
      two situations where this convention is useful.</p><p>First, it allows one to provide some indication of the method when
      the cell coordinate range cannot be precisely defined. For example, a
      climatological mean might be based on any data that exists, and, in
      general, the data might not be available over the same time periods
      everywhere. In this case, the time range would not be well defined
      (because it would vary, depending on location), and it could not be
      precisely specified through a time dimension's bounds. Nevertheless,
      useful information can be conveyed by a <code class="varname">cell_methods</code>
      entry of "<code class="varname">time: mean</code>" (where <code class="varname">time</code>,
      it should be noted, is a valid <code class="varname">standard_name</code>). (As
      required by this convention, it is assumed here that for the data
      referred to by this <code class="varname">cell_methods</code> attribute, "time" is
      not a dimension or coordinate variable.)</p><p>Second, for a few special dimensions, this convention allows one
      to indicate (without explicitly defining the coordinates) that the
      method applies to the domain covering the entire permitted range of
      those dimensions. This is allowed only for longitude, latitude,
      <font style="background-color:#ffccff">and area (indicating a combination of
      horizontal coordinates)</font>. For longitude, the domain is
      indicated according to this provision by the string "longitude" (rather
      than the name of a longitude coordinate variable), and this implies that
      the method applies to all possible longitudes (i.e., from 0E to 360E).
      For latitude, the string "latitude" is used and implies the method
      applies to all possible latitudes (i.e., from 90S to 90N). <font style="background-color:#ffccff">For area, the string "area" is used and implies the
      method applies to the whole world.</font></p><p>In the second case if, in addition, the data variable has a
      dimension with a corresponding labeled axis that specifies a geographic
      region (<a class="xref" href="#geographic-regions" title="6.1.1. Geographic Regions">Section 6.1.1, &#8220;Geographic Regions&#8221;</a>), the implied range of
      longitude and latitude is the valid range for each specified region,
      <font style="background-color:#ffccff">or in the case of <code class="varname">area</code> the
      domain is the geographic region</font>. For example, there could be
      a <code class="varname">cell_methods</code> entry of "<code class="varname">longitude:
      mean</code>", where <code class="varname">longitude</code> is
      <span class="emphasis"><em>not</em></span> the name of a dimension or coordinate variable
      (but is one of the special cases given above). That would indicate a
      mean over all longitudes. Note, however, that if in addition the data
      variable had a scalar coordinate variable with a
      <code class="varname">standard_name</code> of <code class="varname">region</code> and a
      value of <code class="varname">atlantic_ocean</code>, it would indicate a mean
      over longitudes that lie within the Atlantic Ocean, not all
      longitudes.</p><p>We recommend that whenever possible, cell bounds should be
      supplied by giving the variable a dimension of size one and attaching
      bounds to the associated coordinate variable.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="climatological-statistics"></a>7.4. Climatological Statistics</h2></div></div></div><p>Climatological statistics may be derived from corresponding portions
    of the annual cycle in a set of years, e.g., the average January
    temperatures in the climatology of 1961-1990, where the values are derived
    by averaging the 30 Januarys from the separate years. Portions of the
    climatological cycle are specified by references to dates within the
    calendar year. However, a calendar year is not a well-defined unit of
    time, because it differs between leap years and other years, and among
    calendars. Nonetheless for practical purposes we wish to compare
    statistics for months or seasons from different calendars, and to make
    climatologies from a mixture of leap years and other years. Hence we
    provide special conventions for indicating dates within the climatological
    year. Climatological statistics may also be derived from corresponding
    portions of a range of days, for instance the average temperature for each
    hour of the average day in April 1997. In addition the two concepts may be
    used at once, for instance to indicate not April 1997, but the average
    April of the five years 1995-1999.</p><p>Climatological variables have a climatological time axis. Like an
    ordinary time axis, a climatological time axis may have a dimension of
    unity (for example, a variable containing the January average temperatures
    for 1961-1990), but often it will have several elements (for example, a
    climatological time axis with a dimension of 12 for the climatological
    average temperatures in each month for 1961-1990, a dimension of 3 for the
    January mean temperatures for the three decades 1961-1970, 1971-1980,
    1981-1990, or a dimension of 24 for the hours of an average day).
    Intervals of climatological time are conceptually different from ordinary
    time intervals; a given interval of climatological time represents a set
    of subintervals which are not necessarily contiguous. To indicate this
    difference, a climatological time coordinate variable does not have a
    <code class="varname">bounds</code> attribute. Instead, it has a
    <code class="varname">climatology</code> attribute, which names a variable with
    dimensions (n,2), n being the dimension of the climatological time axis.
    Using the units and calendar of the time coordinate variable, element
    (i,0) of the climatology variable specifies the beginning of the first
    subinterval and element (i,1) the end of the last subinterval used to
    evaluate the climatological statistics with index i in the time dimension.
    The time coordinates should be values that are representative of the
    climatological time intervals, such that an application which does not
    recognise climatological time will nonetheless be able to make a
    reasonable interpretation.</p><p>The COARDS standard offers limited support for climatological time.
    For compatibility with COARDS, time coordinates should also be recognised
    as climatological if they have a <code class="varname">units</code> attribute of
    time-units relative to midnight on 1 January in year 0 i.e. <code class="varname">since
    0-1-1</code> in udunits syntax , and provided they refer to the
    real-world calendar. We do not recommend this convention because (a) it
    does not provide any information about the intervals used to compute the
    climatology, and (b) there is no standard for how dates since year 1 will
    be encoded with units having a reference time in year 0, since this year
    does not exist; consequently there may be inconsistencies among software
    packages in the interpretation of the time coordinates. Year 0 may be a
    valid year in non-real-world calendars, and therefore cannot be used to
    signal climatological time in such cases.</p><p>A climatological axis may use different statistical methods to
    represent variation among years, within years and within days. For
    example, the average January temperature in a climatology is obtained by
    averaging both within years and over years. This is different from the
    average January-maximum temperature and the maximum January-average
    temperature. For the former, we first calculate the maximum temperature in
    each January, then average these maxima; for the latter, we first
    calculate the average temperature in each January, then find the largest
    one. As usual, the statistical operations are recorded in the
    <code class="varname">cell_methods</code> attribute, which may have two or three
    entries for the climatological time dimension.</p><p>Valid values of the <code class="varname">cell_methods</code> attribute must
    be in one of the forms from the following list. The intervals over which
    various statistical methods are applied are determined by decomposing the
    date and time specifications of the climatological time bounds of a cell,
    as recorded in the variable named by the <code class="varname">climatology</code>
    attribute. (The date and time specifications must be calculated from the
    time coordinates expressed in units of "time interval since reference date
    and time".) In the descriptions that follow we use the abbreviations
    <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>m</em></span>, <span class="emphasis"><em>d</em></span>,
    <span class="emphasis"><em>H</em></span>, <span class="emphasis"><em>M</em></span>, and <span class="emphasis"><em>S</em></span>
    for year, month, day, hour, minute, and second respectively. The suffix
    <span class="emphasis"><em>0</em></span> indicates the earlier bound and
    <span class="emphasis"><em>1</em></span> the latter. </p><div class="variablelist"><dl><dt><span class="term">time: method1 <code class="varname">within years</code>   time: method2
          <code class="varname">over years</code></span></dt><dd><p><span class="emphasis"><em>method1</em></span> is applied to the time
            intervals (mdHMS0-mdHMS1) within individual years and
            <span class="emphasis"><em>method2</em></span> is applied over the range of years
            (y0-y1).</p></dd><dt><span class="term">time: method1 <code class="varname">within days</code>   time: method2
          <code class="varname">over days</code></span></dt><dd><p><span class="emphasis"><em>method1</em></span> is applied to the time
            intervals (HMS0-HMS1) within individual days and
            <span class="emphasis"><em>method2</em></span> is applied over the days in the
            interval (ymd0-ymd1).</p></dd><dt><span class="term">time: method1 <code class="varname">within days</code>   time: method2
          <code class="varname">over days</code>   time: method3 <code class="varname">over
          years</code></span></dt><dd><p><span class="emphasis"><em>method1</em></span> is applied to the time
            intervals (HMS0-HMS1) within individual days and
            <span class="emphasis"><em>method2</em></span> is applied over the days in the
            interval (md0-md1), and <span class="emphasis"><em>method3</em></span> is applied
            over the range of years (y0-y1).</p></dd></dl></div><p>The methods which can be specified are those listed in <a class="xref" href="#appendix-cell-methods" title="Appendix E. Cell Methods">Appendix E, <i>Cell Methods</i></a> and each entry in the
    <code class="varname">cell_methods</code> attribute may also, as usual, contain
    non-standardised information in parentheses after the method. For
    instance, a mean over ENSO years might be indicated by
    "<code class="computeroutput">time: mean over years (ENSO
    years)</code>".</p><p>When considering intervals within years, if the earlier
    climatological time bound is later in the year than the later
    climatological time bound, it implies that the time intervals for the
    individual years run from each year across January 1 into the next year
    e.g. DJF intervals run from December 1 0:00 to March 1 0:00. Analogous
    situations arise for daily intervals running across midnight from one day
    to the next.</p><p>When considering intervals within days, if the earlier time of day
    is equal to the later time of day, then the method is applied to a full 24
    hour day.</p><p><span class="emphasis"><em> We have tried to make the examples in this section easier
    to understand by translating all time coordinate values to date and time
    formats. This is not currently valid CDL syntax. </em></span></p><div class="example"><a name="idp7157216"></a><p class="title"><b>Example 7.8. Climatological seasons</b></p><div class="example-contents"><p>This example shows the metadata for the average seasonal-minimum
        temperature for the four standard climatological seasons MAM JJA SON
        DJF, made from data for March 1960 to February 1991.</p><pre class="programlisting">
dimensions:
  time=4;
  nv=2;
variables:
  float temperature(time,lat,lon);
    temperature:long_name="surface air temperature";
    temperature:cell_methods="time: minimum within years time: mean over years";
    temperature:units="K";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 1960-1-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1960-4-16", "1960-7-16", "1960-10-16", "1961-1-16" ;
  climatology_bounds="1960-3-1",  "1990-6-1",
                     "1960-6-1",  "1990-9-1",
                     "1960-9-1",  "1990-12-1",
                     "1960-12-1", "1991-3-1" ;
					</pre></div></div><p><br class="example-break"></p><div class="example"><a name="idp7160176"></a><p class="title"><b>Example 7.9. Decadal averages for January</b></p><div class="example-contents"><p>Average January precipitation totals are given for each of the
        decades 1961-1970, 1971-1980, 1981-1990.</p><pre class="programlisting">
dimensions:
  time=3;
  nv=2;
variables:
  float precipitation(time,lat,lon);
    precipitation:long_name="precipitation amount";
    precipitation:cell_methods="time: sum within years time: mean over years";
    precipitation:units="kg m-2";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 1901-1-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1965-1-15", "1975-1-15", "1985-1-15" ;
  climatology_bounds="1961-1-1", "1970-2-1",
                     "1971-1-1", "1980-2-1",
                     "1981-1-1", "1990-2-1" ;

					</pre></div></div><p><br class="example-break"></p><div class="example"><a name="idp7162976"></a><p class="title"><b>Example 7.10. Temperature for each hour of the average day</b></p><div class="example-contents"><p>Hourly average temperatures are given for April 1997.</p><pre class="programlisting">
dimensions:
  time=24;
  nv=2;
variables:
  float temperature(time,lat,lon);
    temperature:long_name="surface air temperature";
    temperature:cell_methods="time: mean within days time: mean over days";
    temperature:units="K";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="hours since 1997-4-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1997-4-1 0:30", "1997-4-1 1:30", ... "1997-4-1 23:30" ;
  climatology_bounds="1997-4-1 0:00",  "1997-4-30 1:00",
                     "1997-4-1 1:00",  "1997-4-30 2:00",
                      ...
                      "1997-4-1 23:00", "1997-5-1 0:00" ;

					</pre></div></div><p><br class="example-break"></p><div class="example"><a name="idp7165728"></a><p class="title"><b>Example 7.11. <font style="background-color:#ffccff">Extreme statistics and spell-lengths
        </font></b></p><div class="example-contents"><p><font style="background-color:#ffccff"> Number of frost days during NH winter
        2007-2008, and maximum length of spells of consecutive frost days. A
        "frost day" is defined as one during which the minimum temperature
        falls below freezing point (0 degC). This is described as a
        climatological statistic, in which the minimum temperature is first
        calculated within each day, and then the number of days or spell
        lengths meeting the specified condition are evaluated. In this
        operation, the standard name is also changed; the original data are
        <code class="varname">air_temperature </code>.</font></p><pre class="programlisting">
<font style="background-color:#ffccff">variables:
  float n1(lat,lon);
    n1:standard_name="number_of_days_with_air_temperature_below_threshold"; 
    n1:coordinates="threshold time";
    n1:cell_methods="time: minimum within days time: sum over days";
  float n2(lat,lon);
    n2:standard_name="spell_length_of_days_with_air_temperature_below_threshold";
    n2:coordinates="threshold time";
    n2:cell_methods="time: minimum within days time: maximum over days";
  float threshold;
    threshold:standard_name="air_temperature";
    threshold:units="degC";
  double time;
    time:climatology="climatology_bounds";
    time:units="days since 2000-6-1";
  double climatology_bounds(time,nv);
data: // time coordinates translated to date/time format
  time="2008-1-16 6:00";
  climatology_bounds="2007-12-1 6:00", "2000-8-2 6:00";
  threshold=0.; </font>

					</pre></div></div><p><br class="example-break"></p><div class="example"><a name="idp7171472"></a><p class="title"><b>Example 7.12. Temperature for each hour of the typical climatological
        day</b></p><div class="example-contents"><p>This is a modified version of the previous example<font style="background-color:#ffccff">, "Temperature for each hour of the average
        day"</font>. It now applies to April from a 1961-1990
        climatology.</p><pre class="programlisting">
variables:
  float temperature(time,lat,lon);
    temperature:long_name="surface air temperature";
    temperature:cell_methods="time: mean within days ",
      "time: mean over days time: mean over years";
    temperature:units="K";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 1961-1-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="1961-4-1 0:30", "1961-4-1 1:30", ..., "1961-4-1 23:30" ;
  climatology_bounds="1961-4-1 0:00", "1990-4-30 1:00",
                     "1961-4-1 1:00", "1990-4-30 2:00",
                     ...
                     "1961-4-1 23:00", "1990-5-1 0:00" ;
					</pre></div></div><p><br class="example-break"></p><div class="example"><a name="idp7175088"></a><p class="title"><b>Example 7.13. Monthly-maximum daily precipitation totals</b></p><div class="example-contents"><p>Maximum of daily precipitation amounts for each of the three
        months June, July and August 2000 are given. The first daily total
        applies to 6 a.m. on 1 June to 6 a.m. on 2 June, the 30th from 6 a.m.
        on 30 June to 6 a.m. on 1 July. The maximum of these 30 values is
        stored under time index 0 in the precipitation array.</p><pre class="programlisting">
dimensions:
  time=3;
  nv=2;
variables:
  float precipitation(time,lat,lon);
    precipitation:long_name="Accumulated precipitation";
    precipitation:cell_methods="time: sum within days time: maximum over days"; 
    precipitation:units="kg";
  double time(time);
    time:climatology="climatology_bounds";
    time:units="days since 2000-6-1";
  double climatology_bounds(time,nv);
data:  // time coordinates translated to date/time format
  time="2000-6-16", "2000-7-16", "2000-8-16" ;
  climatology_bounds="2000-6-1 6:00:00", "2000-7-1 6:00:00",
                     "2000-7-1 6:00:00", "2000-8-1 6:00:00",
                     "2000-8-1 6:00:00", "2000-9-1 6:00:00" ;
					</pre></div></div><p><br class="example-break"></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="idp7390416"></a>Chapter 8. 
		Reduction of Dataset Size
	</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#packed-data">8.1. Packed Data</a></span></dt><dt><span class="section"><a href="#compression-by-gathering">8.2. Compression by Gathering</a></span></dt></dl></div><p>
		There are two methods for reducing dataset size: packing
		and compression. By packing we mean altering the data
		in a way that reduces its precision. By compression we
		mean techniques that store the data more efficiently
		and result in no precision loss. Compression only
		works in certain circumstances, e.g., when a variable
		contains a significant amount of missing or repeated
		data values. In this case it is possible to make use of
		standard utilities, e.g., UNIX <code class="computeroutput">compress</code> 
		or GNU <code class="computeroutput">gzip</code>, to
		compress the entire file after it has been written. In
		this section we offer an alternative compression method
		that is applied on a variable by variable basis. This
		has the advantage that only one variable need be
		uncompressed at a given time. The disadvantage is that
		generic utilities that don't recognize the CF conventions
		will not be able to operate on compressed variables.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="packed-data"></a>8.1. Packed Data</h2></div></div></div><p>
			At the current time the netCDF interface does
			not provide for packing data. However a simple
			packing may be achieved through the use of the
			optional NUG defined attributes 
			<code class="varname">scale_factor</code>
			and
			<code class="varname">add_offset</code>. 
			After the data values of a variable
			have been read, they are to be multiplied by
			the 
			<code class="varname">scale_factor</code>, and have 
			<code class="varname">add_offset</code> 
			added to
			them. If both attributes are present, the data
			are scaled before the offset is added. When
			scaled data are written, the application should
			first subtract the offset and then divide by the
			scale factor. The units of a variable should be
			representative of the unpacked data.
		</p><p>
			This standard is more restrictive than the NUG
			with respect to the use of the 
			<code class="varname">scale_factor</code> and
			<code class="varname">add_offset</code> 
			attributes; ambiguities and precision
			problems related to data type conversions
			are resolved by these restrictions. If the
			<code class="varname">scale_factor</code> 
			and 
			<code class="varname">add_offset</code> 
			attributes are of
			the same data type as the associated variable,
			the unpacked data is assumed to be of the
			same data type as the packed data. However,
			if the 
			<code class="varname">scale_factor</code> 
			and 
			<code class="varname">add_offset</code> 
			attributes
			are of a different data type from the variable
			(containing the packed data) then the unpacked
			data should match the type of these attributes,
			which must both be of type <code class="varname">float</code> or both be of
			type <code class="varname">double</code>. An additional restriction in this
			case is that the variable containing the packed
			data must be of type <code class="varname">byte</code>, <code class="varname">short</code> or <code class="varname">int</code>. It is
			not advised to unpack an <code class="varname">int</code> into a <code class="varname">float</code> as
			there is a potential precision loss.
		</p><p>
			When data to be packed contains missing values
			the attributes that indicate missing values
			(<code class="varname">_FillValue</code>, <code class="varname">valid_min</code>, <code class="varname">valid_max</code>, <code class="varname">valid_range</code>)
			must be of the same data type as the packed
			data. See <a class="xref" href="#missing-data" title="2.5.1. Missing Data, valid and actual range">Section 2.5.1, &#8220;Missing Data<font style="background-color:#ffccff">, valid and actual
      range</font>&#8221;</a> for a discussion of how
			applications should treat variables that have
			attributes indicating both missing values and
			transformations defined by a scale and/or offset.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compression-by-gathering"></a>8.2. Compression by Gathering</h2></div></div></div><p>
			To save space in the netCDF file, it may be
			desirable to eliminate points from data arrays
			that are invariably missing. Such a compression
			can operate over one or more adjacent axes, and
			is accomplished with reference to a list of the
			points to be stored. The list is constructed by
			considering a mask array that only includes the
			axes to be compressed, and then mapping this array
			onto one dimension without reordering. The list is
			the set of indices in this one-dimensional mask
			of the required points. In the compressed array,
			the axes to be compressed are all replaced by a
			single axis, whose dimension is the number of
			wanted points. The wanted points appear along
			this dimension in the same order they appear in
			the uncompressed array, with the unwanted points
			skipped over. Compression and uncompression are
			executed by looping over the list.
		</p><p>
			The list is stored as the coordinate variable
			for the compressed axis of the data array. Thus,
			the list variable and its dimension have the same
			name. The list variable has a string attribute
			<code class="varname">compress</code>, <span class="emphasis"><em>containing a blank-separated list
			of the dimensions which were affected by the
			compression in the order of the CDL declaration
			of the uncompressed array</em></span>. The presence of
			this attribute identifies the list variable
			as such. The list, the original dimensions
			and coordinate variables (including boundary
			variables), and the compressed variables with
			all the attributes of the uncompressed variables
			are written to the netCDF file. The uncompressed
			variables can be reconstituted exactly as they
			were using this information.
		</p><p>
			</p><div class="example"><a name="idp7408560"></a><p class="title"><b>Example 8.1. Horizontal compression of a three-dimensional array</b></p><div class="example-contents"><p>
					 We eliminate sea
					 points at all depths in a
					 longitude-latitude-depth array of
					 soil temperatures. In this case,
					 only the longitude and latitude
					 axes would be affected by the
					 compression. We construct a list
					 <code class="varname">landpoint(landpoint)</code> containing
					 the indices of land points.
				</p><p>
					</p><pre class="programlisting">
dimensions:
  lat=73;
  lon=96;
  landpoint=2381;
  depth=4;
variables:
  int landpoint(landpoint);
    landpoint:compress="lat lon";
  float landsoilt(depth,landpoint);
    landsoilt:long_name="soil temperature";
    landsoilt:units="K";
  float depth(depth);
  float lat(lat);
  float lon(lon);
data:
  landpoint=363, 364, 365, ...;

					</pre><p>
				</p><p>
					Since 
					<code class="computeroutput">landpoint(0)=363</code>, 
					for instance, we know that 
					<code class="computeroutput">landsoilt(*,0)</code> 
					maps on to point 363 of the original data with dimensions 
					<code class="computeroutput">(lat,lon)</code>. 
					This corresponds to indices 
					<code class="computeroutput">(3,75)</code>, 
					i.e., 
					<code class="computeroutput">363 = 3*96 + 75</code>. 
				</p></div></div><p><br class="example-break">
		</p><p>
			</p><div class="example"><a name="idp7415616"></a><p class="title"><b>Example 8.2. Compression of a three-dimensional field</b></p><div class="example-contents"><p>
					We compress a longitude-latitude-depth field of ocean salinity by eliminating points below the sea-floor. In this case, all three dimensions are affected by the compression, since there are successively fewer active ocean points at increasing depths.
				</p><p>
					</p><pre class="programlisting">
variables:
  float salinity(time,oceanpoint);
  int oceanpoint(oceanpoint);
    oceanpoint:compress="depth lat lon";
  float depth(depth);
  float lat(lat);
  float lon(lon);
  double time(time);
					</pre><p>
				</p><p>
					This information implies that
					the salinity field should be
					uncompressed to an array with
					dimensions 
					<code class="computeroutput">(depth,lat,lon)</code>.
				</p></div></div><p><br class="example-break">
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="discrete-sampling-geometries"></a>Chapter 9. <font style="background-color:#ffccff">Discrete Sampling Geometries</font></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#idp7424512">9.1. Features and feature types</a></span></dt><dt><span class="sect1"><a href="#idp7520656">9.2. Collections, instances and elements</a></span></dt><dt><span class="sect1"><a href="#representations-features">9.3. Representations of collections of features in data variables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp7543328">9.3.1. Orthogonal multidimensional array representation</a></span></dt><dt><span class="sect2"><a href="#idp7587200">9.3.2.  Incomplete multidimensional array representation</a></span></dt><dt><span class="sect2"><a href="#idp7622336">9.3.3.  Contiguous ragged array representation</a></span></dt><dt><span class="sect2"><a href="#idp7666048">9.3.4. Indexed ragged array representation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#featureType">9.4. The featureType  attribute</a></span></dt><dt><span class="sect1"><a href="#coordinates-metadata">9.5. Coordinates and metadata</a></span></dt><dt><span class="sect1"><a href="#idp7736784">9.6. Missing Data</a></span></dt></dl></div><p><font style="background-color:#88ff88; font-style:italic">Note: For greater readability, the conventional highlighting for new material. has not been applied to the whole chapter.</font></p><p>This chapter provides representations for <span class="bold"><strong>discrete sampling geometries</strong></span>, such as time series, vertical profiles and trajectories. Discrete sampling geometry datasets are characterized by a dimensionality that is lower than that of the space-time region that is sampled; discrete sampling geometries are typically &#8220;paths&#8221; through space-time.  </p><p></p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp7424512"></a>9.1. Features and feature types</h2></div></div></div><p>Each type of discrete sampling geometry (point, time series, profile
   or trajectory) is defined by the relationships among its spatiotemporal
   coordinates.  We refer to the type of discrete sampling geometry as its
   <span class="bold"><strong>featureType</strong></span>.  The term &#8220;<span class="bold"><strong>feature</strong></span>&#8221; refers herein to a single instance of the
   <span class="bold"><strong>discrete sampling geometry</strong></span> (such as a
   single time series).  The representation of such features in a CF dataset
   was supported previous to the introduction of this chapter using a
   particular convention, which is still supported (that described by section
   9.3.1).  This chapter describes further conventions which offer advantages
   of efficiency and clarity for storing a collection of features in a single
   file.  When using these new conventions, <span class="emphasis"><em>the
   features contained within a collection must always be of the same type; and
   all the collections in a CF file must be of the same feature
   type</em></span>. (Future versions of CF may allow mixing of multiple feature
   types within a file.)  Table 9.1 presents the feature types covered by this
   chapter.</p><p></p><div class="informaltable"><table border="1" width="85%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p><span class="bold"><strong>featureType</strong></span></p>
	 </td><td>
	   <p><span class="bold"><strong>Description of a single feature with this discrete sampling geometry</strong></span></p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p><span class="bold"><strong>Form of a data variable containing values defined on a collection of these features</strong></span></p></td><td>
	   <p><span class="bold"><strong>Mandatory space-time coordinates for a collection of these features                                                </strong></span></p></td></tr></tbody></table></div>
	 </td></tr><tr><td>
	   <p><span class="bold"><strong>point</strong></span></p>
	 </td><td>
	   <p>a single data point (having no implied coordinate relationship to other points)</p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1" width="100%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p>      data(i)</p></td><td>
	   <p>x(i) y(i)  t(i) </p></td></tr></tbody></table></div>
	 </td></tr><tr><td>
	   <p><span class="bold"><strong>timeSeries</strong></span></p>
	 </td><td>
	   <p>a series of data points at the same spatial location with monotonically increasing times</p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1" width="100%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p>     data(i,o)</p></td><td>
	   <p>x(i) y(i) t(i,o) </p></td></tr></tbody></table></div>
	 </td></tr><tr><td>
	   <p><span class="bold"><strong>trajectory</strong></span></p>
	 </td><td>
	   <p>a series of data points along a path through space with monotonically increasing times</p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1" width="100%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p>       data(i,o)    </p></td><td>
	   <p>x(i,o) y(i,o) t(i,o) </p></td></tr></tbody></table></div>
	 </td></tr><tr><td>
	   <p><span class="bold"><strong>profile</strong></span></p>
	 </td><td>
	   <p>an ordered set of data points along a vertical line at a fixed horizontal position and fixed time</p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1" width="100%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p>       data(i,o)    </p></td><td>
	   <p>x(i) y(i) z(i,o) t(i) </p></td></tr></tbody></table></div>
	 </td></tr><tr><td>
	   <p><span class="bold"><strong>timeSeriesProfile</strong></span></p>
	 </td><td>
	   <p>a series of profile features at the same horizontal position with monotonically increasing times</p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1" width="100%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p>       data(i,p,o)     </p></td><td>
	   <p>x(i) y(i) z(i,p,o) t(i,p) </p></td></tr></tbody></table></div>
	 </td></tr><tr><td>
	   <p><span class="bold"><strong>trajectoryProfile</strong></span></p>
	 </td><td>
	   <p>a series of profile features located at points ordered along a trajectory</p>
	 </td></tr><tr><td> </td><td><div class="informaltable"><table border="1" width="100%"><colgroup><col><col></colgroup><tbody><tr><td>
	   <p>       data(i,p,o)         </p></td><td>
	   <p>x(i,p) y(i,p) z(i,p,o) t(i,p) </p></td></tr></tbody></table></div>
	 </td></tr></tbody></table></div><p></p><p><span class="bold"><strong>Table 9.1.</strong></span> Logical structure and mandatory coordinates for discrete sampling geometry featureTypes.</p><p></p><p>In Table 9.1 the spatial coordinates x and y typically refer to longitude and latitude but other horizontal coordinates could also be used (see sections 4 and 5.6).   The spatial coordinate z refers to vertical position.  The time coordinate is indicated as t.  The space-time coordinates that are indicated for each feature are mandatory.  However a featureType may also include other space-time coordinates which are not mandatory (notably the z coordinate).  The array subscripts that are shown illustrate only the <span class="emphasis"><em>logical</em></span> structure of the data.  The subscripts found in actual CF files are determined by the specific type of representations (see section 9.3).</p><p></p><p>The designation of dimensions as mandatory precludes the encoding of data variables where geo-positioning cannot be described as a discrete point location.  Problematic examples include:   </p><p></p><div class="itemizedlist"><ul type="disc"><li><p>time series that refer to a geographical region (e.g. the northern hemisphere), a volume (e.g. the troposphere), or a geophysical quantity in which geolocation information is inherent (e.g. the Southern Oscillation Index (SOI) is the difference between values at two point locations);</p></li><li><p>vertical profiles that similarly represent geographically area-averaged values;  and</p></li><li><p>paths in space that indicate a geographically located feature, but lack a suitable time coordinate (e.g. a meteorological front). </p></li></ul></div><p></p><p>Future versions of CF will generalize the concepts of geolocation to encompass these cases.  As of CF version 1.6 such data can be stored using the representations that are documented here by two means: 1) by utilizing the orthogonal multidimensional array representation and omitting the featureType attribute; or 2) by assigning arbitrary coordinates to the mandatory dimensions.  For example a globally-averaged latitude position (90s to 90n) could be represented arbitrarily (and poorly) as a latitude position at the equator.</p><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp7520656"></a>9.2. Collections, instances and elements</h2></div></div></div><p></p><p>In Table 9.1 the dimension with subscript i identifies a particular feature within a collection of features. It is called the <span class="bold"><strong>instance dimension</strong></span>. One-dimensional variables in a Discrete Geometry CF file, which have <span class="emphasis"><em>only</em></span> this dimension (such as x(i) y(i) and z(i) for a timeseries), are <span class="bold"><strong>instance variables</strong></span>. Instance variables provide the metadata that differentiates individual features.</p><p></p><p>The subscripts o and p distinguish the data elements that compose a single feature.  For example in a collection of <span class="bold"><strong>timeSeries</strong></span> features, each time series instance, i, has data values at various times, o.  In a collection of <span class="bold"><strong>profile</strong></span> features, the subscript, o, provides the index position along the vertical axis of each profile instance. We refer to data values in a feature as its <span class="bold"><strong>elements</strong></span>, and to the dimensions of o and p as <span class="bold"><strong>element dimensions</strong></span>. Each feature can have its own set of element subscripts o and p. For instance, in a collection of timeSeries features, each individual timeSeries can have its own set of times.  The notation t(i,o) means there is a set of times with subscripts o for the elements of each feature i.   Feature instances within a collection need not have the same numbers of elements. If the features do all have the same number of elements, and the sequence of element coordinates is identical for all features, savings in simplicity and space are achievable by storing only one copy of these coordinates.  This is the essence of the orthogonal multidimensional representation (see section 9.3.1). </p><p></p><p>If there is only a single feature to be stored in a data variable, there is no need for an instance dimension and it is permitted to omit it. The data will then be one-dimensional, which is a special (degenerate) case of the multidimensional array representation.  The instance variables will be scalar coordinate variables; the data variable and other auxiliary coordinate variables will have only an element dimension and not have an instance dimension, e.g. data(o) and t(o) for a single timeSeries.</p><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="representations-features"></a>9.3. Representations of collections of features in data variables</h2></div></div></div><p></p><p>The individual features within a collection need not necessarily contain the same number of elements.   For instance observed in situ time series will commonly contain unique numbers of time points, reflecting different deployment dates of the instruments.   Other data sources, such as the output of numerical models, may commonly generate features of identical size.  CF offers multiple representations to allow the storage to be optimized for the character of the data.  Four types of representation are utilized in this chapter: </p><p></p><div class="itemizedlist"><ul type="disc"><li><p>two <span class="bold"><strong>multidimensional array representations</strong></span>, in which each feature instance is allocated the identical amount of storage space.  In these representations the instance dimension and the element dimension(s) are distinct CF coordinate axes (typical of coordinate axes discussed in chapter 4); and</p></li><li><p>two <span class="bold"><strong>ragged array representations</strong></span>, in which each feature is provided with the minimum amount of space that it requires.  In these representations the instances of the individual features are stacked sequentially along the same array dimension as the elements of the features; we refer to this combined dimension as the <span class="bold"><strong>sample dimension</strong></span>.</p></li></ul></div><p></p><p>In the multidimensional array representations, data variables have both an instance dimension and an element dimension.  The dimensions may be given in any order.  If there is a need for either the instance or an element dimension to be the netCDF unlimited dimension (so that more features or more elements can be appended), then that dimension must be the outer dimension of the data variable i.e. the leading dimension in CDL.</p><p>In the ragged array representations, the instance dimension (<code class="varname">i</code>), which sequences the individual features within the collection, and the element dimension, which sequences the data elements of each feature (<code class="varname">o</code> and <code class="varname">p</code>), both occupy the same dimension (the sample dimension).   If the sample dimension is the netCDF unlimited dimension, new data can be appended to the file.   </p><p>In all representations, the instance dimension (which is also the sample dimension in ragged representations) may be set initially to a size that is arbitrarily larger than what is required for the features which are available at the time that the file is created.   Allocating unused array space in this way (pre-filled with missing values -- see also section 9.6, <span class="emphasis"><em>Missing data</em></span>), can be useful as a means to reserve space that will be available to add features at a later time.</p><p></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp7543328"></a>9.3.1. Orthogonal multidimensional array representation</h3></div></div></div><p></p><p>The <span class="bold"><strong>orthogonal multidimensional array representation</strong></span>, the simplest representation, can be used if each feature instance in the collection has identical coordinates along the element axis of the features.  For example, for a collection of the timeSeries that share a common set of times, or a collection of profiles that share a common set of vertical levels, this is likely to be the natural representation to use.  In both examples, there will be longitude and latitude coordinate variables, x(i), y(i), that are one-dimensional and defined along the instance dimension.</p><p>Table 9.2 illustrates the storage of a data variable using the orthogonal multidimensional array representation.  The data variable holds a collection of 4 features.  The individual features, distinguished by color, are sequenced along the horizontal axis by the instance dimension indices, i1, i2, i3, i4.  Each instance contains three elements, sequenced along the vertical with element dimension indices, o1, o2, o3.  The i and o subscripts would be interchanged (i.e. Table 9.2 would be transposed) if the element dimension were the netCDF unlimited dimension.</p><p></p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td bgcolor="#99dddd">
               <p>(i1, o1)</p>
	       
            </td><td bgcolor="#f6c682">
               <p>(i2, o1)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>(i3, o1)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o1)</p>
	       
            </td></tr><tr><td bgcolor="#99dddd">
               <p>(i1, o2)</p>
	       
            </td><td bgcolor="#f6c682">
               <p>(i2, o2)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>(i3, o2)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o2)</p>
	       
            </td></tr><tr><td bgcolor="#99dddd">
               <p>(i1, o3)</p>
	       
            </td><td bgcolor="#f6c682">
               <p>(i2, o3)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>(i3, o3)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o3)</p>
	       
            </td></tr></tbody></table></div><p></p><p>Table 9.2  The storage of a data variable using the orthogonal multidimensional array representation (subscripts in CDL order).</p><p></p><p>The instance variables of a dataset corresponding to Table 9.2 will be one-dimensional with size 4 (for example, the latitude locations of timeSeries), </p><p></p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td bgcolor="#99dddd">
               <p>lat(i1)</p>
	       
            </td><td bgcolor="#f6c682">
               <p>lat(i2)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>lat(i3)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>lat(i4)</p>
	       
            </td></tr></tbody></table></div><p></p><p>and the element coordinate axis will be one-dimensional with size 3 (for example, the time </p><p></p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td bgcolor="#d7d7d7">
               <p>time(o1)</p>
	       
            </td></tr><tr><td bgcolor="#d7d7d7">
               <p>time(o2)</p>
	       
            </td></tr><tr><td bgcolor="#d7d7d7">
               <p>time(o3)</p>
	       
            </td></tr><tr><td bgcolor="#d7d7d7">
               <p>time(o4)</p>
	       
            </td></tr></tbody></table></div><p></p><p>coordinates that are shared by all of the timeSeries). This representation is consistent with the multidimensional fields described in chapter 5; the characteristic that makes it atypical from chapter 5 (though not incompatible) is that the instance dimension is a discrete axis (see section 4.5).</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp7587200"></a>9.3.2.  Incomplete multidimensional array representation</h3></div></div></div><p></p><p>The <span class="bold"><strong>incomplete multidimensional array representation</strong></span> can used if the features within a collection do not all have the same number of elements, but sufficient storage space is available to allocate the number of elements required by the longest feature to all features.  That is, features that are shorter than the longest feature must be padded with missing values to bring all instances to the same storage size. This representation sacrifices storage space to achieve simplicity for reading and writing.  </p><p></p><p>Table 9.3 illustrates the storage of a data variable using the orthogonal multidimensional array representation.   The data variable holds a collection of 4 features.  The individual features, distinguished by color, are sequenced by the instance dimension indices, i1, i2, i3, i4.  The instances contain respectively 2, 4, 3 and 6 elements, sequenced by the element dimension index with values of o1, o2, o3, ....  The i and o subscripts would be interchanged (i.e. Table 9.3 would be transposed) if the element dimension were the netCDF unlimited dimension.</p><p></p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td bgcolor="#99dddd">
               <p> (i1, o1)</p>
	       
            </td><td bgcolor="#f6c682">
               <p>(i2, o1)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>(i3, o1)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o1)</p>
	       
            </td></tr><tr><td bgcolor="#99dddd">
               <p>(i1, o2)</p>
	       
            </td><td bgcolor="#f6c682">
               <p>(i2, o2)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>(i3, o2)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o2)</p>
	       
            </td></tr><tr><td>
               <p></p>
            </td><td bgcolor="#f6c682">
               <p>(i2, o3)</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>(i3, o3)</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o3)</p>
	       
            </td></tr><tr><td>
               <p></p>
            </td><td bgcolor="#f6c682">
               <p>(i2, o4)</p>
	       
            </td><td>
               <p></p>
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o4)</p>
	       
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p></p>
            </td><td>
               <p></p>
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o5)</p>
	       
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p></p>
            </td><td>
               <p></p>
            </td><td bgcolor="#ddaaaa">
               <p>(i4, o6)</p>
	       
            </td></tr></tbody></table></div><p>        </p><p>Table 9.3.   The storage of data using the incomplete multidimensional array representation (subscripts in CDL order).</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp7622336"></a>9.3.3.  Contiguous ragged array representation</h3></div></div></div><p></p><p> The <span class="bold"><strong>contiguous ragged array representation</strong></span> can be used only if the size of each feature is known at the time that it is created.  In this representation the data for each feature will be contiguous on disk, as shown in Table 9.4. </p><p></p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td bgcolor="#99dddd">
               <p>(i1, o1)</p>
	       
            </td></tr><tr><td bgcolor="#99dddd">
               <p>(i1, o2)</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o1)</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o2)</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o3)</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o4)</p>
	       
            </td></tr><tr><td bgcolor="#d4b4de">
               <p>(i3, o1)</p>
	       
            </td></tr><tr><td bgcolor="#d4b4de">
               <p>(i3, o2)</p>
	       
            </td></tr><tr><td bgcolor="#d4b4de">
               <p>(i3, o3)</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o1)</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o2)</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o3)</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o4)</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o5)</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o6)</p>
	       
            </td></tr></tbody></table></div><p>        </p><p>Table 9.4. The storage of data using the contiguous ragged representation (subscripts in CDL order). </p><p></p><p>In this representation, the file contains a <span class="bold"><strong>count variable</strong></span>, which must be of type integer and </p><p></p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td>
               <p>count(i1)</p>
            </td><td>
               <p>count(i2)</p>
            </td><td>
               <p>count(i3)</p>
            </td><td>
               <p>count(i4)</p>
            </td></tr><tr><td bgcolor="#99dddd">
               <p>2</p>
	       
            </td><td bgcolor="#f6c682">
               <p>4</p>
	       
            </td><td bgcolor="#d4b4de">
               <p>3</p>
	       
            </td><td bgcolor="#ddaaaa">
               <p>6</p>
	       
            </td></tr></tbody></table></div><p></p><p>must have the instance dimension as its sole dimension.  The count variable contains the number of elements that each feature has. This representation and its count variable are identifiable by the presence of an attribute, <code class="varname">sample_dimension</code>, found on the count variable, which names the sample dimension being counted. For indices that correspond to features, whose data have not yet been written, the count variable should  have a value of zero or a missing value.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp7666048"></a>9.3.4. Indexed ragged array representation</h3></div></div></div><p></p><p>The <span class="bold"><strong>indexed ragged array representation</strong></span> stores the features interleaved along the sample dimension in the data variable as shown in Table 9.4. The canonical use case for this representation is the storage of real-time data streams that contain reports from many sources; the data can be written as it arrives. </p><p></p><p></p><p></p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td bgcolor="#99dddd">
               <p>(i1, o1)</p>
	       
            </td><td>        </td><td bgcolor="#99dddd">
               <p>0</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o1)</p>
	       
            </td><td> </td><td bgcolor="#f6c682">
               <p>1</p>
	       
            </td></tr><tr><td bgcolor="#d4b4de">
               <p>(i3, o1)</p>
	       
            </td><td> </td><td bgcolor="#d4b4de">
               <p>2</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o1)</p>
	       
            </td><td> </td><td bgcolor="#ddaaaa">
               <p>3</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o2)</p>
	       
            </td><td> </td><td bgcolor="#ddaaaa">
               <p>3</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o2)</p>
	       
            </td><td> </td><td bgcolor="#f6c682">
               <p>1</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o3)</p>
	       
            </td><td> </td><td bgcolor="#ddaaaa">
               <p>3</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o4)</p>
	       
            </td><td> </td><td bgcolor="#ddaaaa">
               <p>3</p>
	       
            </td></tr><tr><td bgcolor="#99dddd">
               <p>(i1, o2)</p>
	       
            </td><td> </td><td bgcolor="#99dddd">
               <p>0</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o3)</p>
	       
            </td><td> </td><td bgcolor="#f6c682">
               <p>1</p>
	       
            </td></tr><tr><td bgcolor="#d4b4de">
               <p>(i3, o2)</p>
	       
            </td><td> </td><td bgcolor="#d4b4de">
               <p>2</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o5)</p>
	       
            </td><td> </td><td bgcolor="#ddaaaa">
               <p>3</p>
	       
            </td></tr><tr><td bgcolor="#d4b4de">
               <p>(i3, o3)</p>
	       
            </td><td> </td><td bgcolor="#d4b4de">
               <p>2</p>
	       
            </td></tr><tr><td bgcolor="#f6c682">
               <p>(i2, o4)</p>
	       
            </td><td> </td><td bgcolor="#f6c682">
               <p>1</p>
	       
            </td></tr><tr><td bgcolor="#ddaaaa">
               <p>(i4, o6)</p>
	       
            </td><td> </td><td bgcolor="#ddaaaa">
               <p>3</p>
	       
            </td></tr></tbody></table></div><p>        </p><p>Table 9.4 The storage of data using the indexed ragged representation (subscripts in CDL order).  The left hand side of the table illustrates a data variable; the right hand side of the table contains the values of the index variable.</p><p></p><p>In this representation, the file contains an <span class="bold"><strong>index variable</strong></span>, which must be of type integer, and must have the sample dimension as its single dimension. The index variable contains the zero-based index of the feature to which each element belongs. This representation is identifiable by the presence of an attribute, <code class="varname">instance_dimension</code>, on the index variable, which names the dimension of the instance variables. For those indices of the sample dimension, into which data have not yet been written, the index variable should be pre-filled with missing values.</p><p></p><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="featureType"></a>9.4. The featureType  attribute</h2></div></div></div><p>A global attribute, <span class="bold"><strong>featureType</strong></span>, is required for all Discrete Geometry representations except the orthogonal multidimensional array representation, for which it is highly recommended.  The exception is allowed for backwards compatibility, as discussed in 9.3.1.  A Discrete Geometry file may include arbitrary numbers of data variables, but (as of CF v1.6) all of the data variables contained in a single file must be of the single feature type indicated by the global <code class="varname">featureType</code> attribute, if it is present.1   The value assigned to the <code class="varname">featureType</code> attribute is case-insensitive;  it must be one of the string values listed in the left column of Table 9.1.</p><p></p><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="coordinates-metadata"></a>9.5. Coordinates and metadata</h2></div></div></div><p>Every feature within a Discrete Geometry CF file must be unambiguously associated with an extensible collection of instance variables that identify the feature and provide other metadata as needed to describe it.  Every element of every feature must be unambiguously associated with its space and time coordinates and with the feature that contains it.  The <code class="varname">coordinates</code> attribute must be attached to every data variable to indicate the spatiotemporal coordinate variables that are needed to geo-locate the data.</p><p></p><p>Where feasible a variable with the attribute <span class="bold"><strong>cf_role</strong></span> should be included.  The only acceptable values of cf_role for Discrete Geometry CF data sets are <code class="varname">timeseries_id</code>, <code class="varname">profile_id</code>, and <code class="varname">trajectory_id</code>.   The variable carrying the cf_role attribute may have any data type.  When a variable is assigned this attribute, it must provide a unique identifier for each feature instance.   CF files that contain timeSeries, profile or trajectory featureTypes, should include only a single occurrence of a <code class="varname">cf_role</code> attribute;  CF files that contain timeSeriesProfile or trajectoryProfile may contain two occurrences, corresponding to the two levels of structure in these feature types.</p><p></p><p>It is not uncommon for observational data to have two sets of coordinates for particular coordinate axes of a feature: a nominal point location and a more precise location that varies with the elements in the feature.  For example, although an idealized vertical profile is measured at a fixed horizontal position and time, a realistic representation might include the time variations and horizontal drift that occur during the duration of the sampling.  Similarly, although an idealized time series exists at a fixed lat-long position, a realistic representation of a moored ocean time series might include the &#8220;watch cycle&#8221; excursions of horizontal position that occur as a result of tidal currents.</p><p></p><p>CF Discrete Geometries provides a mechanism to encode both the nominal and the precise positions, while retaining the semantics of the idealized feature type. Only the set of coordinates which are regarded as the nominal (default or preferred) positions should be indicated by the attribute <code class="varname">axis</code>, which should be assigned string values to indicate the orientations of the axes (<code class="varname">X</code>, <code class="varname">Y</code>, <code class="varname">Z</code>, or <code class="varname">T</code>).  See example A9.2.3.2.  Auxiliary coordinate variables containing the nominal and the precise positions should be listed in the relevant <code class="varname">coordinates</code> attributes of data variables. In orthogonal representations the nominal positions could be  coordinate variables, which do not need to be listed in the <code class="varname">coordinates</code> attribute, rather than auxiliary coordinate variables.</p><p>Coordinate bounds may optionally be associated with coordinate variables and auxiliary coordinate variables using the bounds attribute, following the conventions described in section 7.1.  Coordinate bounds are especially important for accurate representations of model output data using discrete geometry representations; they record the boundaries of the model grid cells.</p><p></p><p>If there is a vertical coordinate variable or auxiliary coordinate variable, it must be identified by the means specified in section 4.3.   The use of the attribute <code class="varname">axis=Z</code> is recommended for clarity.  A <code class="varname">standard_name</code> attribute (see section 3.3) that identifies the vertical coordinate is recommended, e.g. "altitude", "height", etc. . (See the CF Standard Name Table).</p><p></p><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp7736784"></a>9.6. Missing Data</h2></div></div></div><p>Auxiliary coordinate variables (spatial and time) must contain missing values to indicate a void in data storage in the file but must not have missing data for any other reason. This situation may arise for unused elements in the incomplete multidimensional array representation, and in any representation if the instance dimension is set to a larger size than the number of features currently stored.   It is not permitted for auxiliary coordinate variables to have missing values for elements where there is non-missing data. Where <span class="emphasis"><em>any</em></span> auxiliary coordinate variable contains a missing value, <span class="emphasis"><em>all</em></span> other coordinate, auxiliary coordinate and data values corresponding to that element should <span class="emphasis"><em>also</em></span> contain missing values. Data variables should (as usual) also contain missing values to indicate when there is no valid data available for the element, although the coordinates are valid.</p><p></p><p>Similarly, for indices where the instance variable identified by <code class="varname">cf_role</code> contains a missing value indicator, all other instance variable should also contain missing values.</p><p></p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="attribute-appendix"></a>Appendix A. Attributes</h2></div></div></div><p>All CF attributes are listed here except for those that are used to
  describe grid mappings. See Appendix F for the grid mapping
  attributes.</p><p>The "Type" values are <span class="bold"><strong>S</strong></span> for string,
  <span class="bold"><strong>N</strong></span> for numeric, and <span class="bold"><strong>D</strong></span> for the type of the data variable. The "Use" values
  are <span class="bold"><strong>G</strong></span> for global, <span class="bold"><strong>C</strong></span> for variables containing coordinate data, and
  <span class="bold"><strong>D</strong></span> for variables containing non-coordinate
  data. "Links" indicates the location of the attribute"s original definition
  (first link) and sections where the attribute is discussed in this document
  (additional links as necessary). </p><div class="table"><a name="idp8065200"></a><p class="title"><b>Table A.1. Attributes</b></p><div class="table-contents"><table summary="Attributes" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Type</th><th align="center">Use</th><th align="center">Links</th><th align="center">Description</th></tr></thead><tbody><tr><td align="left"><font style="background-color:#ffccff"><code class="varname">actual_range</code></font></td><td align="center"><font style="background-color:#ffccff">N</font></td><td align="center"><font style="background-color:#ffccff">C,
            D</font></td><td align="center"><font style="background-color:#ffccff"><a class="xref" href="#actual_range">Section 2.5.1, &#8220;Missing Data<font style="background-color:#ffccff">, valid and actual
      range</font>&#8221;</a></font></td><td align="left"><font style="background-color:#ffccff">The smallest and the largest valid
            non-missing values occurring in the variable</font></td></tr><tr><td align="left"><code class="varname">add_offset</code></td><td align="center">N</td><td align="center">D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font> , <a class="xref" href="#packed-data" title="8.1. Packed Data">Section 8.1, &#8220;Packed Data&#8221;</a></td><td align="left">If present for a variable, this number is to be added to
            the data after it is read by an application. If both
            <code class="varname">scale_factor</code> and <code class="varname">add_offset</code>
            attributes are present, the data are first scaled before the
            offset is added.</td></tr><tr><td align="left"><code class="varname">ancillary_variables </code></td><td align="center">S</td><td align="center">D</td><td align="center"><a class="xref" href="#ancillary-data" title="3.4. Ancillary Data">Section 3.4, &#8220;Ancillary Data&#8221;</a></td><td align="left">Identifies a variable that contains closely associated
            data, e.g., the measurement uncertainties of instrument
            data.</td></tr><tr><td align="left"><code class="varname">axis</code></td><td align="center">S</td><td align="center">C</td><td align="center"><a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a></td><td align="left">Identifies latitude, longitude, vertical, or time
            axes.</td></tr><tr><td align="left"><code class="varname">bounds</code></td><td align="center">S</td><td align="center">C</td><td align="center"><a class="xref" href="#cell-boundaries" title="7.1. Cell Boundaries">Section 7.1, &#8220;Cell Boundaries&#8221;</a></td><td align="left">Identifies a boundary variable.</td></tr><tr><td align="left"><code class="varname">calendar</code></td><td align="center">S</td><td align="center">C</td><td align="center"><a class="xref" href="#calendar" title="4.4.1. Calendar">Section 4.4.1, &#8220;Calendar&#8221;</a></td><td align="left">Calendar used for encoding time axes.</td></tr><tr><td align="left"><code class="varname">cell_measures</code></td><td align="center">S</td><td align="center">D</td><td align="center"><a class="xref" href="#cell-measures" title="7.2. Cell Measures">Section 7.2, &#8220;Cell Measures&#8221;</a></td><td align="left">Identifies variables that contain cell areas or
            volumes.</td></tr><tr><td align="left"><code class="varname">cell_methods</code></td><td align="center">S</td><td align="center">D</td><td align="center"><a class="xref" href="#cell-methods" title="7.3. Cell Methods">Section 7.3, &#8220;Cell Methods&#8221;</a>, <a class="xref" href="#climatological-statistics" title="7.4. Climatological Statistics">Section 7.4, &#8220;Climatological Statistics&#8221;</a></td><td align="left">Records the method used to derive data that represents cell
            values.</td></tr><tr><td align="left"><font style="background-color:#ffccff"><code class="varname">cf_role</code></font></td><td align="center"><font style="background-color:#ffccff">C</font></td><td align="center"><font style="background-color:#ffccff">C</font></td><td align="center"><font style="background-color:#ffccff"><a class="xref" href="#coordinates-metadata" title="9.5. Coordinates and metadata">Section 9.5, &#8220;Coordinates and metadata&#8221;</a></font></td><td align="left"><font style="background-color:#ffccff">Identifies the roles of variables
            that identify features in discrete sampling
            geometries</font></td></tr><tr><td align="left"><code class="varname">climatology</code></td><td align="center">S</td><td align="center">C</td><td align="center"><a class="xref" href="#climatological-statistics" title="7.4. Climatological Statistics">Section 7.4, &#8220;Climatological Statistics&#8221;</a></td><td align="left">Identifies a climatology variable.</td></tr><tr><td align="left"><code class="varname">comment</code></td><td align="center">S</td><td align="center">G, D</td><td align="center"><a class="xref" href="#description-of-file-contents" title="2.6.2. Description of file contents">Section 2.6.2, &#8220;Description of file contents&#8221;</a></td><td align="left">Miscellaneous information about the data or methods used to
            produce it.</td></tr><tr><td align="left"><code class="varname">compress</code></td><td align="center">S</td><td align="center">C</td><td align="center"><a class="xref" href="#compression-by-gathering" title="8.2. Compression by Gathering">Section 8.2, &#8220;Compression by Gathering&#8221;</a>,
            <a class="xref" href="#reduced-horizontal-grid" title="5.3. Reduced Horizontal Grid">Section 5.3, &#8220;Reduced Horizontal Grid&#8221;</a></td><td align="left">Records dimensions which have been compressed by
            gathering.</td></tr><tr><td align="left"><code class="varname">Conventions</code></td><td align="center">S</td><td align="center">G</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">Name of the conventions followed by the dataset.</td></tr><tr><td align="left"><code class="varname">coordinates</code></td><td align="center">S</td><td align="center">D</td><td align="center"><a class="xref" href="#coordinate-system" title="Chapter 5. Coordinate Systems">Chapter 5, <i>Coordinate Systems</i></a>, <a class="xref" href="#labels" title="6.1. Labels">Section 6.1, &#8220;Labels&#8221;</a>, <a class="xref" href="#alternative-coordinates" title="6.2. Alternative Coordinates">Section 6.2, &#8220;Alternative Coordinates&#8221;</a></td><td align="left">Identifies auxiliary coordinate variables, label variables,
            and alternate coordinate variables.</td></tr><tr><td align="left"><code class="varname">_FillValue</code></td><td align="center">D</td><td align="center"><font style="background-color:#ffccff">C,
            </font>D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">A value used to represent missing or undefined
            data.<font style="background-color:#ffccff"> Not allowed for coordinate data
            except in the case of auxiliary coordinate varibles in discrete
            sampling geometries.</font></td></tr><tr><td align="left"><font style="background-color:#ffccff"><code class="varname">featureType</code></font></td><td align="center"><font style="background-color:#ffccff">C</font></td><td align="center"><font style="background-color:#ffccff">G</font></td><td align="center"><font style="background-color:#ffccff"><a class="xref" href="#featureType" title="9.4. The featureType  attribute">Section 9.4, &#8220;The featureType  attribute&#8221;</a></font></td><td align="left"><font style="background-color:#ffccff">Specifies the type of discrete
            sampling geometry to which the data in the file belongs, and
            implies that all data variables in the file contain collections of
            features of that type.</font></td></tr><tr><td align="left"><code class="varname"><font style="background-color:#ffccff">flag_masks</font></code></td><td align="center"><font style="background-color:#ffccff">D</font></td><td align="center"><font style="background-color:#ffccff">D</font></td><td align="center"><font style="background-color:#ffccff"><a class="xref" href="#flags" title="3.5. Flags">Section 3.5, &#8220;Flags&#8221;</a></font></td><td align="left"><font style="background-color:#ffccff">Provides a list of bit fields
            expressing Boolean or enumerated flags.</font></td></tr><tr><td align="left"><code class="varname">flag_meanings</code></td><td align="center">S</td><td align="center">D</td><td align="center"><a class="xref" href="#flags" title="3.5. Flags">Section 3.5, &#8220;Flags&#8221;</a></td><td align="left">Use in conjunction with <code class="varname">flag_values</code> to
            provide descriptive words or phrases for each flag value. If
            multi-word phrases are used to describe the flag values, then the
            words within a phrase should be connected with
            underscores.</td></tr><tr><td align="left"><code class="varname">flag_values</code></td><td align="center">D</td><td align="center">D</td><td align="center"><a class="xref" href="#flags" title="3.5. Flags">Section 3.5, &#8220;Flags&#8221;</a></td><td align="left">Provides a list of the flag values. Use in conjunction with
            <code class="varname">flag_meanings</code>.</td></tr><tr><td align="left"><code class="varname">formula_terms</code></td><td align="center">S</td><td align="center">C</td><td align="center"><a class="xref" href="#dimensionless-vertical-coordinate" title="4.3.2. Dimensionless Vertical Coordinate">Section 4.3.2, &#8220;Dimensionless Vertical Coordinate&#8221;</a></td><td align="left">Identifies variables that correspond to the terms in a
            formula.</td></tr><tr><td align="left"><code class="varname">grid_mapping</code></td><td align="center">S</td><td align="center">D</td><td align="center"><a class="xref" href="#grid-mappings-and-projections" title="5.6. Grid Mappings and ProjectionsHorizontal Coordinate Reference Systems, Grid Mappings, and Projections">Section 5.6, &#8220;<font style="background-color:#ffff88; text-decoration:line-through">Grid Mappings and
    Projections</font><font style="background-color:#ffccff">Horizontal Coordinate
    Reference Systems, Grid Mappings, and Projections</font>&#8221;</a></td><td align="left">Identifies a variable that defines a grid mapping.</td></tr><tr><td align="left"><code class="varname">history</code></td><td align="center">S</td><td align="center">G</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">List of the applications that have modified the original
            data.</td></tr><tr><td align="left"><font style="background-color:#ffccff"><code class="varname">instance_dimension</code></font></td><td align="center"><font style="background-color:#ffccff">N</font></td><td align="center"><font style="background-color:#ffccff">D</font></td><td align="center"><font style="background-color:#ffccff"><a class="xref" href="#representations-features" title="9.3. Representations of collections of features in data variables">Section 9.3, &#8220;Representations of collections of features in data variables&#8221;</a></font></td><td align="left"><font style="background-color:#ffccff">An attribute which identifies an
            index variable and names the instance dimension to which it
            applies. The index variable indicates that the indexed ragged
            array representation is being used for a collection of
            features.</font></td></tr><tr><td align="left"><code class="varname">institution</code></td><td align="center">S</td><td align="center">G, D</td><td align="center"><a class="xref" href="#description-of-file-contents" title="2.6.2. Description of file contents">Section 2.6.2, &#8220;Description of file contents&#8221;</a></td><td align="left">Where the original data was produced.</td></tr><tr><td align="left"><code class="varname">leap_month</code></td><td align="center">N</td><td align="center">C</td><td align="center"><a class="xref" href="#calendar" title="4.4.1. Calendar">Section 4.4.1, &#8220;Calendar&#8221;</a></td><td align="left">Specifies which month is lengthened by a day in leap years
            for a user defined calendar.</td></tr><tr><td align="left"><code class="varname">leap_year</code></td><td align="center">N</td><td align="center">C</td><td align="center"><a class="xref" href="#calendar" title="4.4.1. Calendar">Section 4.4.1, &#8220;Calendar&#8221;</a></td><td align="left">Provides an example of a leap year for a user defined
            calendar. It is assumed that all years that differ from this year
            by a multiple of four are also leap years.</td></tr><tr><td align="left"><code class="varname">long_name</code></td><td align="center">S</td><td align="center">C, D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font> , <a class="xref" href="#long-name" title="3.2. Long Name">Section 3.2, &#8220;Long Name&#8221;</a></td><td align="left">A descriptive name that indicates a variable"s content.
            This name is not standardized.</td></tr><tr><td align="left"><code class="varname">missing_value</code></td><td align="center">D</td><td align="center"><font style="background-color:#ffccff">C,
            </font>D</td><td align="center"><a class="xref" href="#missing-data" title="2.5.1. Missing Data, valid and actual range">Section 2.5.1, &#8220;Missing Data<font style="background-color:#ffccff">, valid and actual
      range</font>&#8221;</a></td><td align="left">A value used to represent missing or undefined data
            (deprecated by the NUG).<font style="background-color:#ffccff"> Not allowed for
            coordinate data except in the case of auxiliary coordinate
            variables in discrete sampling geometries.</font></td></tr><tr><td align="left"><code class="varname">month_lengths</code></td><td align="center">N</td><td align="center">C</td><td align="center"><a class="xref" href="#calendar" title="4.4.1. Calendar">Section 4.4.1, &#8220;Calendar&#8221;</a></td><td align="left">Specifies the length of each month in a non-leap year for a
            user defined calendar.</td></tr><tr><td align="left"><code class="varname">positive</code></td><td align="center">S</td><td align="center">C</td><td align="center">[<span class="citation"><a class="link" href="#coards" title="Conventions for the standardization of NetCDF Files">COARDS</a></span>]</td><td align="left">Direction of increasing vertical coordinate value.</td></tr><tr><td align="left"><code class="varname">references</code></td><td align="center">S</td><td align="center">G, D</td><td align="center"><a class="xref" href="#description-of-file-contents" title="2.6.2. Description of file contents">Section 2.6.2, &#8220;Description of file contents&#8221;</a></td><td align="left">References that describe the data or methods used to
            produce it.</td></tr><tr><td align="left"><font style="background-color:#ffccff"><code class="varname">sample_dimension</code></font></td><td align="center"><font style="background-color:#ffccff">N</font></td><td align="center"><font style="background-color:#ffccff">D</font></td><td align="center"><font style="background-color:#ffccff"> <a class="xref" href="#representations-features" title="9.3. Representations of collections of features in data variables">Section 9.3, &#8220;Representations of collections of features in data variables&#8221;</a></font></td><td align="left"><font style="background-color:#ffccff">An attribute which identifies a
            count variable and names the sample dimension to which it applies.
            The count variable indicates that the contiguous ragged array
            representation is being used for a collection of
            features.</font></td></tr><tr><td align="left"><code class="varname">scale_factor</code></td><td align="center">N</td><td align="center">D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font> , <a class="xref" href="#packed-data" title="8.1. Packed Data">Section 8.1, &#8220;Packed Data&#8221;</a></td><td align="left">If present for a variable, the data are to be multiplied by
            this factor after the data are read by an application See also the
            <code class="varname">add_offset</code> attribute.</td></tr><tr><td align="left"><code class="varname">source</code></td><td align="center">S</td><td align="center">G, D</td><td align="center"><a class="xref" href="#description-of-file-contents" title="2.6.2. Description of file contents">Section 2.6.2, &#8220;Description of file contents&#8221;</a></td><td align="left">Method of production of the original data.</td></tr><tr><td align="left"><code class="varname">standard_error_multiplier</code></td><td align="center">N</td><td align="center">D</td><td align="center"><a class="xref" href="#standard-name-modifiers" title="Appendix C. Standard Name Modifiers">Appendix C, <i>Standard Name Modifiers</i></a></td><td align="left">If a data variable with a standard_name modifier of
            standard_error has this attribute, it indicates that the values
            are the stated multiple of one standard error.</td></tr><tr><td align="left"><code class="varname">standard_name</code></td><td align="center">S</td><td align="center">C, D</td><td align="center"><a class="xref" href="#standard-name" title="3.3. Standard Name">Section 3.3, &#8220;Standard Name&#8221;</a></td><td align="left">A standard name that references a description of a
            variable"s content in the standard name table.</td></tr><tr><td align="left"><code class="varname">title</code></td><td align="center">S</td><td align="center">G</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">Short description of the file contents.</td></tr><tr><td align="left"><code class="varname">units</code></td><td align="center">S</td><td align="center">C, D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font> , <a class="xref" href="#units" title="3.1. Units">Section 3.1, &#8220;Units&#8221;</a></td><td align="left">Units of a variable"s content.</td></tr><tr><td align="left"><code class="varname">valid_max</code></td><td align="center">N</td><td align="center">C, D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">Largest valid value of a variable.</td></tr><tr><td align="left"><code class="varname">valid_min</code></td><td align="center">N</td><td align="center">C, D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">Smallest valid value of a variable.</td></tr><tr><td align="left"><code class="varname">valid_range</code></td><td align="center">N</td><td align="center">C, D</td><td align="center"><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/guidef-13.html#HEADING13-12" target="_top">NUG
            (8.1)</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html#Attribute-Conventions" target="_top">NUG
            (8.1)</a></font></td><td align="left">Smallest and largest valid values of a variable.</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="standard-name-table-format"></a>Appendix B. Standard Name Table Format</h2></div></div></div><p>
	The CF standard name table is an XML document (i.e., its format
	adheres to the XML 1.0 
	[<a href="#xml" class="biblioref" title="[XML]"><abbr class="abbrev">XML</abbr></a>] recommendation). The XML suite
	of protocols provides a reasonable balance between human and
	machine readability. It also provides extensive support for
	internationalization. See the W3C [<a href="#w3c" class="biblioref" title="[W3C]"><abbr class="abbrev">W3C</abbr></a>] home page for more
	information.
  </p><p>
	The document begins with a header that identifies it as an XML file:

	</p><pre class="programlisting">
	 	
  &lt;?xml version="1.0"?&gt;
			 
	</pre><p>

	Next is the <code class="varname">standard_name_table</code> itself, which is bracketed by the tags
    <code class="varname"><code class="sgmltag-element">&lt;standard_name_table&gt;</code></code> and <code class="varname"><code class="sgmltag-element">&lt;/standard_name_table&gt;</code></code>.

	</p><pre class="programlisting">
	 	
  &lt;standard_name_table 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     xsi:noNamespaceSchemaLocation="CFStandardNameTable.xsd"&gt;
			 
	 </pre><p>

  </p><p>
	The content (delimited by the <code class="sgmltag-element">&lt;standard_name_table&gt;</code> tags) 
	 consists of, in order,

	 </p><pre class="programlisting">
	 	
  &lt;institution&gt;Name of institution here ... &lt;/institution&gt;
  &lt;contact&gt;E-mail address of contact person ... &lt;/contact&gt;
			 
	 </pre><p>

	 followed by a sequence of <code class="varname">entry</code> elements which may optionally
	 be followed by a sequence of <code class="varname">alias</code> elements.
     The <code class="varname">entry</code> and
	 <code class="varname">alias</code> elements take the following forms:
	 </p><pre class="programlisting">
	 	
  &lt;entry id="an_id"&gt;
      Define the variable whose standard_name attribute has the value "an_id".  
  &lt;/entry&gt;
  &lt;alias id="another_id"&gt;
      Provide alias for a variable whose standard_name attribute has the
        value "another_id".
  &lt;/alias&gt;
			 
	 </pre><p>


  </p><p>
	The value of the <code class="varname">id</code> attribute appearing in the
    <code class="varname">entry</code> and <code class="varname">alias</code>
	tags is a case sensitive string, containing no whitespace,
	which uniquely identifies the entry relative to the table. 
	<span class="emphasis"><em>This is the value used for a variable's <code class="varname">standard_name</code> attribute.</em></span>
  </p><p>
		The purpose of the <code class="varname">entry</code> elements are to provide
		definitions for the <code class="varname">id</code> strings. Each <code class="varname">entry</code> element
		contains the following elements:
		</p><pre class="programlisting">
			
  &lt;entry id="an_id"&gt;
    &lt;canonical_units&gt;Representative units for the variable ... &lt;/canonical_units&gt;
    &lt;description&gt;Description of the variable ... &lt;/description&gt;
  &lt;/entry&gt;
			
		</pre><p>

		<code class="varname">Entry</code> elements may optionally also contain the following elements:
		</p><pre class="programlisting">
			
  &lt;grib&gt;GRIB parameter code&lt;/grib&gt;
  &lt;amip&gt;AMIP identifier string&lt;/amip&gt;

			
		</pre><p>
	</p><p>
		Not all variables have equivalent AMIP or GRIB
		codes. ECMWF GRIB codes start with <code class="varname">E</code>, NCEP codes
		with <code class="varname">N</code>. Standard codes (in the range 1-127) are not
		prefaced. When a variable has more than one equivalent
		GRIB code, the alternatives are given as a blank-separated
		list.
	</p><p>
		The <code class="varname">alias</code> elements do not contain definitions.
        Rather they
		contain the value of the <code class="varname">id</code> attribute
        of an <code class="varname">entry</code> element
		that contains the sought after definition. The purpose of
		the <code class="varname">alias</code> elements are to provide a means for maintaining
		the table in a backwards compatible fashion. For example,
		if more than one <code class="varname">id</code> string was found to correspond to
		identical definitions, then the redundant definitions
		can be converted into aliases. It is not intended that
		the <code class="varname">alias</code> elements be used to accommodate the use of
		local naming conventions in the 
		<code class="varname">standard_name</code>
		attribute
		strings. Each <code class="varname">alias</code> element contains a single element:
		</p><pre class="programlisting">
			
  &lt;alias id="an_id"&gt;
    &lt;entry_id&gt;Identifier of the defining entry ... &lt;/entry_id&gt;
  &lt;/alias&gt;
			
		</pre><p>
	</p><p>
		</p><div class="example"><a name="idp8526064"></a><p class="title"><b>Example B.1. A name table containing three entries</b></p><div class="example-contents"><p>
				</p><pre class="programlisting">
					
  &lt;?xml version="1.0"?&gt;
  &lt;standard_name_table&gt;
    &lt;institution&gt;Program for Climate Model Diagnosis and Intercomparison&lt;/institution&gt;
    &lt;contact&gt;support@pcmdi.llnl.gov&lt;/contact&gt;
    &lt;entry id="surface_air_pressure"&gt;
      &lt;canonical_units&gt;Pa&lt;/canonical_units&gt;
      &lt;grib&gt;E134&lt;/grib&gt;
      &lt;amip&gt;ps&lt;/amip&gt;
      &lt;description&gt;
          The surface called "surface" means the lower boundary of the atmosphere.  
      &lt;/description&gt;
    &lt;/entry&gt;
    &lt;entry id="air_pressure_at_sea_level"&gt;
      &lt;canonical_units&gt;Pa&lt;/canonical_units&gt;
      &lt;grib&gt;2 E151&lt;/grib&gt;
      &lt;amip&gt;psl&lt;/amip&gt;
      &lt;description&gt;
          Air pressure at sea level is the quantity often abbreviated 
          as MSLP or PMSL. sea_level means mean sea level, which is close 
          to the geoid in sea areas.  
      &lt;/description&gt;
    &lt;/entry&gt;
    &lt;alias id="mean_sea_level_pressure"&gt;
      &lt;entry_id&gt;air_pressure_at_sea_level&lt;/entry_id&gt;
    &lt;/alias&gt;
  &lt;/standard_name_table&gt;
					
				</pre><p>
			</p></div></div><p><br class="example-break">
	</p><p>
			The definition of a variable with the <code class="varname">standard_name</code>
			attribute <code class="varname">surface_air_pressure</code> is found directly since
			the element with <code class="varname">id="surface_air_pressure"</code> is an
            <code class="varname">entry</code> element which contains the definition.
	</p><p>
		The definition of a variable with the
		<code class="varname">standard_name</code> attribute
		<code class="constant">mean_sea_level_pressure</code>
		is found indirectly by first finding the element with the
		<code class="varname">id="mean_sea_level_pressure"</code>,
		and then, since this is an alias element, by searching for the element with
		<code class="varname">id="air_pressure_at_sea_level"</code> as indicated
        by the value of the <code class="varname">entry_id</code> tag.
	</p><p>
		It is possible that new tags may be added in the
		future. Any applications that parse the standard table
		should be written so that unrecognized tags are gracefully
		ignored.
	</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="standard-name-modifiers"></a>Appendix C. Standard Name Modifiers</h2></div></div></div><p>
    In the <span class="emphasis"><em>Units</em></span> column, <em class="parameter"><code>u</code></em> indicates units dimensionally equivalent to those for the unmodified standard name.
    </p><div class="table"><a name="idp8538784"></a><p class="title"><b>Table C.1. Standard Name Modifiers</b></p><div class="table-contents"><table summary="Standard Name Modifiers" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Modifier</th><th align="left">Units</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code class="constant">detection_minimum</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">The smallest data value which is regarded as a detectable signal.</td></tr><tr><td align="left"><code class="constant">number_of_observations</code></td><td align="left">1</td><td align="left">The number of discrete observations or measurements from which a data value has been derived.</td></tr><tr><td align="left"><code class="constant">standard_error</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">The uncertainty of the data value. The standard error includes both systematic and statistical uncertainty. By default it is assumed that the values supplied are for one standard error. If the values supplied are for some multiple of the standard error, the <code class="constant">standard_error</code> ancillary variable should have an attribute <code class="varname">standard_error_multiplier</code> stating the multiplication factor.</td></tr><tr><td align="left"><code class="constant">status_flag</code></td><td align="left"> </td><td align="left">Flag values indicating the quality or other status of the data values. The variable 
                should have <code class="varname">flag_values</code> <font style="background-color:#ffccff">or 
                <code class="varname">flag_masks</code> (or both)</font> and <code class="varname">flag_meanings</code> 
                attributes to show how it should be interpreted (<a class="xref" href="#flags" title="3.5. Flags">Section 3.5, &#8220;Flags&#8221;</a>).</td></tr></tbody></table></div></div><p><br class="table-break">
  </p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dimensionless-v-coord"></a>Appendix D. Dimensionless Vertical Coordinates</h2></div></div></div><p>
        The definitions given here allow an application to compute
        dimensional coordinate values from the dimensionless
        ones and associated variables. The formulas are
        expressed for a gridpoint 
        <code class="varname">(n,k,j,i)</code> 
        where <code class="varname">i</code> and <code class="varname">j</code> are
        the horizontal indices, <code class="varname">k</code> is the vertical
        index and <code class="varname">n</code>
        is the time index. A coordinate variable is associated
        with its definition by the value of the 
        <code class="varname">standard_name</code>
        attribute. The terms in the definition are associated
        with file variables by the 
        <code class="varname">formula_terms</code> 
        attribute. The
        <code class="varname">formula_terms</code>
        attribute takes a string value, the string
        being comprised of blank-separated elements of the form
        "<code class="varname">term: variable</code>", where
        <code class="varname">term</code> is a keyword that represents
        one of the terms in the definition, and
        <code class="varname">variable</code> is the
        name of the variable in a netCDF file that contains
        the values for that term. The order of elements is
        not significant.
    </p><p>
        The gridpoint indices are not formally part of the
        definitions, but are included to illustrate the indices
        that <span class="emphasis"><em>might</em></span> be present in the file variables. For example,
        a vertical coordinate whose definition contains a time
        index is not necessarily time dependent in all netCDF
        files. Also, the definitions are given in general forms
        that may be simplified by omitting certain terms. A term
        that is omitted from the 
        <code class="varname">formula_terms</code>
        attribute should
        be assumed to be zero.
    </p><p>
    </p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="atmosphere-natural-log-pressure-coordinate"></a> Atmosphere natural log pressure coordinate </h2></div></div></div><p>
                </p><pre class="programlisting">
<code class="varname">standard_name</code> = "atmosphere_ln_pressure_coordinate"
                </pre><p>
            </p><p>
              </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
p(k) = p0 * exp(-lev(k))
                     </pre></dd></dl></div><p>

             where <code class="varname">p(k)</code> is the pressure
             at gridpoint <code class="varname">(k)</code>, <code class="varname">p0</code>
             is a reference pressure, <code class="varname">lev(k)</code>
             is the dimensionless coordinate
             at vertical gridpoint <code class="varname">(k)</code>.
            </p><p>
              The format for the <code class="varname">formula_terms</code> attribute is 
              </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "p0: var1 lev: var2"
              </pre><p>
            </p></div><p>
    </p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8633840"></a> Atmosphere sigma coordinate </h2></div></div></div><p>
                </p><pre class="programlisting">
<code class="varname">standard_name</code> = "atmosphere_sigma_coordinate"
                </pre><p>
            </p><p>
              </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
p(n,k,j,i) = ptop + sigma(k)*(ps(n,j,i)-ptop)
                     </pre></dd></dl></div><p>

              where <code class="varname">p(n,k,j,i)</code> is the
              pressure at gridpoint <code class="varname">(n,k,j,i)</code>,
              <code class="varname">ptop</code> is the pressure
              at the top of the model, <code class="varname">sigma(k)</code>
              is the dimensionless coordinate at vertical gridpoint
              <code class="varname">(k)</code>, and <code class="varname">ps(n,j,i)</code>
              is the surface pressure at horizontal
              gridpoint <code class="varname">(j,i)</code> and time <code class="varname">(n)</code>.
            </p><p>
              The format for the formula_terms attribute is 
              </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "sigma: var1 ps: var2 ptop: var3"
              </pre><p>
            </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8644240"></a> Atmosphere hybrid sigma pressure coordinate </h2></div></div></div><p>
                </p><pre class="programlisting">
<code class="varname">standard_name</code> = "atmosphere_hybrid_sigma_pressure_coordinate"
                </pre><p>
            </p><p>
              </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
p(n,k,j,i) = a(k)*p0 + b(k)*ps(n,j,i)
                     </pre><p> or </p><pre class="programlisting">
p(n,k,j,i) = ap(k) + b(k)*ps(n,j,i)
                     </pre></dd></dl></div><p>

              where 
              <code class="computeroutput">p(n,k,j,i)</code>
              is the pressure at gridpoint
              <code class="computeroutput">(n,k,j,i)</code>,
              <code class="computeroutput">a(k)</code>
              or 
              <code class="computeroutput">ap(k)</code>
              and 
              <code class="computeroutput">b(k)</code>
              are components of the hybrid coordinate at
              level 
              <code class="computeroutput">k</code>,
              <code class="computeroutput">p0</code> 
              is a reference
              pressure, and 
              <code class="computeroutput">ps(n,j,i)</code>
              is the surface pressure at horizontal gridpoint
              <code class="computeroutput">(j,i)</code> 
              and time
              <code class="computeroutput">(n)</code>. 
              The choice of whether 
              <code class="computeroutput">a(k)</code> 
              or
              <code class="computeroutput">ap(k)</code> 
              is used depends on
              model formulation; the former is a dimensionless fraction,
              the latter a pressure value. In both formulations,
              <code class="computeroutput">b(k)</code> 
              is a dimensionless
              fraction.
            </p><p>
              The format for the <code class="varname">formula_terms</code> attribute is
              </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "a: var1 b: var2 ps: var3 p0: var4" 
              </pre><p>
              where 
              <code class="computeroutput">a</code> 
              is replaced by 
              <code class="computeroutput">ap</code> 
              if appropriate. 
            </p><p>
              The hybrid sigma-pressure coordinate for level <code class="varname">k</code> is defined as 
              <code class="computeroutput">a(k)+b(k)</code> 
              or 
              <code class="computeroutput">ap(k)/p0+b(k)</code>, 
              as appropriate.
            </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="atmosphere-hybrid-height-coordinate"></a> Atmosphere hybrid height coordinate </h2></div></div></div><p>
        </p><pre class="programlisting">
<code class="varname">standard_name</code> = "atmosphere_hybrid_height_coordinate"
        </pre><p>
      </p><p>
        </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
z(n,k,j,i) = a(k) + b(k)*orog(n,j,i)
              </pre></dd></dl></div><p>

        where 
        <code class="varname">z(n,k,j,i)</code>
        is the height above the geoid (approximately mean sea level) at gridpoint 
        <code class="varname">(k,j,i)</code>
        and 
        <code class="varname">time (n)</code>, 
        <code class="varname">orog(n,j,i)</code>
        is the height of the surface above 
        the geoid at
        <code class="varname">(j,i)</code> 
        and 
        <code class="varname">time (n)</code>, 
        and <code class="varname">a(k)</code> and <code class="varname">b(k)</code>
        are the coordinates
        which define hybrid height level 
        <code class="varname">k</code>.
        <code class="varname">a(k)</code> has the dimensions of height and
        <code class="varname">b(i)</code> is dimensionless.
      </p><p>
        The format for the 
        <code class="varname">formula_terms</code> 
        attribute is 
        </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "a: var1 b: var2 orog: var3"
        </pre><p>
      </p><p>
        There is no dimensionless hybrid height coordinate. The hybrid
        height is best approximated as <code class="varname">a(k)</code>
        if a level-dependent constant is needed.
      </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8679888"></a> Atmosphere smooth level vertical (SLEVE) coordinate </h2></div></div></div><p>
        </p><pre class="programlisting">
<code class="varname">standard_name</code> = "atmosphere_sleve_coordinate"
        </pre><p>
      </p><p>
        </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
z(n,k,j,i) = a(k)*ztop + b1(k)*zsurf1(n,j,i) + b2(k)*zsurf2(n,j,i)
              </pre></dd></dl></div><p>

        where 
        <code class="varname">z(n,k,j,i)</code>
        is the height above the geoid (approximately mean sea level) at gridpoint 
        <code class="varname">(k,j,i)</code>
        and time
        <code class="varname">(n)</code>, 
        <code class="varname">ztop</code> 
        is the height of the top of the model, and
        <code class="varname">a(k)</code>,
        <code class="varname">b1(k)</code>,
        and
        <code class="varname">b2(k)</code>
        are the dimensionless coordinates which define hybrid level
        <code class="varname">k</code>.
        <code class="varname">zsurf1(n,j,i)</code>
        and 
        <code class="varname">zsurf2(n,j,i)</code>
        are respectively the large and small parts of the topography.  See Shaer et al
        [<a href="#sch02" class="biblioref" title="[SCH02]"><abbr class="abbrev">SCH02</abbr></a>]
        for details.
      </p><p>
        The format for the 
        <code class="varname">formula_terms</code> 
        attribute is 
        </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "a: var1 b1: var2 b2: var3 ztop: var4 zsurf1: var5
                zsurf2: var6"
        </pre><p>
      </p><p>
        The hybrid height coordinate for level 
        <code class="varname">k</code> is defined as
        <code class="varname">a(k)*ztop</code>.
      </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8693904"></a> Ocean sigma coordinate </h2></div></div></div><p>
        </p><pre class="programlisting">
<code class="varname">standard_name</code> = "ocean_sigma_coordinate"
        </pre><p>
      </p><p>
        </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
z(n,k,j,i) = eta(n,j,i) + sigma(k)*(depth(j,i)+eta(n,j,i))
              </pre></dd></dl></div><p>

        where <code class="varname">z(n,k,j,i)</code> is height, positive upwards, relative to
        ocean datum (e.g. mean sea level) at gridpoint <code class="varname">(n,k,j,i)</code>,
        <code class="varname">eta(n,j,i)</code> is the height of the ocean surface, positive upwards,
        relative to ocean datum at gridpoint <code class="varname">(n,j,i)</code>,
        <code class="varname">sigma(k)</code> is the
        dimensionless coordinate at vertical gridpoint <code class="varname">(k)</code>,
        and <code class="varname">depth(j,i)</code>
        is the distance from ocean datum to sea floor (positive value)
        at horizontal gridpoint <code class="varname">(j,i)</code>.
      </p><p>
        The format for the 
        <code class="varname">formula_terms</code> 
        attribute is 
        </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "sigma: var1 eta: var2 depth: var3"
        </pre><p>
      </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8704896"></a> Ocean s-coordinate </h2></div></div></div><p>
        </p><pre class="programlisting">
<code class="varname">standard_name</code> = "ocean_s_coordinate"
        </pre><p>
      </p><p>
        </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
z(n,k,j,i) = eta(n,j,i)*(1+s(k)) + depth_c*s(k) +
             (depth(j,i)-depth_c)*C(k)

<font style="background-color:#ffccff">where</font>  C(k) = (1-b)*sinh(a*s(k))/sinh(a) + 
         b*[tanh(a*(s(k)+0.5))/(2*tanh(0.5*a)) - 0.5]
              </pre></dd></dl></div><p>

        where <code class="varname">z(n,k,j,i)</code> is height, positive upwards, relative to ocean
        datum (e.g. mean sea level) at gridpoint <code class="varname">(n,k,j,i)</code>,
        <code class="varname">eta(n,j,i)</code> is
        the height of the ocean surface, positive upwards, relative to
        ocean datum at gridpoint <code class="varname">(n,j,i)</code>, <code class="varname">s(k)</code> is the dimensionless
        coordinate at vertical gridpoint <code class="varname">(k)</code>, and <code class="varname">depth(j,i)</code> is the distance
        from ocean datum to sea floor (positive value) at horizontal
        gridpoint <code class="varname">(j,i)</code>. The constants
        <code class="varname">a</code>, <code class="varname">b</code>, and <code class="varname">depth_c</code> control the stretching.
      </p><p>
        The format for the 
        <code class="varname">formula_terms</code> 
        attribute is 
        </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "s: var1 eta: var2 depth: var3 a: var4 b: var5 depth_c: var6"
        </pre><p>
      </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8718000"></a> Ocean s-coordinate, generic form 1 </h2></div></div></div><p>
          </p><pre class="programlisting">
<code class="varname">standard_name</code> = "ocean_s_coordinate_g1"
        </pre><p>
        </p><p>
          </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
z(n,k,j,i) = S(k,j,i) + eta(n,j,i) * (1 + S(k,j,i) / depth(j,i))

<font style="background-color:#ffccff">where</font>  S(k,j,i) = depth_c * s(k) + (depth(j,i) - depth_c) * C(k)
              </pre></dd></dl></div><p>
          
          where <code class="varname">z(n,k,j,i)</code> is height, positive upwards, relative to ocean
          datum (e.g. mean sea level) at gridpoint <code class="varname">(n,k,j,i)</code>,
          <code class="varname">eta(n,j,i)</code> is
          the height of the ocean surface, positive upwards, relative to
          ocean datum at gridpoint <code class="varname">(n,j,i)</code>, 
          <code class="varname">s(k)</code> is the dimensionless coordinate at vertical gridpoint 
          <code class="varname">(k)</code> with a range of <code class="varname"> -1 &lt;= s(k) &lt;= 0 </code>, 
          <code class="varname">s(0)</code> corresponds to <code class="varname">eta(n,j,i)</code> whereas <code class="varname">s(-1)</code> corresponds to <code class="varname">depth(j,i)</code>; 
          <code class="varname">C(k)</code> is the dimensionless vertical coordinate stretching function at gridpoint <code class="varname">(k)</code> with a range of 
          <code class="varname">-1 &lt;= C(k) &lt;= 0</code>, <code class="varname">C(0)</code> corresponds to <code class="varname">eta(n,j,i)</code> whereas <code class="varname">C(-1)</code> 
          corresponds to <code class="varname">depth(j,i)</code>; the constant <code class="varname">depth_c</code>, (positive value), 
          is a critical depth controlling the stretching and <code class="varname">depth(j,i)</code> is the distance
          from ocean datum to sea floor (positive value) at horizontal
          gridpoint <code class="varname">(j,i)</code>. 
        </p><p>
          The format for the 
          <code class="varname">formula_terms</code> 
          attribute is 
          </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "s: var1 C: var2 eta: var3 depth: var4 depth_c: var5"
        </pre><p>
        </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8735776"></a> Ocean s-coordinate, generic form 2 </h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">standard_name</code> = "ocean_s_coordinate_g2"
        </pre><p>
    </p><p>
      </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
z(n,k,j,i) = eta(n,j,i) + (eta(n,j,i) + depth(j,i)) * S(k,j,i)

<font style="background-color:#ffccff">where</font>  S(k,j,i) = (depth_c * s(k) + depth(j,i) * C(k)) / (depth_c + depth(j,i))
              </pre></dd></dl></div><p>
      
      where <code class="varname">z(n,k,j,i)</code> is height, positive upwards, relative to ocean
      datum (e.g. mean sea level) at gridpoint <code class="varname">(n,k,j,i)</code>,
      <code class="varname">eta(n,j,i)</code> is
      the height of the ocean surface, positive upwards, relative to
      ocean datum at gridpoint <code class="varname">(n,j,i)</code>, 
      <code class="varname">s(k)</code> is the dimensionless coordinate at vertical gridpoint 
      <code class="varname">(k)</code> with a range of <code class="varname"> -1 &lt;= s(k) &lt;= 0 </code>, 
      <code class="varname">s(0)</code> corresponds to <code class="varname">eta(n,j,i)</code> whereas <code class="varname">s(-1)</code> corresponds to <code class="varname">depth(j,i)</code>; 
      <code class="varname">C(k)</code> is the dimensionless vertical coordinate stretching function at gridpoint <code class="varname">(k)</code> with a range of 
      <code class="varname">-1 &lt;= C(k) &lt;= 0</code>, <code class="varname">C(0)</code> corresponds to <code class="varname">eta(n,j,i)</code> whereas <code class="varname">C(-1)</code> 
      corresponds to <code class="varname">depth(j,i)</code>; the constant <code class="varname">depth_c</code>, (positive value), 
      is a critical depth controlling the stretching and <code class="varname">depth(j,i)</code> is the distance
      from ocean datum to sea floor (positive value) at horizontal
      gridpoint <code class="varname">(j,i)</code>. 
    </p><p>
      The format for the 
      <code class="varname">formula_terms</code> 
      attribute is 
      </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "s: var1 C: var2 eta: var3 depth: var4 depth_c: var5"
        </pre><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8753504"></a> Ocean sigma over z coordinate </h2></div></div></div><p>
        </p><pre class="programlisting">
<code class="varname">standard_name</code> = "ocean_sigma_z_coordinate"
        </pre><p>
      </p><p>
        </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
for k &lt;= nsigma:

  z(n,k,j,i) = eta(n,j,i) + sigma(k)*(min(depth_c,depth(j,i))+eta(n,j,i))
 
for k &gt; nsigma:

  z(n,k,j,i) = zlev(k)
              </pre></dd></dl></div><p>

        where <code class="varname">z(n,k,j,i)</code> is height, positive upwards, relative to ocean
        datum (e.g. mean sea level) at gridpoint <code class="varname">(n,k,j,i)</code>,
        <code class="varname">eta(n,j,i)</code>
        is the height of the ocean surface, positive upwards, relative
        to ocean datum at gridpoint <code class="varname">(n,j,i)</code>,
        <code class="varname">sigma(k)</code> is the dimensionless
        coordinate at vertical gridpoint <code class="varname">(k)</code> for
        <code class="varname">k &lt;= nsigma</code>,
        and <code class="varname">depth(j,i)</code> is the distance from ocean datum to
        sea floor (positive value) at horizontal gridpoint <code class="varname">(j,i)</code>.
        Above depth <code class="varname">depth_c</code> there are <code class="varname">nsigma</code> layers.
      </p><p>
        The format for the 
        <code class="varname">formula_terms</code> 
        attribute is 
        </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "sigma: var1 eta: var2 depth: var3 depth_c: var4 nsigma: var5
                zlev: var6"
        </pre><p>
      </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8766048"></a> Ocean double sigma coordinate </h2></div></div></div><p>
        </p><pre class="programlisting">
<code class="varname">standard_name</code> = "ocean_double_sigma_coordinate"
        </pre><p>
      </p><p>
        </p><div class="variablelist"><dl><dt><span class="term"> Definition: </span></dt><dd><pre class="programlisting">
for k &lt;= k_c<font style="background-color:#ffccff">:</font>

  z(k,j,i)= sigma(k)*f(j,i)

for k &gt; k_c<font style="background-color:#ffccff">:</font>

  z(k,j,i)= f(j,i) + (sigma(k)-1)*(depth(j,i)-f(j,i))

f(j,i)= 0.5*(z1+ z2) + 0.5*(z1-z2)* tanh(2*a/(z1-z2)*(depth(j,i)-href))
              </pre></dd></dl></div><p>

        where <code class="varname">z(k,j,i)</code> is height, positive upwards, relative to ocean
        datum (e.g. mean sea level) at gridpoint <code class="varname">(k,j,i)</code>,
        <code class="varname">sigma(k)</code> is the dimensionless coordinate at vertical
        gridpoint <code class="varname">(k)</code> for <code class="varname">k &lt;= k_c</code>,
        and <code class="varname">depth(j,i)</code> is the distance
        from ocean datum to sea floor (positive value) at horizontal
        gridpoint <code class="varname">(j,i)</code>.
        <code class="constant">z1</code>, <code class="constant">z2</code>, <code class="constant">a</code>, and <code class="constant">href</code> are constants.
      </p><p>
        The format for the 
        <code class="varname">formula_terms</code> 
        attribute is 
        </p><pre class="programlisting">
<code class="varname">formula_terms</code> = "sigma: var1 depth: var2 z1: var3 z2: var4 a: var5 href: var6
                k_c: var7"
        </pre><p>
      </p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-cell-methods"></a>Appendix E. Cell Methods</h2></div></div></div><p>In the <span class="emphasis"><em>Units</em></span> column, <em class="parameter"><code>u</code></em>
  indicates the units of the physical quantity before the method is applied.
  </p><div class="table"><a name="idp8920288"></a><p class="title"><b>Table E.1. Cell Methods</b></p><div class="table-contents"><table summary="Cell Methods" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left"><font style="background-color:#ffff88; text-decoration:line-through"><code class="varname">cell_method</code></font>
            <font style="background-color:#ffccff"><code class="varname">cell_methods</code></font></th><th align="left">Units</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code class="constant">point</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">The data values are representative of points in space or
            time (instantaneous). This is the default method for a quantity
            that is intensive with respect to the specified dimension.</td></tr><tr><td align="left"><code class="constant">sum</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">The data values are representative of a sum or accumulation
            over the cell. This is the default method for a quantity that is
            extensive with respect to the specified dimension.</td></tr><tr><td align="left"><code class="constant">maximum</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Maximum</td></tr><tr><td align="left"><code class="constant">median</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Median</td></tr><tr><td align="left"><code class="constant">mid_range</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Average of maximum and minimum</td></tr><tr><td align="left"><code class="constant">minimum</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Minimum</td></tr><tr><td align="left"><code class="constant">mean</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Mean (average value)</td></tr><tr><td align="left"><code class="constant">mode</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Mode (most common value)</td></tr><tr><td align="left"><font style="background-color:#ffccff">range</font></td><td align="left"><font style="background-color:#ffccff">u</font></td><td align="left"><font style="background-color:#ffccff">Absolute difference between
            maximum and minimum</font></td></tr><tr><td align="left"><code class="constant">standard_deviation</code></td><td align="left"><em class="parameter"><code>u</code></em></td><td align="left">Standard deviation</td></tr><tr><td align="left"><code class="constant">variance</code></td><td align="left"><em class="parameter"><code>u</code></em><sup>2</sup></td><td align="left">Variance</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-grid-mappings"></a>Appendix F. Grid Mappings</h2></div></div></div><p>Each recognized grid mapping is described in one of the sections
  below. Each section contains: the valid name that is used with the
  <code class="varname">grid_mapping_name</code> attribute; a list of the specific
  attributes that may be used to assign values to the mapping's parameters;
  the standard names used to identify the coordinate variables that contain
  the mapping's independent variables; and references to the mapping's
  definition or other information that may help in using the mapping. Since
  the attributes used to set a mapping's parameters may be shared among
  several mappings, their definitions are contained in a table in the final
  section. <font style="background-color:#ffccff">The attributes which describe the
  ellipsoid and prime meridian may be included, when applicable, with any grid
  mapping.</font></p><p>We have used the FGDC "Content Standard for Digital Geospatial
  Metadata" [<a href="#fgdc" class="biblioref" title="[FGDC]"><abbr class="abbrev">FGDC</abbr></a>] as a guide in choosing the values for
  <code class="varname">grid_mapping_name</code> and the attribute names for the
  parameters describing map projections.</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9031760"></a>Albers Equal Area</h2></div></div></div><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = albers_conical_equal_area
        </pre><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>Map parameters:</em></span>
        </span></dt><dd><p>
            </p><div class="itemizedlist"><ul type="disc"><li><p><code class="varname">standard_parallel</code> - There may be 1 or
                2 values.</p></li><li><p>
                  <code class="varname">longitude_of_central_meridian</code>
                </p></li><li><p>
                  <code class="varname">latitude_of_projection_origin</code>
                </p></li><li><p>
                  <code class="varname">false_easting</code>
                </p></li><li><p>
                  <code class="varname">false_northing</code>
                </p></li></ul></div><p>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>Map coordinates:</em></span>
        </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates are
          identified by the <code class="varname">standard_name</code> attribute values
          <code class="varname">projection_x_coordinate</code> and
          <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
          <span class="emphasis"><em>Notes:</em></span>
        </span></dt><dd><p>Notes on using the <code class="varname">PROJ.4</code> software package
          for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/albers_equal_area_conic.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/albers_equal_area_conic.html</a>.</p></dd></dl></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="azimuthal-equidistant"></a>Azimuthal equidistant</h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = azimuthal_equidistant
        </pre><p>

      </p><div class="variablelist"><dl><dt><span class="term">
            <span class="emphasis"><em>Map parameters:</em></span>
          </span></dt><dd><p>
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="varname">longitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">latitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">false_easting</code>
                  </p></li><li><p>
                    <code class="varname">false_northing</code>
                  </p></li></ul></div><p>
            </p></dd><dt><span class="term">
            <span class="emphasis"><em>Map coordinates:</em></span>
          </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates
            are identified by the <code class="varname">standard_name</code> attribute
            values <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
            <span class="emphasis"><em>Notes:</em></span>
          </span></dt><dd><p>Notes on using the <code class="varname">PROJ.4</code> software
            package for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/azimuthal_equidistant.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/azimuthal_equidistant.html</a>.</p></dd></dl></div><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lambert-azimuthal-equal-area"></a>Lambert azimuthal equal area</h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = lambert_azimuthal_equal_area
        </pre><p>

      </p><div class="variablelist"><dl><dt><span class="term">
            <span class="emphasis"><em>Map parameters:</em></span>
          </span></dt><dd><p>
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="varname">longitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">latitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">false_easting</code>
                  </p></li><li><p>
                    <code class="varname">false_northing</code>
                  </p></li></ul></div><p>
            </p></dd><dt><span class="term">
            <span class="emphasis"><em>Map coordinates:</em></span>
          </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates
            are identified by the <code class="varname">standard_name</code> attribute
            values <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
            <span class="emphasis"><em>Notes:</em></span>
          </span></dt><dd><p>Notes on using the <code class="varname">PROJ.4</code> software
            package for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/lambert_azimuthal_equal_area.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/lambert_azimuthal_equal_area.html</a>.</p></dd></dl></div><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9083008"></a>Lambert conformal</h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = lambert_conformal_conic
        </pre><p>

      </p><div class="variablelist"><dl><dt><span class="term">
            <span class="emphasis"><em>Map parameters:</em></span>
          </span></dt><dd><p>
              </p><div class="itemizedlist"><ul type="disc"><li><p><code class="varname">standard_parallel</code> - There may be 1
                  or 2 values.</p></li><li><p>
                    <code class="varname">longitude_of_central_meridian</code>
                  </p></li><li><p>
                    <code class="varname">latitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">false_easting</code>
                  </p></li><li><p>
                    <code class="varname">false_northing</code>
                  </p></li></ul></div><p>
            </p></dd><dt><span class="term">
            <span class="emphasis"><em>Map coordinates:</em></span>
          </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates
            are identified by the <code class="varname">standard_name</code> attribute
            values <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
            <span class="emphasis"><em>Notes:</em></span>
          </span></dt><dd><p>Notes on using the <code class="varname">PROJ.4</code> software
            package for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/lambert_conic_conformal_2sp.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/lambert_conic_conformal_2sp.html</a>.</p></dd></dl></div><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9100656"></a>
      <font style="background-color:#ffccff">Lambert Cylindrical Equal Area</font>
    </h2></div></div></div><pre class="programlisting">
<font style="background-color:#ffccff"><code class="varname">grid_mapping_name</code> = lambert_cylindrical_equal_area</font>
      </pre><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map parameters:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">
              <div class="itemizedlist"><ul type="disc"><li><font style="background-color:#ffccff">
                    <code class="varname">longitude_of_central_meridian</code>
                  </font></li><li><font style="background-color:#ffccff">Either
                  <code class="varname">standard_parallel</code> or
                  <code class="varname">scale_factor_at_projection_origin</code></font></li><li><font style="background-color:#ffccff">
                    <code class="varname">false_easting</code>
                  </font></li><li><font style="background-color:#ffccff">
                    <code class="varname">false_northing</code>
                  </font></li></ul></div>
            </font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map coordinates:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">
              <font style="background-color:#ffccff">The x (abscissa) and y (ordinate)
              rectangular coordinates are identified by the
              <code class="varname">standard_name</code> attribute value
              <code class="varname">projection_x_coordinate</code> and
              <code class="varname">projection_y_coordinate</code>
              respectively.</font>
            </font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Notes:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">Notes on using the PROJ.4 software
            packages for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/cylindrical_equal_area.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/cylindrical_equal_area.html</a>
            ("Lambert Cylindrical Equal Area" or EPSG 9834 or EPSG 9835).
            Detailed formulas can be found in [Snyder] pages 76-85.</font>
          </p></dd></dl></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9123808"></a>
      <font style="background-color:#ffccff">Latitude-Longitude</font>
    </h2></div></div></div><pre class="programlisting">
<font style="background-color:#ffccff"><code class="varname">grid_mapping_name</code> = latitude_longitude</font>
      </pre><p>
      <font style="background-color:#ffccff">This grid mapping defines the canonical 2D
      geographical coordinate system based upon latitude and longitude
      coordinates on a spherical Earth. It is included so that the figure of
      the Earth can be described.</font>
    </p><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map parameters:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">None.</font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map coordinates:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">The rectangular coordinates are longitude
            and latitude identified by the usual conventions (<a class="xref" href="#latitude-coordinate" title="4.1. Latitude Coordinate">Section 4.1, &#8220;Latitude Coordinate&#8221;</a> and <a class="xref" href="#longitude-coordinate" title="4.2. Longitude Coordinate">Section 4.2, &#8220;Longitude Coordinate&#8221;</a>).</font>
          </p></dd></dl></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9136592"></a>
      <font style="background-color:#ffccff">Mercator</font>
    </h2></div></div></div><pre class="programlisting">
<font style="background-color:#ffccff"><code class="varname">grid_mapping_name</code> = mercator</font>
      </pre><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map parameters:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">
              <div class="itemizedlist"><ul type="disc"><li><font style="background-color:#ffccff">
                    <code class="varname">longitude_of_projection_origin</code>
                  </font></li><li><font style="background-color:#ffccff">Either
                  <code class="varname">standard_parallel</code> (EPSG 9805) or
                  <code class="varname">scale_factor_at_projection_origin</code> (EPSG
                  9804)</font></li><li><font style="background-color:#ffccff">
                    <code class="varname">false_easting</code>
                  </font></li><li><font style="background-color:#ffccff">
                    <code class="varname">false_northing</code>
                  </font></li></ul></div>
            </font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map coordinates:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">The x (abscissa) and y (ordinate)
            rectangular coordinates are identified by the
            <code class="varname">standard_name</code> attribute value
            <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code>
            respectively.</font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Notes:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">Notes on using the PROJ.4 software
            packages for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/mercator_1sp.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/mercator_1sp.html</a>
            ("Mercator (1SP)" or EPSG 9804) or <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/mercator_2sp.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/mercator_2sp.html</a>
            ("Mercator (2SP)" or EPSG 9805).</font>
          </p><p>
            <font style="background-color:#ffccff">More information on formulas available in
            [<a href="#ogp-epsg_gn7_2" class="biblioref" title="[OGP/EPSG_GN7_2]"><abbr class="abbrev"><font style="background-color:#ffccff">OGP/EPSG_GN7_2</font></abbr></a>].</font>
          </p></dd></dl></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9161904"></a>
      <font style="background-color:#ffccff">Orthographic</font>
    </h2></div></div></div><pre class="programlisting">
<font style="background-color:#ffccff"><code class="varname">grid_mapping_name</code> = orthographic</font>
      </pre><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map parameters:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">
              <div class="itemizedlist"><ul type="disc"><li><font style="background-color:#ffccff">
                    <code class="varname">longitude_of_projection_origin</code>
                  </font></li><li><font style="background-color:#ffccff">
                    <code class="varname">latitude_of_projection_origin</code>
                  </font></li><li><font style="background-color:#ffccff">
                    <code class="varname">false_easting</code>
                  </font></li><li><font style="background-color:#ffccff">
                    <code class="varname">false_northing</code>
                  </font></li></ul></div>
            </font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map coordinates:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">The x (abscissa) and y (ordinate)
            rectangular coordinates are identified by the
            <code class="varname">standard_name</code> attribute value
            <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code>
            respectively.</font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Notes:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">Notes on using the PROJ.4 software
            packages for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/orthographic.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/orthographic.html</a>
            ("Orthographic" or EPSG 9840).</font>
          </p><p>
            <font style="background-color:#ffccff">More information on formulas available in
            [<a href="#ogp-epsg_gn7_2" class="biblioref" title="[OGP/EPSG_GN7_2]"><abbr class="abbrev"><font style="background-color:#ffccff">OGP/EPSG_GN7_2</font></abbr></a>].</font>
          </p></dd></dl></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="polar-stereographic"></a>Polar stereographic</h2></div></div></div><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = polar_stereographic
      </pre><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>Map parameters:</em></span>
        </span></dt><dd><p>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <code class="varname">straight_vertical_longitude_from_pole</code>
                </p></li><li><p><code class="varname">latitude_of_projection_origin</code> -
                Either +90. or -90.</p></li><li><p>Either <code class="varname">standard_parallel</code> or
                <code class="varname">scale_factor_at_projection_origin</code></p></li><li><p>
                  <code class="varname">false_easting</code>
                </p></li><li><p>
                  <code class="varname">false_northing</code>
                </p></li></ul></div><p>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>Map coordinates:</em></span>
        </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates are
          identified by the <code class="varname">standard_name</code> attribute values
          <code class="varname">projection_x_coordinate</code> and
          <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
          <span class="emphasis"><em>Notes:</em></span>
        </span></dt><dd><p>Notes on using the <code class="varname">PROJ.4</code> software package
          for computing the mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/polar_stereographic.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/polar_stereographic.html</a>.</p></dd></dl></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9203712"></a>Rotated pole</h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = rotated_latitude_longitude
        </pre><p>

      </p><div class="variablelist"><dl><dt><span class="term">
            <span class="emphasis"><em>Map parameters:</em></span>
          </span></dt><dd><p>
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="varname">grid_north_pole_latitude</code>
                  </p></li><li><p>
                    <code class="varname">grid_north_pole_longitude</code>
                  </p></li><li><p><code class="varname">north_pole_grid_longitude</code> - This
                  parameter is option (default is 0).</p></li></ul></div><p>
            </p></dd><dt><span class="term">
            <span class="emphasis"><em>Map coordinates:</em></span>
          </span></dt><dd><p>The rotated latitude and longitude coordinates are
            identified by the <code class="varname">standard_name</code> attribute
            values <code class="varname">grid_latitude</code> and
            <code class="varname">grid_longitude</code> respectively.</p></dd><dt><span class="term">
            <span class="emphasis"><em>Notes:</em></span>
          </span></dt><dd><p></p></dd></dl></div><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9217520"></a>Stereographic</h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = stereographic
        </pre><p>

      </p><div class="variablelist"><dl><dt><span class="term">
            <span class="emphasis"><em>Map parameters:</em></span>
          </span></dt><dd><p>
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="varname">longitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">latitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">scale_factor_at_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">false_easting</code>
                  </p></li><li><p>
                    <code class="varname">false_northing</code>
                  </p></li></ul></div><p>
            </p></dd><dt><span class="term">
            <span class="emphasis"><em>Map coordinates:</em></span>
          </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates
            are identified by the <code class="varname">standard_name</code> attribute
            values <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
            <span class="emphasis"><em>Notes:</em></span>
          </span></dt><dd><p>Formulas for the mapping and its inverse along with notes on
            using the <code class="varname">PROJ.4</code> software package for doing the
            calcuations may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/stereographic.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/stereographic.html</a>.
            See the section "Polar stereographic" for the special case when
            the projection origin is one of the poles.</p></dd></dl></div><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9235424"></a>Transverse Mercator</h2></div></div></div><p>
      </p><pre class="programlisting">
<code class="varname">grid_mapping_name</code> = transverse_mercator
        </pre><p>

      </p><div class="variablelist"><dl><dt><span class="term">
            <span class="emphasis"><em>Map parameters:</em></span>
          </span></dt><dd><p>
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="varname">scale_factor_at_central_meridian</code>
                  </p></li><li><p>
                    <code class="varname">longitude_of_central_meridian</code>
                  </p></li><li><p>
                    <code class="varname">latitude_of_projection_origin</code>
                  </p></li><li><p>
                    <code class="varname">false_easting</code>
                  </p></li><li><p>
                    <code class="varname">false_northing</code>
                  </p></li></ul></div><p>
            </p></dd><dt><span class="term">
            <span class="emphasis"><em>Map coordinates:</em></span>
          </span></dt><dd><p>The x (abscissa) and y (ordinate) rectangular coordinates
            are identified by the <code class="varname">standard_name</code> attribute
            values <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code> respectively.</p></dd><dt><span class="term">
            <span class="emphasis"><em>Notes:</em></span>
          </span></dt><dd><p>Formulas for the mapping and its inverse along with notes on
            using the <code class="varname">PROJ.4</code> software package for doing the
            calcuations may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/transverse_mercator.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/transverse_mercator.html</a>.</p></dd></dl></div><p>
    </p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9253184"></a>
      <font style="background-color:#ffccff">Vertical perspective</font>
    </h2></div></div></div><pre class="programlisting">
<font style="background-color:#ffccff"><code class="varname">grid_mapping_name</code> = vertical_perspective</font>
      </pre><div class="variablelist"><dl><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map parameters:</font>
          </em></span>
        </span></dt><dd><p>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <code class="varname">
                    <font style="background-color:#ffccff">latitude_of_projection_origin</font>
                  </code>
                </p></li><li><p>
                  <code class="varname">
                    <font style="background-color:#ffccff">longitude_of_projection_origin</font>
                  </code>
                </p></li><li><p>
                  <code class="varname">
                    <font style="background-color:#ffccff">perspective_point_height</font>
                  </code>
                </p></li><li><p>
                  <code class="varname">
                    <font style="background-color:#ffccff">false_easting</font>
                  </code>
                </p></li><li><p>
                  <code class="varname">
                    <font style="background-color:#ffccff">false_northing</font>
                  </code>
                </p></li></ul></div><p>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Map coordinates:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">The x (abscissa) and y (ordinate)
            rectangular coordinates are identified by the
            <code class="varname">standard_name</code> attribute value
            <code class="varname">projection_x_coordinate</code> and
            <code class="varname">projection_y_coordinate</code>
            respectively.</font>
          </p></dd><dt><span class="term">
          <span class="emphasis"><em>
            <font style="background-color:#ffccff">Notes:</font>
          </em></span>
        </span></dt><dd><p>
            <font style="background-color:#ffccff">Notes on using the
            <code class="varname">PROJ.4</code> software packages for computing the
            mapping may be found at <a class="ulink" href="http://www.remotesensing.org/geotiff/proj_list/geos.html" target="_top">http://www.remotesensing.org/geotiff/proj_list/geos.html</a>
            . These notes assume the point of perspective is directly over the
            equator. A more general description of vertical perspective
            projection is given in [<a href="#snyder" class="biblioref" title="[Snyder]"><abbr class="abbrev"><font style="background-color:#ffccff">Snyder</font></abbr></a>], pages 169-181.</font>
          </p></dd></dl></div></div><p>
    <font style="background-color:#ffccff">In the following table the "Type" values are
    <span class="bold"><strong>S</strong></span> for string and <span class="bold"><strong>N</strong></span> for numeric.</font>
  </p><div class="table"><a name="idp9281904"></a><p class="title"><b>Table F.1. Grid Mapping Attributes</b></p><div class="table-contents"><table summary="Grid Mapping Attributes" border="1"><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">
            <font style="background-color:#ffccff">Type</font>
          </th><th align="center">Description</th></tr></thead><tbody><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">crs_wkt</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">S</font>
          </td><td align="left">
            <font style="background-color:#ffccff">This optional attribute may be used to
            specify multiple coordinate system properties in well-known text
            (WKT) format. The syntax must conform to the WKT format as
            specified in reference [[<a href="#OGC_CTS" class="biblioref" title="[OGC_CTS]"><abbr class="abbrev"><font style="background-color:#ffccff">OGC_CTS</font></abbr></a>]]. Use of
            the crs_wkt attribute is described in section 5.6.1.</font>
          </td></tr><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">earth_radius</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">
            <font style="background-color:#ffccff">Used to specify the radius, in metres, of
            the spherical figure used to approximate the shape of the Earth.
            This attribute should be specified for those projected coordinate
            reference systems in which the X-Y cartesian coordinates have been
            derived using a spherical Earth approximation. If the cartesian
            coordinates were derived using an ellipsoid, this attribute should
            not be defined. Example: "6371007", which is the radius of the GRS
            1980 Authalic Sphere.</font>
          </td></tr><tr><td align="left">
            <code class="varname">false_easting</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">The value added to all abscissa values in the rectangular
          coordinates for a map projection. This value frequently is assigned
          to eliminate negative numbers. Expressed in the unit of the
          coordinate variable identified by the standard name
          <code class="varname">projection_x_coordinate</code>.</td></tr><tr><td align="left">
            <code class="varname">false_northing</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">The value added to all ordinate values in the rectangular
          coordinates for a map projection. This value frequently is assigned
          to eliminate negative numbers. Expressed in the unit of the
          coordinate variable identified by the standard name
          <code class="varname">projection_y_coordinate</code>.</td></tr><tr><td align="left">
            <code class="varname">grid_mapping_name</code>
          </td><td align="left">
            <font style="background-color:#ffccff">S</font>
          </td><td align="left">The name used to identify the grid mapping.</td></tr><tr><td align="left">
            <code class="varname">grid_north_pole_latitude</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">True latitude (degrees_north) of the north pole of the
          rotated grid.</td></tr><tr><td align="left">
            <code class="varname">grid_north_pole_longitude</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">True longitude (degrees_east) of the north pole of the
          rotated grid.</td></tr><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">inverse_flattening</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">
            <font style="background-color:#ffccff">Used to specify the
            <span class="emphasis"><em>inverse</em></span> flattening (<span class="emphasis"><em>1/f</em></span>)
            of the ellipsoidal figure associated with the geodetic datum and
            used to approximate the shape of the Earth. The flattening
            (<span class="emphasis"><em>f</em></span>) of the ellipsoid is related to the
            semi-major and semi-minor axes by the formula <span class="emphasis"><em>f =
            (a-b)/a</em></span>. In the case of a spherical Earth this
            attribute should be omitted or set to zero. Example: 298.257222101
            for the GRS 1980 ellipsoid. (Note: By convention the dimensions of
            an ellipsoid are specified using either the semi-major and
            semi-minor axis lengths, or the semi-major axis length and the
            inverse flattening. If all three attributes are specified then the
            supplied values must be consistent with the aforementioned
            formula.)</font>
          </td></tr><tr><td align="left">
            <code class="varname">latitude_of_projection_origin</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">The latitude chosen as the origin of rectangular coordinates
          for a map projection. Domain: <code class="varname">-90.0 &lt;=
          latitude_of_projection_origin &lt;= 90.0</code></td></tr><tr><td align="left">
            <code class="varname">longitude_of_central_meridian</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">The line of longitude at the center of a map projection
          generally used as the basis for constructing the projection. Domain:
          <code class="varname">-180.0 &lt;= longitude_of_central_meridian &lt;
          180.0</code></td></tr><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">longitude_of_prime_meridian</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">
            <font style="background-color:#ffccff">Specifies the longitude, with respect to
            Greenwich, of the prime meridian associated with the geodetic
            datum. The prime meridian defines the origin from which longitude
            values are determined. Not to be confused with the projection
            origin longitude (cf.
            <code class="varname">longitude_of_projection_origin</code>, a.k.a. central
            meridian) which defines the longitude of the map projection
            origin. Domain: <code class="varname">-180.0 &lt;= longitude_of_prime_meridian
            &lt; 180.0</code> decimal degrees. Default =
            <code class="varname">0.0</code></font>
          </td></tr><tr><td align="left">
            <code class="varname">longitude_of_projection_origin</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">The longitude chosen as the origin of rectangular coordinates
          for a map projection. Domain: <code class="varname">-180.0 &lt;=
          longitude_of_projection_origin &lt; 180.0</code></td></tr><tr><td align="left">
            <code class="varname">north_pole_grid_longitude</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">Longitude (degrees) of the true north pole in the rotated
          grid.</td></tr><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">perspective_point_height</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">
            <font style="background-color:#ffccff">Records the height, <span class="emphasis"><em>in
            metres</em></span>, of the map projection perspective point above
            the ellipsoid (or sphere). Used by perspective-type map
            projections, for example the Vertical Perspective Projection,
            which may be used to simulate the view from a Meteosat
            satellite.</font>
          </td></tr><tr><td align="left">
            <code class="varname">scale_factor_at_central_meridian</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">A multiplier for reducing a distance obtained from a map by
          computation or scaling to the actual distance along the central
          meridian. Domain: <code class="varname">scale_factor_at_central_meridian &gt;
          0.0</code></td></tr><tr><td align="left">
            <code class="varname">scale_factor_at_projection_origin</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">A multiplier for reducing a distance obtained from a map by
          computation or scaling to the actual distance at the projection
          origin. Domain: <code class="varname">scale_factor_at_projection_origin &gt;
          0.0</code></td></tr><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">semi_major_axis</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">
            <font style="background-color:#ffccff">Specifies the length, <span class="emphasis"><em>in
            metres</em></span>, of the semi-major axis of the ellipsoidal
            figure associated with the geodetic datum and used to approximate
            the shape of the Earth. Commonly denoted using the symbol
            <span class="emphasis"><em>a</em></span>. In the case of a spherical Earth
            approximation this attribute defines the radius of the Earth. See
            also the <code class="varname">inverse_flattening</code>
            attribute.</font>
          </td></tr><tr><td align="left">
            <font style="background-color:#ffccff">
              <code class="varname">semi_minor_axis</code>
            </font>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">
            <font style="background-color:#ffccff">Specifies the length, <span class="emphasis"><em>in
            metres</em></span>, of the semi-minor axis of the ellipsoidal
            figure associated with the geodetic datum and used to approximate
            the shape of the Earth. Commonly denoted using the symbol
            <span class="emphasis"><em>b</em></span>. In the case of a spherical Earth
            approximation this attribute should be omitted (the preferred
            option) or else set equal to the value of the semi_major_axis
            attribute. See also the inverse_flattening attribute.</font>
          </td></tr><tr><td align="left">
            <code class="varname">standard_parallel</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left"><font style="background-color:#ffccff"> Specifies the line, or lines, of
          latitude at which the developable map projection surface (plane,
          cone, or cylinder) touches the reference sphere or ellipsoid used to
          represent the Earth. Since there is zero scale distortion along a
          standard parallel it is also referred to as a "latitude of true
          scale". In the situation where a conical developable surface
          intersects the reference ellipsoid there are two standard parallels,
          in which case this attribute can be used as a vector to record both
          latitude values, with the additional convention that the standard
          parallel nearest the pole (N or S) is provided first. </font>
          <font style="background-color:#ffff88; text-decoration:line-through"> Line of constant latitude at which the
          surface of the Earth and plane or developable surface intersect.
          This attribute may be vector valued if two standard parallels are
          specified. </font> Domain: <code class="varname">-90.0 &lt;=
          standard_parallel &lt;= 90.0</code></td></tr><tr><td align="left">
            <code class="varname">straight_vertical_longitude_from_pole</code>
          </td><td align="left">
            <font style="background-color:#ffccff">N</font>
          </td><td align="left">The longitude to be oriented straight up from the North or
          South Pole. Domain: <code class="varname">-180.0 &lt;=
          straight_vertical_longitude_from_pole &lt; 180.0</code></td></tr></tbody></table></div></div><br class="table-break"></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="revhistory"></a>Appendix G. Revision History</h2></div></div></div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left"></td><td align="left">14 June 2004</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Added <a class="xref" href="#lambert-azimuthal-equal-area" title="Lambert azimuthal equal area">the section called &#8220;Lambert azimuthal equal area&#8221;</a>.</p></li><li><p><a class="xref" href="#polar-stereographic" title="Polar stereographic">the section called &#8220;Polar stereographic&#8221;</a>: Added
              <code class="varname">latitude_of_projection_origin</code> map
              parameter.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">1 July 2004</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p><a class="xref" href="#scalar-coordinate-variables" title="5.7. Scalar Coordinate Variables">Section 5.7, &#8220;Scalar Coordinate Variables&#8221;</a>: Added note
              that use of scalar coordinate variables inhibits
              interoperability with COARDS conforming applications.</p></li><li><p><a class="xref" href="#multiple-forecasts-from-single-analysis" title="Example 5.12. Multiple forecasts from a single analysis">Example 5.12, &#8220;Multiple forecasts from a single analysis&#8221;</a>:
              Added <code class="varname">positive</code> attribute to the scalar
              coordinate p500 to make it unambiguous that the pressure is a
              vertical coordinate value.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">20 September 2004</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p><a class="xref" href="#cell-methods" title="7.3. Cell Methods">Section 7.3, &#8220;Cell Methods&#8221;</a>: Changed several incorrect
              occurances of the cell method <code class="varname">"standard
              deviation"</code> to
              <code class="varname">"standard_deviation"</code>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">22 October 2004</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Added <a class="xref" href="#lambert-conformal-projection" title="Example 5.7. Lambert conformal projection">Example 5.7, &#8220;Lambert conformal projection&#8221;</a>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">25 November 2005</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p><a class="xref" href="#atmosphere-hybrid-height-coordinate" title="Atmosphere hybrid height coordinate">the section called &#8220; Atmosphere hybrid height coordinate &#8221;</a>:
              Fixed definition of atmosphere hybrid height coordinate.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">21 March 2006</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Added <a class="xref" href="#azimuthal-equidistant" title="Azimuthal equidistant">the section called &#8220;Azimuthal equidistant&#8221;</a>.</p></li><li><p>Added <a class="xref" href="#atmosphere-natural-log-pressure-coordinate" title="Atmosphere natural log pressure coordinate">the section called &#8220; Atmosphere natural log pressure coordinate &#8221;</a>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">17 January 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p><a class="xref" href="#preface" title="Preface">Preface</a>: Changed text to refer to rules
              of CF governance, and provisional status.</p></li><li><p><a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a>, <a class="xref" href="#coordinate-system" title="Chapter 5. Coordinate Systems">Chapter 5, <i>Coordinate Systems</i></a>: Made changes regarding use of the
              axis attribute to identify horizontal coordinate
              variables.</p></li><li><p>Changed document version to 1.1.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">4 May 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p><a class="xref" href="#grid-mappings-and-projections" title="5.6. Grid Mappings and ProjectionsHorizontal Coordinate Reference Systems, Grid Mappings, and Projections">Section 5.6, &#8220;<font style="background-color:#ffff88; text-decoration:line-through">Grid Mappings and
    Projections</font><font style="background-color:#ffccff">Horizontal Coordinate
    Reference Systems, Grid Mappings, and Projections</font>&#8221;</a>, <a class="xref" href="#appendix-grid-mappings" title="Appendix F. Grid Mappings">Appendix F, <i>Grid Mappings</i></a> : Additions and revisions to
              CF grid mapping attributes to support the specification of
              coordinate reference system properties <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/18" target="_top">(Trac ticket
              #18)</a>.</p></li><li><p><a class="xref" href="#table-supported-units" title="Table 3.1. Supported Units">Table 3.1, &#8220;Supported Units&#8221;</a> : Corrected Prefix
              for Factor "1e-2" from "deci" to "centi". <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/25" target="_top">(Trac ticket
              #25)</a>.</p></li><li><p>Changed document version to 1.2.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">15 July 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p><a class="xref" href="#flags" title="3.5. Flags">Section 3.5, &#8220;Flags&#8221;</a>, <a class="xref" href="#attribute-appendix" title="Appendix A. Attributes">Appendix A, <i>Attributes</i></a>, <a class="xref" href="#standard-name-modifiers" title="Appendix C. Standard Name Modifiers">Appendix C, <i>Standard Name Modifiers</i></a> : Enhanced the Flags
              definition to support bit field notation using a
              <code class="varname">flag_masks</code> attribute. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/26" target="_top">(Trac ticket
              #26)</a>.</p></li><li><p>Changed document version to 1.3.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">9 October 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Fixed defect in <a class="xref" href="#atm-sigma-coord-ex" title="Example 4.3. Atmosphere sigma coordinate">Example 4.3, &#8220;Atmosphere sigma coordinate&#8221;</a>.
              <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/30" target="_top">(Trac
              ticket #30)</a>.</p></li><li><p>Fixed defect in <a class="xref" href="#coordinate-system" title="Chapter 5. Coordinate Systems">Chapter 5, <i>Coordinate Systems</i></a>.
              <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/32" target="_top">(Trac
              ticket #32)</a>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">7 November 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Fixed defect in wording of <a class="xref" href="#coordinate-system" title="Chapter 5. Coordinate Systems">Chapter 5, <i>Coordinate Systems</i></a>. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/35" target="_top">(Trac ticket
              #35)</a>.</p></li><li><p>Fixed defect related to subsection headings in <a class="xref" href="#dimensionless-v-coord" title="Appendix D. Dimensionless Vertical Coordinates">Appendix D, <i>Dimensionless Vertical Coordinates</i></a>. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/36" target="_top">(Trac ticket
              #36)</a>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">10 December 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Changes related to removing ambiguity in <a class="xref" href="#cell-methods" title="7.3. Cell Methods">Section 7.3, &#8220;Cell Methods&#8221;</a>. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/17" target="_top">(Trac ticket
              #17)</a>.</p></li><li><p>Changed document version to 1.4.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">11 December 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Added grid mappings Lambert Cylindrical Equal Area,
              Mercator, and Orthographic to <a class="xref" href="#appendix-grid-mappings" title="Appendix F. Grid Mappings">Appendix F, <i>Grid Mappings</i></a>. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/34" target="_top">(Trac ticket
              #34)</a>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">12 December 2008</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Fixed defect in Mercator section of <a class="xref" href="#appendix-grid-mappings" title="Appendix F. Grid Mappings">Appendix F, <i>Grid Mappings</i></a> by updating to version 12 of
              Grid Map Names (see <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/wiki/GridMapNames?version=12" target="_top">http://cf-pcmdi.llnl.gov/trac/wiki/GridMapNames?version=12</a>).</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">27 February 2009</td></tr><tr><td align="left" colspan="2">
        <p>
          </p><div class="orderedlist"><ol type="1" compact><li><p>Fixed defect by clarifying that coordinates indicate
              gridpoint location in <a class="xref" href="#coordinate-types" title="Chapter 4.  Coordinate Types">Chapter 4, <i>
    Coordinate Types
  </i></a>. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/44" target="_top">(Trac ticket
              #44)</a>.</p></li><li><p>Fixed defect of outdated Conventions attribute. <a class="ulink" href="http://cf-pcmdi.llnl.gov/trac/ticket/45" target="_top">(Trac ticket
              #45)</a>.</p></li></ol></div><p>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">25 October 2010</td></tr><tr><td align="left" colspan="2">
        <p>
          <font style="background-color:#ffccff">Minor revisions requested by Jonathan
          Gregory. Revisions 33 and 49 were closed after discussions; the rest
          had elicited no objections. <div class="orderedlist"><ol type="1" compact><li><p>Ticket 33, cell_methods for statistical indices</p></li><li><p>Ticket 49, clarification of flag_meanings
                attribute</p></li><li><p>Ticket 58, remove deprecation of "missing_value"
                attribute</p></li><li><p>Ticket 57, fix for broken URLs in CF Conventions
                document</p></li><li><p>Ticket 56, typo in CF conventions doc</p></li><li><p>Ticket 51, syntax consistency for dimensionless vertical
                coordinate definitions</p></li><li><p>Ticket 47, error in example 7.4</p></li><li><p>Changed document version to 1.5.</p></li><li><p>New chapter, ticket 37 Changed document version to
                1.6.</p></li></ol></div></font>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">22 June 2011</td></tr><tr><td align="left" colspan="2">
        <p>
          <font style="background-color:#ffccff">Ticket 37. Added Chapter 9, Discrete
          Sampling Geometries, and a related Appendix H, and revised several
          other chapters.</font>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">5 December 2011</td></tr><tr><td align="left" colspan="2">
        <p>
          <font style="background-color:#ffccff">In Appendix H (Annotated Examples of
          Descrete Geometries), updated standard names "station_description"
          and "station_wmo_id" to "platform_name" and
          "platform_id".</font>
        </p>
      </td></tr><tr><td align="left"></td><td align="left">3 October 2013</td></tr><tr><td align="left" colspan="2">
        <p>Ticket 69. Added Section 5.6.1, Use of the CRS Well-known Text
        Format and related changes, Ticket 93, a minor correction to Section
        7.3, and Ticket 65, a range entry in Apendix E.</p>
      </td></tr><tr><td align="left"></td><td align="left">12 November 2013</td></tr><tr><td align="left" colspan="2">
        <p>Ticket 61. Added two cell methods to Appendix E.</p>
      </td></tr><tr><td align="left"></td><td align="left">28 March 2014</td></tr><tr><td align="left" colspan="2">
        <p>Added John Graybeal to the authors list. <span class="bold"><strong>
            <a class="ulink" href="???" target="_top">N.B. That was a mistake! Jonathan Gregory didn't
            ask that he go here, he asked that he be added to the CF
            Conventions and standard names committees (that does not mean the
            authors list and does not mean the governance panel). c.f. today's
            emails. Once I do this, I should undo this document change. (I
            don't have access to that part of the web site today.).</a>
          </strong></span></p>
      </td></tr><tr><td align="left"></td><td align="left">7 January 2015</td></tr><tr><td align="left" colspan="2">
        <p>Ticket 93. Added two new dimensionless coordinates to Appendix D.</p>
      </td></tr></table></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-examples-discrete-geometries"></a>Appendix H. <font style="background-color:#ffccff">Annotated Examples of Discrete Geometries</font></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#idp9714416">H.1. Point Data</a></span></dt><dt><span class="sect1"><a href="#time-series-data">H.2. Time Series Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9763584">H.2.1. Orthogonal multidimensional array representation of time series</a></span></dt><dt><span class="sect2"><a href="#idp9772688">H.2.2. Incomplete multidimensional array representation of time series</a></span></dt><dt><span class="sect2"><a href="#idp9751936">H.2.3. Single time series, including deviations from a nominal fixed spatial location</a></span></dt><dt><span class="sect2"><a href="#idp9804080">H.2.4. Contiguous ragged array representation of time series</a></span></dt><dt><span class="sect2"><a href="#idp9819360">H.2.5. Indexed ragged array representation of time series</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9831536">H.3. Profile Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9836800">H.3.1. Orthogonal multidimensional array representation of profiles</a></span></dt><dt><span class="sect2"><a href="#idp9844272">H.3.2. Incomplete multidimensional array representation of profiles</a></span></dt><dt><span class="sect2"><a href="#idp9847344">H.3.3. Single profile</a></span></dt><dt><span class="sect2"><a href="#idp9853184">H.3.4. Contiguous ragged array representation of profiles</a></span></dt><dt><span class="sect2"><a href="#idp9860512">H.3.5. Indexed ragged array representation of profiles</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9867488">H.4. Trajectory Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9872416">H.4.1. Multidimensional array representation of trajectories</a></span></dt><dt><span class="sect2"><a href="#idp9880624">H.4.2. Single trajectory</a></span></dt><dt><span class="sect2"><a href="#idp9887728">H.4.3. Contiguous ragged array representation of trajectories</a></span></dt><dt><span class="sect2"><a href="#idp9895520">H.4.4. Indexed ragged array representation of trajectories</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9903584">H.5. Time Series of Profiles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9913136">H.5.1. Multidimensional array representations of time series profiles</a></span></dt><dt><span class="sect2"><a href="#idp9782384">H.5.2. Time series of profiles at a single station</a></span></dt><dt><span class="sect2"><a href="#idp9791328">H.5.3. Ragged array representation of time series profiles</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp9970000">H.6. Trajectory of Profiles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp9974768">H.6.1. Multidimensional array representation of trajectory profiles</a></span></dt><dt><span class="sect2"><a href="#idp9986752">H.6.2. Profiles along a single trajectory</a></span></dt><dt><span class="sect2"><a href="#idp9993472">H.6.3. Ragged array representation of trajectory profiles</a></span></dt></dl></dd></dl></div><p><font style="background-color:#88ff88; font-style:italic">Note: For greater readability, the conventional highlighting for new material. has not been applied to the whole chapter.</font></p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9714416"></a>H.1. Point Data</h2></div></div></div><p>To represent data at scattered locations and times with no implied relationship among of coordinate positions, both data and coordinates must share the same (sample) instance dimension.   Because each feature contains only a single data element, there is no need for a separate element dimension.  The representation of point features is a special, degenerate case of the standard four representations.  The <code class="varname">coordinates</code> attribute is used on the data variables to unambiguously identify the relevant space and time auxiliary coordinate variables.</p><p></p><div class="example"><a name="Example%20H.1.1"></a><p class="title"><b>Example H.1. Point data.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = 1234 ;

   variables:
      double time(obs) ; 
          time:standard_name = &#8220;time&#8221;;
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(obs) ; 
          lon:standard_name = "longitude";
          lon:long_name = "longitude of the observation";
          lon:units = "degrees_east";
      float lat(obs) ; 
          lat:standard_name = "latitude";
          lat:long_name = "latitude of the observation" ;
          lat:units = "degrees_north" ;
      float alt(obs) ;
          alt:long_name = "vertical distance above the surface" ;
          alt:standard_name = "height" ;
          alt:units = "m";
          alt:positive = "up";
          alt:axis = "Z";

      float humidity(obs) ;
          humidity:standard_name = "specific_humidity" ;
          humidity:coordinates = "time lat lon alt" ;
      float temp(obs) ;
          temp:standard_name = "air_temperature" ;
          temp:units = "Celsius" ;
          temp:coordinates = "time lat lon alt" ;

   attributes:
      :featureType = "point";</pre></div></div><br class="example-break"><p></p><p>In this example, the humidity(i) and temp(i) data are associated with the coordinate values time(i), lat(i), lon(i), and alt(i). The obs dimension may optionally be the netCDF unlimited dimension of the netCDF file. </p><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="time-series-data"></a>H.2. Time Series Data</h2></div></div></div><p></p><p>Data may be taken over periods of time at a set of discrete point, spatial locations called stations (see also discussion in 9.1).  The set of elements at a particular station is referred to as a timeSeries feature and a data variable may contain a collection of such features. The instance dimension in the case of timeSeries specifies the number of time series in the collection and is also referred to as the station dimension. The instance variables, which have just this dimension, including latitude and longitude for example, are also referred to as station variables and are considered to contain information describing the stations. The station variables may contain missing values, allowing one to reserve space for additional stations that may be added at a later time, as discussed in section 9.6. In addition,</p><p></p><div class="itemizedlist"><ul type="disc"><li><p>It is strongly recommended that there should be a station variable (which may be of any type) with the attribute <code class="varname">cf_role=&#8221;timeseries_id&#8221;</code>, whose values uniquely identify the stations.</p></li><li><p>It is recommended that there should be station variables with standard_name attributes "<code class="varname">platform_name</code>", "<code class="varname">surface_altitude</code>" and &#8220;<code class="varname">platform_id</code>&#8221; when applicable. </p></li></ul></div><p></p><p>All the representations described in section 9.3 can be used for time series. The global attribute <code class="varname">featureType=&#8221;timeSeries&#8221;</code> (case-insensitive) must be included.</p><p></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9763584"></a>H.2.1. Orthogonal multidimensional array representation of time series</h3></div></div></div><p></p><p>If the time series instances have the same number of elements and the time values are identical for all instances, you may use the orthogonal multidimensional array representation. This has either a one-dimensional coordinate variable, time(time), provided the time values are ordered monotonically, or a one-dimensional auxiliary coordinate variable, time(o), where o is the element dimension. In the former case, listing the time variable in the <code class="varname">coordinates</code> attributes of the data variables is optional. </p><p></p><div class="example"><a name="Example%20H2.1.1"></a><p class="title"><b>Example H.2. Timeseries with common element times in a time coordinate variable using the orthogonal multidimensional array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
     station = 10 ;  // measurement locations
     time = UNLIMITED ;
   variables:
     float humidity(station,time) ;
       humidity:standard_name = "specific humidity" ;
       humidity:coordinates = "lat lon alt" ;
     double time(time) ; 
       time:standard_name = "time";
       time:long_name = "time of measurement" ;
       time:units = "days since 1970-01-01 00:00:00" ;
     float lon(station) ; 
       lon:standard_name = "longitude";
       lon:long_name = "station longitude";
       lon:units = "degrees_east";
     float lat(station) ; 
       lat:standard_name = "latitude";
       lat:long_name = "station latitude" ;
       lat:units = "degrees_north" ; 
     float alt(station) ;
       alt:long_name = "vertical distance above the surface" ;
       alt:standard_name = "height" ;
       alt:units = "m";
       alt:positive = "up";
       alt:axis = "Z";
     char station_name(station, name_strlen) ;
       station_name:long_name = "station name" ;
       station_name:cf_role = "timeseries_id";
   attributes:
       :featureType = "timeSeries";</pre></div></div><br class="example-break"><p></p><p>In this example, <code class="varname">humidity(i,o)</code> is element o of time series i, and associated with the coordinate values <code class="varname">time(o)</code>, <code class="varname">lat(i)</code>, and <code class="varname">lon(i)</code>. Either the instance (station) or the element (time) dimension may optionally be the netCDF unlimited dimension. </p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9772688"></a>H.2.2. Incomplete multidimensional array representation of time series</h3></div></div></div><p></p><p>Much of the simplicity of the orthogonal multidimensional representation can be preserved even in cases where individual time series have different time coordinate values.  All time series must be allocated the amount of staorage needed by the longest, so the use of this representation will trade off simplicity against storage space in some cases.  </p><p></p><div class="example"><a name="Example%20H.2.2.1"></a><p class="title"><b>Example H.3. Timeseries of station data in the incomplete multidimensional array representation.    </b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      station = UNLIMITED ;
      obs = 13 ;

   variables:
      float lon(station) ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat(station) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      float alt(station) ;
          alt:long_name = "vertical distance above the surface" ;
          alt:standard_name = "height" ;
          alt:units = "m";
          alt:positive = "up";
          alt:axis = "Z";
      char station_name(station, name_strlen) ;
          station_name:long_name = "station name" ;
          station_name:cf_role = "timeseries_id";
      int station_info(station) ;
          station_info:long_name = "any kind of station info" ;
      float station_elevation(station) ;
          station_elevationalt:long_name = "height above the geoid" ;
          station_elevationalt:standard_name = "surface_altitude" ;
          station_elevationalt:units = "m";

      double time(station, obs) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
      float humidity(station, obs) ;
          humidity:standard_name = &#8220;specific_humidity&#8221; ;
          humidity:coordinates = "time lat lon alt" ;
          humidity:_FillValue = -999.9;
      float temp(station, obs) ;
          temp:standard_name = &#8220;air_temperature&#8221; ;
          temp:units = "Celsius" ;
          temp:coordinates = "time lat lon alt" ;
          temp:_FillValue = -999.9;

   attributes:
          :featureType = "timeSeries";</pre></div></div><br class="example-break"><p></p><p>In this example, the humidity(i,o) and temp(i,o) data for element o of time series i are associated with the coordinate values time(i,o), lat(i), lon(i) and alt(i). Either the instance (station) dimension or the element (obs) dimension could be the unlimited dimension of a netCDF file.  Any unused elements of the data and auxiliary coordinate variables must contain the missing data flag value(section 9.6).</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9751936"></a>H.2.3. Single time series, including deviations from a nominal fixed spatial location</h3></div></div></div><p></p><p>When the intention of a data variable is to contain only a single time series, the preferred encoding is a special case of the multidimensional array representation. </p><p></p><div class="example"><a name="Example%20H.2.3.1"></a><p class="title"><b>Example H.4. A single timeseries.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      time = 100233 ;
      name_strlen = 23 ;

   variables:
      float lon ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      float alt ;
          alt:long_name = "vertical distance above the surface" ;
          alt:standard_name = "height" ;
          alt:units = "m";
          alt:positive = "up";
          alt:axis = "Z";
      char station_name(name_strlen) ;
          station_name:long_name = "station name" ;
          station_name:cf_role = "timeseries_id";

      double time(time) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
      float humidity(time) ;
          humidity:standard_name = &#8220;specific_humidity&#8221; ;
          humidity:coordinates = "time lat lon alt" ;
          humidity:_FillValue = -999.9;
      float temp(time) ;
          temp:standard_name = &#8220;air_temperature&#8221; ;
          temp:units = "Celsius" ;
          temp:coordinates = "time lat lon alt" ;
          temp:_FillValue = -999.9;

   attributes:
          :featureType = "timeSeries";</pre></div></div><br class="example-break"><p></p><p>While an idealized time series is defined at a single, stable point location, there are examples of time series, such as cabled ocean surface mooring measurements, in which the precise position of the observations varies slightly from a nominal fixed point.  In the following example we show how the spatial positions of such a time series should be encoded in CF.  Note that although this example shows only a single time series, the technique is applicable to all of the representations.</p><p></p><div class="example"><a name="Example%20H.2.3.2"></a><p class="title"><b>Example H.5. A single timeseries with time-varying deviations from a nominal point spatial location</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      time = 100233 ;
      name_strlen = 23 ;

   variables:
      float lon ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
          lon:axis = &#8220;X&#8221;;
      float lat ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
          lat: axis = &#8220;Y&#8221; ;
      float precise_lon (time); 
          precise_lon:standard_name = "longitude";
          precise_lon:long_name = "station longitude";
          precise_lon:units = "degrees_east";
      float precise_lat (time); 
          precise_lat:standard_name = "latitude";
          precise_lat:long_name = "station latitude" ;
          precise_lat:units = "degrees_north" ;
      float alt ;
          alt:long_name = "vertical distance above the surface" ;
          alt:standard_name = "height" ;
          alt:units = "m";
          alt:positive = "up";
          alt:axis = "Z";
      char station_name(name_strlen) ;
          station_name:long_name = "station name" ;
          station_name:cf_role = "timeseries_id";

      double time(time) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
      float humidity(time) ;
          humidity:standard_name = &#8220;specific_humidity&#8221; ;
          humidity:coordinates = "time lat lon alt precise_lon precise_lat" ;
          humidity:_FillValue = -999.9;
      float temp(time) ;
          temp:standard_name = &#8220;air_temperature&#8221; ;
          temp:units = "Celsius" ;
          temp:coordinates = "time lat lon alt precise_lon precise_lat " ;
          temp:_FillValue = -999.9;

   attributes:
          :featureType = "timeSeries";</pre></div></div><br class="example-break"><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9804080"></a>H.2.4. Contiguous ragged array representation of time series</h3></div></div></div><p></p><p>When the time series have different lengths and the data values for entire time series are available to be written in a single operation,  the contiguous ragged array representation is efficient.</p><p></p><div class="example"><a name="Example%20H.2.4.1"></a><p class="title"><b>Example H.6. Timeseries of station data in the contiguous ragged array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      station = 23 ;
      obs = 1234 ;

   variables:
      float lon(station) ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat(station) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      float alt(station) ;
          alt:long_name = "vertical distance above the surface" ;
          alt:standard_name = "height" ;
          alt:units = "m";
          alt:positive = "up";
          alt:axis = "Z";
      char station_name(station, name_strlen) ;
          station_name:long_name = "station name" ;
          station_name:cf_role = "timeseries_id";
      int station_info(station) ;
          station_info:long_name = "some kind of station info" ;
      int row_size(station) ;
          row_size:long_name = "number of observations for this station " ;
          row_size:sample_dimension = "obs" ;

      double time(obs) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float humidity(obs) ;
          humidity:standard_name = &#8220;specific_humidity&#8221; ;
          humidity:coordinates = "time lat lon alt" ;
          humidity:_FillValue = -999.9;
      float temp(obs) ;
          temp:standard_name = &#8220;air_temperature&#8221; ;
          temp:units = "Celsius" ;
          temp:coordinates = "time lat lon alt" ;
          temp:_FillValue = -999.9;

   attributes:
          :featureType = "timeSeries";</pre></div></div><br class="example-break"><p></p><p>The data humidity(o) and temp(o) are associated with the coordinate values time(o), lat(i), lon(i), and alt(i), where i indicates which time series. Time series i comprises the data elements from </p><p></p><pre class="programlisting">   rowStart(i) to rowStart(i) + row_size(i) - 1</pre><p></p><p>where</p><p></p><pre class="programlisting">
      rowStart(i) = 0 if i = 0      
      rowStart(i) = rowStart(i-1) + row_size(i-1) if i &gt; 0</pre><p>The variable, <code class="varname">row_size</code>, is the count variable containing the length of each time series feature.   It is identified by having an attribute with name <span class="bold"><strong><code class="varname">sample_dimension</code></strong></span> whose value is name of the sample dimension (<code class="varname">obs</code> in this example). The sample dimension could optionally be the netCDF unlimited dimension. The variable bearing the <span class="bold"><strong><code class="varname">sample_dimension</code></strong></span> attribute must have the instance dimension (<code class="varname">station</code> in this example) as its single dimension, and must be of type integer.   This variable implicitly partitions into individual instances all variables that have the sample dimension. The auxiliary coordinate variables <code class="varname">lat</code>, <code class="varname">lon</code>, <code class="varname">alt</code> and <code class="varname">station_name</code> are station variables. </p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9819360"></a>H.2.5. Indexed ragged array representation of time series</h3></div></div></div><p></p><p>When time series with different lengths are written incrementally, the indexed ragged array representation is efficient.</p><p></p><div class="example"><a name="Example%20H.2.5.1"></a><p class="title"><b>Example H.7. Timeseries of station data in the indexed ragged array representation. </b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      station = 23 ;
      obs = UNLIMITED ;

   variables:
      float lon(station) ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat(station) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      float alt(station) ;
          alt:long_name = "vertical distance above the surface" ;
          alt:standard_name = "height" ;
          alt:units = "m";
          alt:positive = "up";
          alt:axis = "Z";
      char station_name(station, name_strlen) ;
          station_name:long_name = "station name" ;
          station_name:cf_role = "timeseries_id";
      int station_info(station) ;
          station_info:long_name = "some kind of station info" ;

      int stationIndex(obs) ;
          stationIndex:long_name = "which station this obs is for" ;
          stationIndex:instance_dimension= "station" ;
      double time(obs) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float humidity(obs) ;
          humidity:standard_name = &#8220;specific_humidity&#8221; ;
          humidity:coordinates = "time lat lon alt" ;
          humidity:_FillValue = -999.9;
      float temp(obs) ;
          temp:standard_name = &#8220;air_temperature&#8221; ;
          temp:units = "Celsius" ;
          temp:coordinates = "time lat lon alt" ;
          temp:_FillValue = -999.9;

   attributes:
          :featureType = "timeSeries";</pre></div></div><br class="example-break"><p></p><p>The humidity(o) and temp(o) data are associated with the coordinate values time(o), lat(i), lon(i), and alt(i), where i = stationIndex(o) is a zero-based index indicating which time series. Thus, time(0), humidity(0) and temp(0) belong to the element of the <code class="varname">station</code> dimension that is indicated by <code class="varname">stationIndex(0)</code>; time(1), humidity(1) and temp(1) belong to element <code class="varname">stationIndex(1)</code> of the <code class="varname">station</code> dimension, etc. </p><p>The variable, <code class="varname">stationIndex</code> , is identified as the index variable by having an attribute with name of <span class="bold"><strong><code class="varname">instance_dimension</code></strong></span> whose value is the instance dimension (<code class="varname">station</code> in this example).  The variable bearing the <span class="bold"><strong><code class="varname">instance_dimension</code></strong></span> attribute must have the sample dimension (<code class="varname">obs</code> in this example) as its single dimension, and must be type integer. This variable implicitly assigns the station to each value of any variable having the sample dimension. The sample dimension need not be the netCDF unlimited dimension, though it commonly is.</p><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9831536"></a>H.3. Profile Data</h2></div></div></div><p></p><p>A series of connected observations along a vertical line, like an atmospheric or ocean sounding, is called a profile. For each profile, there is a single time, lat and lon. A data variable may contain a collection of profile features. The instance dimension in the case of profiles specifies the number of profiles in the collection and is also referred to as the <span class="bold"><strong>profile dimension</strong></span>. The instance variables, which have just this dimension, including latitude and longitude for example, are also referred to as <span class="bold"><strong>profile variables</strong></span> and are considered to be information about the profiles. It is strongly recommended that there always be a profile variable (of any data type) with <code class="varname">cf_role</code> attribute "<code class="varname">profile_id</code>", whose values uniquely identify the profiles. The profile variables may contain missing values. This allows one to reserve space for additional profiles that may be added at a later time, as discussed in section 9.6. All the representations described in section 9.1.3 can be used for profiles. The global attribute <code class="varname">featureType=&#8221;profile&#8221;</code> (case-insensitive) should be included if all data variables in the file contain profiles.</p><p></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9836800"></a>H.3.1. Orthogonal multidimensional array representation of profiles</h3></div></div></div><p></p><p>If the profile instances have the same number of elements and the vertical coordinate values are identical for all instances, you may use the orthogonal multidimensional array representation. This has either a one-dimensional coordinate variable, z(z), provided the vertical coordinate values are ordered monotonically, or a one-dimensional auxiliary coordinate variable, alt(o), where o is the element dimension. In the former case, listing the vertical coordinate variable in the <span class="bold"><strong>coordinates</strong></span> attributes of the data variables is optional.</p><p></p><div class="example"><a name="Example%20H.3.1.1"></a><p class="title"><b>Example H.8. Atmospheric sounding profiles for a common set of vertical coordinates stored in the orthogonal multidimensional array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      z = 42 ;
      profile = 142 ;

   variables:
      int profile(profile) ;
            profile:cf_role = "profile_id";
      double time(profile); 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(profile); 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(profile); 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ;

      float z(z) ;
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ; 
          z:axis = "Z" ;   

      float pressure(profile, z) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat altz" ;

      float temperature(profile, z) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat altz" ;

      float humidity(profile, z) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat altz" ;

   attributes:
      :featureType = "profile";</pre></div></div><br class="example-break"><p>The pressure(i,o), temperature(i,o), and humidity(i,o) data for element o of profile i are associated with the coordinate values time(i), lat(i), and lon(i). The vertical coordinate for element o in each profile is altitude z(o). Either the instance (profile) or the element (z) dimension could be the netCDF unlimited dimension.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9844272"></a>H.3.2. Incomplete multidimensional array representation of profiles</h3></div></div></div><p></p><p>If there are the same number of levels in each profile, but they do not have the same set of vertical coordinates, one can use the incomplete multidimensional array representation, which the vertical coordinate variable is two-dimensional e.g. replacing z(z) in <a class="xref" href="#Example%20H.3.1.1" title="Example H.8. Atmospheric sounding profiles for a common set of vertical coordinates stored in the orthogonal multidimensional array representation.">Example H.8, &#8220;Atmospheric sounding profiles for a common set of vertical coordinates stored in the orthogonal multidimensional array representation.&#8221;</a> with alt(profile,z).  This representation also allows one to have a variable number of elements in different profiles, at the cost of some wasted space. In that case, any unused elements of the data and auxiliary coordinate variables must contain missing data values (section 9.6).</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9847344"></a>H.3.3. Single profile</h3></div></div></div><p></p><p>When a single profile is stored in a file, there is no need for the profile dimension; the data arrays are one-dimensional. This is a special case of the orthogonal multidimensional array representation (9.3.1). </p><div class="example"><a name="Example%20H.3.3.1"></a><p class="title"><b>Example H.9. Data from a single atmospheric sounding profile.</b></p><div class="example-contents"><pre class="programlisting">
   dimensions:
      z = 42 ;

   variables:
      int profile ;
          profile:cf_role = "profile_id";

      double time; 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon; 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat; 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ;

      float z(z) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ; 
          z:axis = "Z" ;   

      float pressure(z) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat z" ;

      float temperature(z) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat z" ;

      float humidity(z) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat z" ;

   attributes:
      :featureType = "profile";</pre></div></div><br class="example-break"><p>The pressure(o), temperature(o), and humidity(o) data is associated with the coordinate values time, z(o), lat, and lon. The profile variables time, lat and lon, shown here as scalar, could alternatively be one-dimensional time(profile), lat(profile), lon(profile) if a size-one profile dimension were retained in the file.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9853184"></a>H.3.4. Contiguous ragged array representation of profiles</h3></div></div></div><p>When the number of vertical levels for each profile varies, and one can control the order of writing, one can use the contiguous ragged array representation. The canonical use case for this is when rewriting raw data, and you expect that the common read pattern will be to read all the data from each profile. </p><div class="example"><a name="Example%20H.3.4.1"></a><p class="title"><b>Example H.10. Atmospheric sounding profiles for a common set of vertical coordinates stored in the contiguous ragged array representation.</b></p><div class="example-contents"><pre class="programlisting">
   dimensions:
      obs = UNLIMITED ;
      profile = 142 ;

   variables:
      int profile(profile) ;
          profile:cf_role = "profile_id";
      double time(profile); 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(profile); 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(profile); 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ; 
       int rowSize(profile) ;
          rowSize:long_name = "number of obs for this profile " ;
          rowSize:sample_dimension = "obs" ;

      float z(obs) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ;
          z:axis = "Z" ;   

      float pressure(obs) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat z" ;

      float temperature(obs) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat z" ;

      float humidity(obs) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat z" ;

   attributes:
      :featureType = "profile";</pre></div></div><br class="example-break"><p></p><p>The pressure(o), temperature(o), and humidity(o) data is associated with the coordinate values time(i), z(o), lat(i), and lon(i), where i indicates which profile. All elements for one profile are contiguous along the sample dimension. The sample dimension (obs) may be the unlimited dimension or not. All variables that have the instance dimension (profile) as their single dimension are considered to be information about the profiles. </p><p></p><p>The count variable (row_size) contains the number of elements for each profile, and is identified by having an attribute with name "sample_dimension" whose value is the sample dimension being counted. It must have the profile dimension as its single dimension, and must be type integer. The elements are associated with the profile using the same algorithm as in H.2.4.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9860512"></a>H.3.5. Indexed ragged array representation of profiles</h3></div></div></div><p></p><p>When the number of vertical levels for each profile varies, and one cannot write them contiguously, one can use the indexed ragged array representation. The canonical use case is when writing real-time data streams that contain reports from many profiles, arriving randomly. If the sample dimension is the unlimited dimension, this allows data to be appended to the file. </p><p></p><div class="example"><a name="Example%20H.3.5.1"></a><p class="title"><b>Example H.11. Atmospheric sounding profiles for a common set of vertical coordinates stored in the indexed ragged array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = UNLIMITED ;
      profiles = 142 ;

   variables:
      int profile(profile) ;
          profile:cf_name = "profile_id";
      double time(profile); 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(profile); 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(profile); 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ; 

      int parentIndex(obs) ;
          parentIndex:long_name = "index of profile " ;
          parentIndex:instance_dimension= "profile" ;
      
       float z(obs) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ;
          z:axis = "Z" ;   

      float pressure(obs) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat z" ;

      float temperature(obs) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat z" ;

      float humidity(obs) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat z" ;

   attributes:
      :featureType = "profile";</pre></div></div><br class="example-break"><p></p><p>The pressure(o), temperature(o), and humidity(o) data are associated with the coordinate values time(i), z(o), lat(i), and lon(i), where i indicates which profile. The sample dimension (obs) may be the unlimited dimension or not. The profile index variable (parentIndex) is identified by having an attribute with name of "instance_dimension" whose value is the profile dimension name. It must have the sample dimension as its single dimension, and must be type integer. Each value in the profile index variable is the zero-based profile index that the element belongs to. The elements are associated with the profiles using the same algorithm as in H.2.5.
   </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9867488"></a>H.4. Trajectory Data</h2></div></div></div><p></p><p>Data may be taken along discrete paths through space, each path constituting a connected set of points called a trajectory, for example along a flight path, a ship path or the path of a parcel in a Lagrangian calculation. A data variable may contain a collection of trajectory features. The instance dimension in the case of trajectories specifies the number of trajectories in the collection and is also referred to as the <span class="bold"><strong>trajectory dimension</strong></span>. The instance variables, which have just this dimension, are also referred to as <span class="bold"><strong>trajectory variables</strong></span> and are considered to be information about the trajectories. It is strongly recommended that there always be a trajectory variable (of any data type) with the attribute <code class="varname">cf_role=&#8221;trajectory_id&#8221;</code> attribute, whose values uniquely identify the trajectories. The trajectory variables may contain missing values. This allows one to reserve space for additional trajectories that may be added at a later time, as discussed in section 9.6. All the representations described in section 9.3 can be used for trajectories. The global attribute <code class="varname">featureType=&#8221;trajectory&#8221;</code> (case-insensitive) should be included if all data variables in the file contain trajectories.</p><p></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9872416"></a>H.4.1. Multidimensional array representation of trajectories</h3></div></div></div><p></p><p>When storing multiple trajectories in the same file, and the number of elements in each trajectory is the same, one can use the multidimensional array representation. This representation also allows one to have a variable number of elements in different trajectories, at the cost of some wasted space. In that case, any unused elements of the data and auxiliary coordinate variables must contain missing data values (section 9.6).  </p><div class="example"><a name="Example%20H.4.1.1"></a><p class="title"><b>Example H.12. Trajectories recording atmospheric composition in the incomplete multidimensional array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = 1000 ;
      trajectory = 77 ;

   variables:
      char trajectory(trajectory, name_strlen) ;
        trajectory:cf_role = "trajectory_id";
        trajectory:long_name = "trajectory name" ;
      int trajectory_info(trajectory) ;
          trajectory_info:long_name = "some kind of trajectory info" 

      double time(trajectory, obs) ; 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(trajectory, obs) ; 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(trajectory, obs) ; 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ;

      float z(trajectory, obs) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ; 
           z:axis = "Z" ; 

      float O3(trajectory, obs) ;
          O3:standard_name = &#8220;mass_fraction_of_ozone_in_air&#8221;;
          O3:long_name = "ozone concentration" ;
          O3:units = "1e-9" ;
          O3:coordinates = "time lon lat z" ;

      float NO3(trajectory, obs) ;
          NO3:standard_name = &#8220;mass_fraction_of_nitrate_radical_in_air&#8221;;
          NO3:long_name = "NO3 concentration" ;
          NO3:units = "1e-9" ;
          NO3:coordinates = "time lon lat z" ;

   attributes:
      :featureType = "trajectory";</pre></div></div><br class="example-break"><p></p><p>The NO3(i,o) and O3(i,o) data for element o of trajectory i are associated with the coordinate values time(i,o), lat(i,o), lon(i,o), and z(i,o). Either the instance (trajectory) or the element (obs) dimension could be the netCDF unlimited dimension. All variables that have trajectory as their only dimension are considered to be information about that trajectory.</p><p>If the trajectories all have the same set of times, the time auxiliary coordinate variable could be one-dimensional time(obs), or replaced by a one-dimensional coordinate variable time(time), where the size of the time dimension is now equal to the number of elements of each trajectory. In the latter case, listing the time coordinate variable in the coordinates attribute is optional.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9880624"></a>H.4.2. Single trajectory</h3></div></div></div><p></p><p>When a single trajectory is stored in the data variable, there is no need for the trajectory dimension and the arrays are one-dimensional. This is a special case of the multidimensional array representation. </p><p></p><div class="example"><a name="Example%20H.4.2.1"></a><p class="title"><b>Example H.13. A single trajectory recording atmospheric composition.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      time = 42;

   variables:
      char trajectory(name_strlen) ;
          trajectory:cf_role = "trajectory_id";

      double time(time) ; 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(time) ; 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(time) ; 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ;
      float z(time) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ; 
           z:axis = "Z" ; 

      float O3(time) ; 
          O3:standard_name = &#8220;mass_fraction_of_ozone_in_air&#8221;;
          O3:long_name = "ozone concentration" ;
          O3:units = "1e-9" ;
          O3:coordinates = "time lon lat z" ;

      float NO3(time) ; 
          NO3:standard_name = &#8220;mass_fraction_of_nitrate_radical_in_air&#8221;;
          NO3:long_name = "NO3 concentration" ;
          NO3:units = "1e-9" ;
          NO3:coordinates = "time lon lat z" ;

   attributes:
      :featureType = "trajectory";</pre></div></div><br class="example-break"><p></p><p>The NO3(o) and O3(o) data are associated with the coordinate values time(o), z(o), lat(o), and lon(o). In this example, the time coordinate is ordered, so time values are contained in a coordinate variable i.e. time(time) and time is the element dimension. The time dimension may be unlimited or not. </p><p>Note that structurally this looks like unconnected point data as in example 9.5. The presence of the featureType = "trajectory" global attribute indicates that in fact the points are connected along a trajectory.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9887728"></a>H.4.3. Contiguous ragged array representation of trajectories</h3></div></div></div><p></p><p>When the number of elements for each trajectory varies, and one can control the order of writing, one can use the contiguous ragged array representation. The canonical use case for this is when rewriting raw data, and you expect that the common read pattern will be to read all the data from each trajectory.</p><p></p><div class="example"><a name="Example%20H.4.3.1"></a><p class="title"><b>Example H.14. Trajectories recording atmospheric composition in the contiguous ragged array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = 3443;
      trajectory = 77 ;
   
   variables:
      char trajectory(trajectory, name_strlen) ;
            trajectory:cf_role = "trajectory_id";
      int rowSize(trajectory) ;
          rowSize:long_name = "number of obs for this trajectory " ;
          rowSize:sample_dimension = "obs" ;
   
      double time(obs) ; 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(obs) ; 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(obs) ; 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ;
      float z(obs) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ; 
           z:axis = "Z" ; 
   
      float O3(obs) ; 
          O3:standard_name = &#8220;mass_fraction_of_ozone_in_air&#8221;;
          O3:long_name = "ozone concentration" ;
          O3:units = "1e-9" ;
          O3:coordinates = "time lon lat z" ;
   
      float NO3(obs) ; 
          NO3:standard_name = &#8220;mass_fraction_of_nitrate_radical_in_air&#8221;;
          NO3:long_name = "NO3 concentration" ;
          NO3:units = "1e-9" ;
          NO3:coordinates = "time lon lat z" ;
   
   attributes:
      :featureType = "trajectory";</pre></div></div><br class="example-break"><p></p><p>The O3(o) and NO3(o) data are associated with the coordinate values time(o), lat(o), lon(o), and alt(o). All elements for one trajectory are contiguous along the sample dimension. The sample dimension (obs) may be the unlimited dimension or not. All variables that have the instance dimension (trajectory) as their single dimension are considered to be information about that trajectory. </p><p></p><p>The count variable (row_size) contains the number of elements for each trajectory, and is identified by having an attribute with name "sample_dimension" whose value is the sample dimension being counted. It must have the trajectory dimension as its single dimension, and must be type integer. The elements are associated with the trajectories using the same algorithm as in H.2.4.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9895520"></a>H.4.4. Indexed ragged array representation of trajectories</h3></div></div></div><p></p><p>When the number of elements at each trajectory vary, and the elements cannot be written in order, one can use the indexed ragged array representation. The canonical use case is when writing real-time data streams that contain reports from many trajectories. The data can be written as it arrives; if the flatsample dimension is the unlimited dimension, this allows data to be appended to the file. </p><p></p><div class="example"><a name="Example%20H.4.4.1"></a><p class="title"><b>Example H.15. Trajectories recording atmospheric composition in the indexed ragged array representation. </b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = UNLIMITED ;
      trajectory = 77 ;
   
   variables:
      char trajectory(trajectory, name_strlen) ;
          trajectory:cf_role = "trajectory_id";
   
      int trajectory_index(obs) ;
          trajectory_index:long_name = "index of trajectory this obs belongs to " ;
          trajectory_index:instance_dimension= "trajectory" ;
      double time(obs) ; 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(obs) ; 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(obs) ; 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ;
      float z(obs) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ;
          z:axis = "Z" ;   
   
      float O3(obs) ; 
          O3:standard_name = &#8220;mass_fraction_of_ozone_in_air&#8221;;
          O3:long_name = "ozone concentration" ;
          O3:units = "1e-9" ;
          O3:coordinates = "time lon lat z" ;
   
      float NO3(obs) ; 
          NO3:standard_name = &#8220;mass_fraction_of_nitrate_radical_in_air&#8221;;
          NO3:long_name = "NO3 concentration" ;
          NO3:units = "1e-9" ;
          NO3:coordinates = "time lon lat z" ;
   
   attributes:
      :featureType = "trajectory";</pre></div></div><br class="example-break"><p></p><p>The O3(o) and NO3(o) data are associated with the coordinate values time(o), lat(o), lon(o), and alt(o). All elements for one trajectory will have the same trajectory index value. The sample dimension (obs) may be the unlimited dimension or not. </p><p></p><p>The index variable (trajectory_index) is identified by having an attribute with name of "instance_dimension" whose value is the trajectory dimension name. It must have the sample dimension as its single dimension, and must be type integer. Each value in the trajectory_index variable is the zero-based trajectory index that the element belongs to. The elements are associated with the trajectories using the same algorithm as in H.2.5. </p><p> </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9903584"></a>H.5. Time Series of Profiles</h2></div></div></div><p></p><p>When profiles are taken repeatedly at a station, one gets a time series of profiles (see also section H.2 for discussion of stations and time series). The resulting collection of profiles is called a timeSeriesProfile. A data variable may contain a collection of such timeSeriesProfile features, one feature per station. The instance dimension in the case of a timeSeriesProfile is also referred to as the <span class="bold"><strong>station dimension</strong></span>. The instance variables, which have just this dimension, including latitude and longitude for example, are also referred to as <span class="bold"><strong>station variables</strong></span> and are considered to contain information describing the stations. The station variables may contain missing values. This allows one to reserve space for additional stations that may be added at a later time, as discussed in section 9.6. In addition,</p><p></p><div class="itemizedlist"><ul type="disc"><li>
         It is strongly recommended that there should be a station variable (which may be of any type) with <code class="varname">cf_role</code> attribute "<code class="varname">timeseries_id</code>", whose values uniquely identify the stations.
      </li><li>
         It is recommended that there should be station variables with standard_name attributes "<code class="varname">platform_name</code>", "<code class="varname">surface_altitude</code>" and &#8220;<code class="varname">platform_id</code>&#8221; when applicable.
      </li></ul></div><p></p><p>TimeSeriesProfiles are more complicated than timeSeries because there are two element dimensions (profile and vertical). Each time series has a number of profiles from different times as its elements, and each profile has a number of data from various levels as its elements. It is strongly recommended that there always be a variable (of any data type) with the profile dimension and the <code class="varname">cf_role</code> attribute "<code class="varname">profile_id</code>", whose values uniquely identify the profiles.</p><p></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9913136"></a>H.5.1. Multidimensional array representations of time series profiles</h3></div></div></div><p></p><p>When storing time series of profiles at multiple stations in the same data variable, if there are the same number of time points for all timeSeries, and the same number of vertical levels for every profile, one can use the multidimensional array representation: </p><p></p><div class="example"><a name="Example%20H.5.1.1"></a><p class="title"><b>Example H.16. Time series of atmospheric sounding profiles from a set of locations stored in a multidimensional array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      station = 22 ;
      profile = 3002 ;
      z = 42 ;
   
   variables:
      float lon(station) ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat(station) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      char station_name(station, name_strlen) ;
          station_name:cf_role = "timeseries_id" ;
          station_name:long_name = "station name" ;
      int station_info(station) ;
          station_name:long_name = "some kind of station info" ;
   
      float alt(station, profile , z) ; 
          alt:standard_name = &#8220;altitude&#8221;;
          alt:long_name = "height above mean sea level" ;
          alt:units = "km" ;
          alt:positive = "up" ; 
           alt:axis = "Z" ;   
   
      double time(station, profile ) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
   
      float pressure(station, profile , z) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat alt" ;
   
      float temperature(station, profile , z) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat alt" ;
   
      float humidity(station, profile , z) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat alt" ;
   
   attributes:
    :featureType = "timeSeriesProfile";</pre></div></div><br class="example-break"><p></p><p>The pressure(i,p,o), temperature(i,p,o), and humidity(i,p,o) data for element o of profile p at station i are associated with the coordinate values time(i,p), z(i,p,o), lat(i), and lon(i). Any of the three dimensions could be the netCDF unlimited dimension, if it might be useful to be able enlarge it.</p><p></p><p>If all of the profiles at any given station have the same set of vertical coordinates values, the vertical auxiliary coordinate variable could be dimensioned alt(station, z). If all the profiles have the same set of vertical coordinates, the vertical auxiliary coordinate variable could be one-dimensional alt(z), or replaced by a one-dimensional coordinate variable z(z), provided the values are ordered monotonically. In the latter case, listing the vertical coordinate variable in the coordinates attribute is optional.</p><p></p><p>If the profiles are taken at all stations at the same set of times, the time auxiliary coordinate variable could be one-dimensional time(profile), or replaced by a one-dimensional coordinate variable time(time), where the size of the time dimension is now equal to the number of profiles at each station. In the latter case, listing the time coordinate variable in the coordinates attribute is optional.</p><p></p><p>If there is only a single set of levels and a single set of times, the multidimensional array representation is formally orthogonal:</p><p></p><div class="example"><a name="Example%20H.5.1.2"></a><p class="title"><b>Example H.17. Time series of atmospheric sounding profiles from a set of locations stored in an orthogonal multidimensional array representation. </b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
     station = 10 ;  // measurement locations
     pressure = 11 ; // pressure levels
     time = UNLIMITED ;
   variables:
     float humidity(time,pressure,station) ;
       humidity:standard_name = &#8220;specific_humidity&#8221; ;
       humidity:coordinates = "lat lon" ;
     double time(time) ; 
       time:standard_name = "time";
       time:long_name = "time of measurement" ;
       time:units = "days since 1970-01-01 00:00:00" ;
     float lon(station) ;
       lon:long_name = "station longitude";
       lon:units = "degrees_east";
     float lat(station) ;
       lat:long_name = "station latitude" ;
       lat:units = "degrees_north" ;
     float pressure(pressure) ; 
       pressure:standard_name = "air_pressure" ;
       pressure:long_name = "pressure" ;
       pressure:units = "hPa" ;
       pressure:axis = "Z" ;</pre></div></div><br class="example-break"><p></p><p><code class="varname">humidity(p,o,i)</code> is associated with the coordinate values <code class="varname">time(p)</code>, <code class="varname">pressure(o)</code>, <code class="varname">lat(i)</code>, and <code class="varname">lon(i)</code>. The number of profiles equals the number of times.</p><p>At the cost of some wasted space, the multidimensional array representation also allows one to have a variable number of profiles for different stations, and varying numbers of levels for different profiles. In these cases, any unused elements of the data and auxiliary coordinate variables must contain missing data values (section 9.6).</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9782384"></a>H.5.2. Time series of profiles at a single station</h3></div></div></div><p></p><p>If there is only one station in the data variable, there is no need for the station dimension:</p><p></p><div class="example"><a name="Example%20H.5.2.1"></a><p class="title"><b>Example H.18. Time series of atmospheric sounding profiles from a single location stored in a multidimensional array representation. </b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      profile = 30 ;
      z = 42 ;
   
   variables:
      float lon ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      char station_name(name_strlen) ;
          station_name:cf_role = "timeseries_id" ;
          station_name:long_name = "station name" ;
      int station_info;
          station_name:long_name = "some kind of station info" ;
   
      float alt(profile , z) ; 
          alt:standard_name = &#8220;altitude&#8221;;
          alt:long_name = "height above mean sea level" ;
          alt:units = "km" ;
          alt:axis = "Z" ;   
          alt:positive = "up" ; 
   
      double time(profile ) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
   
      float pressure(profile , z) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat alt" ;
   
      float temperature(profile , z) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat alt" ;
   
      float humidity(profile , z) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat alt" ;
   
   attributes:
    :featureType = "timeSeriesProfile";</pre></div></div><br class="example-break"><p></p><p>The pressure(p,o), temperature(p,o), and humidity(p,o) data for element o of profile p are associated with the coordinate values time(p), alt(p,o), lat, and lon. If all the profiles have the same set of vertical coordinates, the vertical auxiliary coordinate variable could be one-dimensional alt(z), or replaced by a one-dimensional coordinate variable z(z), provided the values are ordered monotonically. In the latter case, listing the vertical coordinate variable in the coordinates attribute is optional.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9791328"></a>H.5.3. Ragged array representation of time series profiles</h3></div></div></div><p></p><p>When the number of profiles and levels for each station varies, one can use a ragged array representation. Each of the two element dimensions (time and vertical) could in principle be stored either contiguous or indexed, but this convention supports only one of the four possible choices. This uses the contiguous ragged array representation for each profile (9.5.43.3), and the indexed ragged array representation to organise the profiles into time series (9.3.54). The canonical use case is when writing real-time data streams that contain profiles from many stations, arriving randomly, with the data for each entire profile written all at once. </p><p></p><div class="example"><a name="Example%20H.5.3.1"></a><p class="title"><b>Example H.19. Time series of atmospheric sounding profiles from a set of locations stored in a ragged array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = UNLIMITED ;
      profiles = 1420 ;
      stations = 42;
   
   variables:
      float lon(station) ; 
          lon:standard_name = "longitude";
          lon:long_name = "station longitude";
          lon:units = "degrees_east";
      float lat(station) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
      float alt(station) ;
          alt:long_name = "altitude above MSL" ;
          alt:units = "m" ;
      char station_name(station, name_strlen) ;
          station_name:long_name = "station name" ;
          station_name:cf_role = "timeseries_id";
      int station_info(station) ;
          station_info:long_name = "some kind of station info" ;
   
      int profile(profile) ;
          profile:cf_role = "profile_id";
      double time(profile); 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      int station_index(profile) ;
          station_index:long_name = "which station this profile is for" ;
          station_index:instance_dimension = "station" ;
      int row_size(profile) ;
          row_size:long_name = "number of obs for this profile " ;
          row_size:sample_dimension = "obs" ;
   
      float z(obs) ; 
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:axis = "Z" ;   
           z:positive = "up" ;
   
      float pressure(obs) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat z" ;
   
      float temperature(obs) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat z" ;
   
      float humidity(obs) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat z" ;
   
   attributes:
      :featureType = "timeSeriesProfile";</pre></div></div><br class="example-break"><p></p><p>The pressure(o), temperature(o), and humidity(o) data for element o of profile p at station i are associated with the coordinate values time(p), z(o), lat(i), and lon(i).</p><p></p><p>The index variable (station_index) is identified by having an attribute with name of instance_dimension whose value is the instance dimension name (station in this example). The index variable must have the profile dimension as its sole dimension, and must be type integer. Each value in the index variable is the zero-based station index that the profile belongs to i.e. profile p belongs to station i=station_index(p), as in section H.2.5.</p><p>The count variable (row_size) contains the number of elements for each profile, which must be written contiguously. The count variable is identified by having an attribute with name sample_dimension whose value is the sample dimension (obs in this example) being counted. It must have the profile dimension as its sole dimension, and must be type integer. The number of elements in profile p is recorded in row_size(p), as in section H.2.4. The sample dimension need not be the netCDF unlimited dimension,  though it commonly is.</p><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp9970000"></a>H.6. Trajectory of Profiles</h2></div></div></div><p></p><p>When profiles are taken along a trajectory, one gets a collection of profiles called a trajectoryProfile. A data variable may contain a collection of such trajectoryProfile features, one feature per trajectory. The instance dimension in the case of a trajectoryProfile is also referred to as the <span class="bold"><strong>trajectory dimension</strong></span>. The instance variables, which have just this dimension, are also referred to as <span class="bold"><strong>trajectory variables</strong></span> and are considered to contain information describing the trajectories. The trajectory variables may contain missing values. This allows one to reserve space for additional trajectories that may be added at a later time, as discussed in section 9.6. TrajectoryProfiles are more complicated than trajectories because there are two element dimensions. Each trajectory has a number of profiles as its elements, and each profile has a number of data from various levels as its elements. It is strongly recommended that there always be a variable (of any data type) with the profile dimension and the <code class="varname">cf_role</code> attribute "<code class="varname">profile_id</code>", whose values uniquely identify the profiles.</p><p></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9974768"></a>H.6.1. Multidimensional array representation of trajectory profiles</h3></div></div></div><p></p><p>If there are the same number of profiles for all trajectories, and the same number of vertical levels for every profile, one can use the multidimensional representation:</p><p></p><div class="example"><a name="Example%20H.6.1.1"></a><p class="title"><b>Example H.20. Time series of atmospheric sounding profiles along a set of trajectories stored in a multidimensional array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      trajectory = 22 ;
      profile = 33;
      z = 42 ;
   
   variables:
      int trajectory (trajectory ) ;
          trajectory:cf_role = "trajectory_id" ;
   
      float lon(trajectory, profile) ; 
          lon:standard_name = "longitude";
          lon:units = "degrees_east";
      float lat(trajectory, profile) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
   
      float alt(trajectory, profile , z) ; 
          alt:standard_name = &#8220;altitude&#8221;;
          alt:long_name = "height above mean sea level" ;
          alt:units = "km" ;
          alt:positive = "up" ; 
          alt:axis = "Z" ;   
   
      double time(trajectory, profile ) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
   
      float pressure(trajectory, profile , z) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat alt" ;
   
      float temperature(trajectory, profile , z) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat alt" ;
   
      float humidity(trajectory, profile , z) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat alt" ;
   
   attributes:
    :featureType = "trajectoryProfile";</pre></div></div><br class="example-break"><p></p><p>The pressure(i,p,o), temperature(i,p,o), and humidity(i,p,o) data for element o of profile p along trajectory i are associated with the coordinate values time(i,p), alt(i,p,o), lat(i,p), and lon(i,p). Any of the three dimensions could be the netCDF unlimited dimension, if it might be useful to be able enlarge it. </p><p></p><p>If all of the profiles along any given trajectory have the same set of vertical coordinates values, the vertical auxiliary coordinate variable could be dimensioned alt(trajectory, z). If all the profiles have the same set of vertical coordinates, the vertical auxiliary coordinate variable could be one-dimensional alt(z), or replaced by a one-dimensional coordinate variable z(z), provided the values are ordered monotonically. In the latter case, listing the vertical coordinate variable in the coordinates attribute is optional.</p><p></p><p>If the profiles are taken along all the trajectories at the same set of times, the time auxiliary coordinate variable could be one-dimensional time(profile), or replaced by a one-dimensional coordinate variable time(time), where the size of the time dimension is now equal to the number of profiles along each trajectory. In the latter case, listing the time coordinate variable in the coordinates attribute is optional.</p><p></p><p>At the cost of some wasted space, the multidimensional array representation also allows one to have a variable number of profiles for different trajectories, and varying numbers of levels for different profiles. In these cases, any unused elements of the data and auxiliary coordinate variables must contain missing data values (section 9.6).</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9986752"></a>H.6.2. Profiles along a single trajectory</h3></div></div></div><p></p><p>If there is only one trajectory in the data variable, there is no need for the trajectory dimension: </p><p></p><div class="example"><a name="Example%20H.6.2.1"></a><p class="title"><b>Example H.21. Time series of atmospheric sounding profiles along a trajectory stored in a multidimensional array representation.</b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      profile = 33;
      z = 42 ;
   
   variables:
      int trajectory;
          trajectory:cf_role = "trajectory_id" ;
   
      float lon(profile) ; 
          lon:standard_name = "longitude";
          lon:units = "degrees_east";
      float lat(profile) ; 
          lat:standard_name = "latitude";
          lat:long_name = "station latitude" ;
          lat:units = "degrees_north" ;
   
      float alt(profile, z) ; 
          alt:standard_name = &#8220;altitude&#8221;;
          alt:long_name = "height above mean sea level" ;
          alt:units = "km" ;
          alt:positive = "up" ; 
           alt:axis = "Z" ;   
   
      double time(profile ) ; 
          time:standard_name = "time";
          time:long_name = "time of measurement" ;
          time:units = "days since 1970-01-01 00:00:00" ;
          time:missing_value = -999.9;
   
      float pressure(profile, z) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat alt" ;
   
      float temperature(profile, z) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat alt" ;
   
      float humidity(profile, z) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat alt" ;
   
   attributes:
    :featureType = "trajectoryProfile";</pre></div></div><br class="example-break"><p></p><p>The pressure(p,o), temperature(p,o), and humidity(p,o) data for element o of profile p are associated with the coordinate values time(p), alt(p,o), lat(p), and lon(p). If all the profiles have the same set of vertical coordinates, the vertical auxiliary coordinate variable could be one-dimensional alt(z), or replaced by a one-dimensional coordinate variable z(z), provided the values are ordered monotonically. In the latter case, listing the vertical coordinate variable in the coordinates attribute is optional.</p><p></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="idp9993472"></a>H.6.3. Ragged array representation of trajectory profiles</h3></div></div></div><p></p><p>When the number of profiles and levels for each trajectory varies, one can use a ragged array representation. Each of the two element dimensions (along a projectory, within a profile) could in principle be stored either contiguous or indexed, but this convention supports only one of the four possible choices. This uses the contiguous ragged array representation for each profile (9.3.3), and the indexed ragged array representation to organise the profiles into time series (9.3.4). The canonical use case is when writing real-time data streams that contain profiles from many trajectories, arriving randomly, with the data for each entire profile written all at once.</p><p></p><div class="example"><a name="Example%20H.6.3.1"></a><p class="title"><b>Example H.22. Time series of atmospheric sounding profiles along a set of trajectories stored in a ragged array representation. </b></p><div class="example-contents"><p></p><pre class="programlisting">
   dimensions:
      obs = UNLIMITED ;
      profiles = 142 ;
      section = 3;
   
   variables:
      int trajectory(trajectory) ;
          section:standard_namecf_role = "trajectory_id" ;
   
      double time(profile); 
          time:standard_name = "time";
          time:long_name = "time" ;
          time:units = "days since 1970-01-01 00:00:00" ;
      float lon(profile); 
          lon:standard_name = "longitude";
          lon:long_name = "longitude" ;
          lon:units = "degrees_east" ;
      float lat(profile); 
          lat:standard_name = "latitude";
          lat:long_name = "latitude" ;
          lat:units = "degrees_north" ; 
      int row_size(profile) ;
          row_size:long_name = "number of obs for this profile " ;
          row_size:sample_dimension = "obs" ;
      int trajectory_index(profile) ;
          trajectory_index:long_name = "which trajectory this profile is for" ;
          trajectory_index:instance_dimension= "trajectory" ;
      
       float z(obs) ;
          z:standard_name = &#8220;altitude&#8221;;
          z:long_name = "height above mean sea level" ;
          z:units = "km" ;
          z:positive = "up" ;
          z:axis = "Z" ;   
   
      float pressure(obs) ; 
          pressure:standard_name = "air_pressure" ;
          pressure:long_name = "pressure level" ;
          pressure:units = "hPa" ;
          pressure:coordinates = "time lon lat z" ;
   
      float temperature(obs) ; 
          temperature:standard_name = "surface_temperature" ;
          temperature:long_name = "skin temperature" ;
          temperature:units = "Celsius" ;
          temperature:coordinates = "time lon lat z" ;
   
      float humidity(obs) ; 
          humidity:standard_name = "relative_humidity" ;
          humidity:long_name = "relative humidity" ;
          humidity:units = "%" ;
          humidity:coordinates = "time lon lat z" ;
   
   attributes:
      :featureType = "trajectoryProfile";</pre></div></div><br class="example-break"><p></p><p>The pressure(o), temperature(o), and humidity(o) data for element o of profile p along trajectory i are associated with the coordinate values time(p), z(o), lat(p), and lon(p).</p><p>The index variable (trajectory_index) is identified by having an attribute with name of instance_dimension whose value is the instance dimension name (trajectory in this example). The index variable must have the profile dimension as its sole dimension, and must be type integer. Each value in the index variable is the zero-based trajectory index that the profile belongs to i.e. profile p belongs to trajectory i=trajectory_index(p), as in section H.2.5. </p><p>The count variable (row_size) contains the number of elements for each profile, which must be written contiguously. The count variable is identified by having an attribute with name sample_dimension whose value is the sample dimension (obs in this example) being counted. It must have the profile dimension as its sole dimension, and must be type integer. The number of elements in profile p is recorded in row_size(p), as in section H.2.4. The sample dimension need not be the netCDF unlimited dimension,  though it commonly is.</p><p></p></div></div><p></p></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="idp10201280"></a>Bibliography</h2></div></div></div><div class="bibliodiv"><h3 class="title">References</h3><div class="biblioentry"><a name="coards"></a><p>[<abbr class="abbrev">COARDS</abbr>] <span class="title"><i><a class="ulink" href="http://ferret.wrc.noaa.gov/noaa_coop/coop_cdf_profile.html" target="_top">
      Conventions for the standardization of NetCDF Files </a></i>. </span><span class="publisher"><span class="publishername">Sponsored by the "Cooperative Ocean/Atmosphere Research
        Data Service," a NOAA/university cooperative for the sharing and
        distribution of global atmospheric and oceanographic research data
        sets. </span></span><span class="date">May 1995. </span></p></div><div class="biblioentry"><a name="fgdc"></a><p>[<abbr class="abbrev">FGDC</abbr>] <span class="title"><i><a class="ulink" href="http://www.fgdc.gov/standards/projects/FGDC-standards-projects/metadata/base-metadata/v2_0698.pdf" target="_top">Content
      Standard for Digital Geospatial Metadata</a></i>. </span><span class="publisher"><span class="publishername">Federal Geographic Data Committee,
        FGDC-STD-001-1998. </span></span></p></div><div class="biblioentry"><a name="netcdf"></a><p>[<abbr class="abbrev">NetCDF</abbr>] <span class="title"><i><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/index.html" target="_top"> NetCDF
      Software Package</a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/index.html" target="_top"> NetCDF Software
      Package</a></font></i>. </span><span class="publisher"><span class="publishername">UNIDATA Program Center of the University Corporation
        for Atmospheric Research. </span></span></p></div><div class="biblioentry"><a name="nug"></a><p>[<abbr class="abbrev">NUG</abbr>] <span class="title"><i><font style="background-color:#ffff88; text-decoration:line-through"> <a class="ulink" href="http://www.unidata.ucar.edu/packages/netcdf/guidef/" target="_top"> NetCDF User's
      Guide for Fortran: An Access Interface for Self-Describing Portable
      Data; version 3 </a></font> <font style="background-color:#ffccff"> <a class="ulink" href="http://www.unidata.ucar.edu/netcdf/docs/netcdf.html" target="_top"> NetCDF User's
      Guide for Fortran: An Access Interface for Self-Describing Portable
      Data; version 3 </a></font></i>. </span><span class="authorgroup"><span class="firstname">Russ</span> <span class="surname">Rew</span>, <span class="firstname">Glenn</span> <span class="surname">Davis</span>, <span class="firstname">Steve</span> <span class="surname">Emmerson</span>, and <span class="firstname">Harvey</span> <span class="surname">Davies</span>. </span><span class="date">June 1997. </span></p></div><div class="biblioentry"><a name="OGC_CTS"></a><p>[<abbr class="abbrev"><font style="background-color:#ffccff">OGC_CTS</font></abbr>] <span class="title"><i><font style="background-color:#ffccff">OpenGIS Coordinate Transformation
      Service Implementation Specification. OGC document
      01-009.</font></i>. </span><span class="bibliosource"><font style="background-color:#ffccff">http://www.opengeospatial.org/standards/ct</font>. </span><span class="date"><font style="background-color:#ffccff">12 January 2001</font>. </span></p></div><div class="biblioentry"><a name="ogp-epsg"></a><p>[<abbr class="abbrev"><font style="background-color:#ffccff">OGP/EPSG</font></abbr>] <span class="title"><i><font style="background-color:#ffccff"><a class="ulink" href="http://www.epsg.org" target="_top">OGP
      Surveying &amp; Positioning Committee</a> and <a class="ulink" href="http://www.epsg-registry.org" target="_top">EPSG Geodetic Parameter
      Registry</a></font></i>. </span></p></div><div class="biblioentry"><a name="ogp-epsg_gn7_2"></a><p>[<abbr class="abbrev"><font style="background-color:#ffccff">OGP/EPSG_GN7_2</font></abbr>] <span class="title"><i><font style="background-color:#ffccff"><a class="ulink" href="http://www.epsg.org" target="_top">OGP
      Surveying and Positioning Guidance Note 7, part 2: Coordinate
      Conversions and Transformations including
      Formulas</a></font></i>. </span></p></div><div class="biblioentry"><a name="sch02"></a><p>[<abbr class="abbrev">SCH02</abbr>] <span class="biblioset"><span class="authorgroup"><span class="firstname">C</span> <span class="surname">Schaer</span>, <span class="firstname">D</span> <span class="surname">Leuenberger</span>, and <span class="firstname">O</span> <span class="surname">Fuhrer</span>. </span><span class="date">2002. </span>&#8220;A new terrain-following vertical coordiante formulation for
        atmospheric prediction models&#8221;. <span class="biblioset"><i>Monthly Weather Review</i>. <span class="volumenum">130. </span></span><span class="pagenums">2459-2480. </span></span></p></div><div class="biblioentry"><a name="snyder"></a><p>[<abbr class="abbrev"><font style="background-color:#ffccff">Snyder</font></abbr>] <span class="title"><i><font style="background-color:#ffccff"><a class="ulink" href="http://pubs.er.usgs.gov/usgspubs/pp/pp1395" target="_top"> Map Projections: A
      Working Manual </a></font></i>. </span><span class="publisher"><span class="publishername"><font style="background-color:#ffccff">USGS Professional Paper
        1395</font>. </span></span></p></div><div class="biblioentry"><a name="udunits"></a><p>[<abbr class="abbrev">UDUNITS</abbr>] <span class="title"><i><a class="ulink" href="http://www.unidata.ucar.edu/packages/udunits/" target="_top">
      UDUNITS Software Package </a></i>. </span><span class="publisher"><span class="publishername">UNIDATA Program Center of the University Corporation
        for Atmospheric Research. </span></span></p></div><div class="biblioentry"><a name="w3c"></a><p>[<abbr class="abbrev">W3C</abbr>] <span class="title"><i><a class="ulink" href="http://www.w3.org/" target="_top">World Wide Web Consortium
      (W3C)</a></i>. </span></p></div><div class="biblioentry"><a name="xml"></a><p>[<abbr class="abbrev">XML</abbr>] <span class="title"><i><a class="ulink" href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_top">
      Extensible Markup Language (XML) 1.0 </a></i>. </span><span class="authorgroup"><span class="firstname">T.</span> <span class="surname">Bray</span>, <span class="firstname">J.</span> <span class="surname">Paoli</span>, and <span class="firstname">C.M.</span> <span class="surname">Sperberg-McQueen</span>. </span><span class="date">10 February 1998. </span></p></div></div></div></div></body></html>
