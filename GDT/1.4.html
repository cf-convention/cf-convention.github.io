  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML>
<META NAME="GENERATOR" CONTENT="TtH 1.96">
                                                                           
<title> GDT netCDF conventions for climate data, version 1.4</title>
 
<H1 align=center>GDT netCDF conventions for climate data, version 1.4 </H1>

<H3 align=center>Jonathan Gregory<sup>1</sup>, Bob Drach<sup>2</sup>, Simon Tett<sup>1</sup> and
Karl Taylor<sup>2</sup><br>
<font size="+0">(1) Hadley Centre, UK Met Office;
(2) PCMDI, LLNL</font> </H3>

<H3 align=center>15th September 1999 </H3>

<p>
        <H2><A NAME="tth_sEc1">
1</A>&nbsp;&nbsp;Purposes</H2>

<p>
This standard defines a set of conventions adopted in order to promote the
interchange and sharing of files created with the netCDF Application
Programmer Interface (API). The standard is based upon version 2.4 of
netCDF. Documentation of the netCDF API may be found in the ``NetCDF
Users' Guide'', Version 2.4, February 1996, available from
<a href="http://www.unidata.ucar.edu/packages/netcdf/"><tt>http://www.unidata.ucar.edu/packages/netcdf/</tt></a>
or via anonymous ftp at
<tt>ftp.unidata.ucar.edu</tt>.
The standard is named ``GDT'' from the names of the authors.

<p>
This standard is intended for use with climate data,
and was designed with data generated by GCMs particularly in mind.
We recognise that there are limits to what a standard can practically cover;
we restrict ourselves to issues which we believe to be of common and
frequent concern in the design of climate metadata.
Although this is specifically a netCDF standard,
we feel that most of the ideas are of wider application.
Our main purpose is to propose a clear, adequate and flexible definition
of the metadata needed for climate data.
The metadata objects could be contained in file formats other than netCDF.
Interconversion of the metadata between files of different formats
will be facilitated if they are based on similar ideas.

<p>
This standard is mostly additional to the conventions sponsored by COARDS
(<tt>ftp://ftp.unidata.ucar.edu/pub/netcdf/Conventions/COARDS</tt>).
In addition, all Unidata recommendations are supported here
unless noted to the contrary.
Comments indicate the places where there are differences
between the standards.
Comments given in <i>emphasised type</i>
and CDL examples given in <i><i><tt>slanted typewriter type</i></tt></i>
are not part of the standard.
Note that examples typically show only the details relevant to the
point under discussion,
and hence may be incomplete with respect to the provisions
of the complete standard.

<p>
Successful transmission of data
depends upon the receiver of the file having
software that will correctly interpret it. For this reason, a
strategy that is as conservative as possible in the use of attributes
and encoding techniques will best promote portability of data.

<p>
This standard also refers to the udunits standard
supported by Unidata.
The udunits package is available via anonymous
ftp at <tt>ftp.unidata.ucar.edu</tt>.
See section <A href="#units">11</A> for details of how the package
is used by this convention to define units for physical quantities.

<p>
<i>Useful comments and suggestions from
John Sheldon, Jan Polcher, Bryant McAvaney, Harvey Davies,
John Caron, Steve Hankin and contributors to the netCDF news group
have influenced the development of this standard.
We have made some changes to gain greater compatibility with 
the NCAR CSM netCDF standard.</i>

<p>

<em>This document makes occasional use of some mathematical symbols,
for instance ``<font face=symbol>s</font>'', which should appear as
a lower-case sigma. Under X, this may require you to add the following
to your X resources:<br><tt>
Netscape*documentFonts.charset*adobe-fontspecific:   iso-8859-1
</tt></em>


<p>
        <H2><A NAME="tth_sEc2">
2</A>&nbsp;&nbsp;Filename</H2>
NetCDF files should have the file name extension <tt>.nc</tt>.

<p>
        <H2><A NAME="tth_sEc3">
3</A>&nbsp;&nbsp;Data types</H2>
<A NAME="datatype">
</A>

<p>
The netCDF data types
<tt>char</tt>, <tt>short</tt>, <tt>long</tt>, <tt>float</tt>, and <tt>double</tt>
are all acceptable.
All numeric types are signed.
The <tt>byte</tt> data type, which is functionally identical to <tt>char</tt>,
is not recommended because its signedness is ambiguous in netCDF.
<i>The COARDS convention deprecates <i><tt>char</i></tt>, rather than <i><tt>byte</i></tt>.</i>

<p>
NetCDF does not support a character string type,
so these have to be represented as <tt>char</tt> arrays.
In this standard, we refer to them as type ``string''.
A string array must be implemented as a
two-dimensional character data variable,
serving as a vector of fixed-length strings,
the second dimension of its CDL declaration
<i>(leading dimension in terms of Fortran)</i>
being recorded as a dimension in the netCDF file.

<p>
        <H2><A NAME="tth_sEc4">
4</A>&nbsp;&nbsp;Attributes</H2>
<A NAME="attributes">
</A>

<p>
This standard describes many attributes
(some mandatory, others optional),
but a file may also contain non-standard attributes.
Such attributes do not represent a violation of this standard.
Application programs should ignore attributes that they do not recognise
or which are irrelevant for their purposes.
Conventional attribute names should be used wherever applicable.
Non-standard names should be as meaningful as possible.
Before introducing an attribute, consideration should be given to
whether the information would be better represented as a variable.
In general, if a proposed attribute
requires ancillary data to describe it,
is multidimensional, requires any of the defined netCDF
dimensions to index its values,
or requires a significant amount of storage,
a variable should be used instead.
When this standard defines string attributes which make take
various prescribed values, the possible values are given in lower case.
However, applications programs should not be sensitive to case
in these attributes.
Several string attributes are defined by this standard to
contain ``blank-separated lists''.
Consecutive words in such a list are separated by one or more
adjacent spaces. The list may begin and end with any number of spaces.
<i>See Appendix&nbsp;A for a list of attributes described by this standard.</i>

<p>
        <H2><A NAME="tth_sEc5">
5</A>&nbsp;&nbsp;Global attributes</H2>
<A NAME="global">
</A>

<p>
The Unidata-standard attribute <tt>Conventions</tt>
is recommended to reference this standard, containing the
string <tt>"GDT 1.4"</tt>.
This standard is registered with Unidata under the name ``GDT''
in the directory <tt>ftp://ftp.unidata.ucar.edu/pub/netcdf/Conventions</tt>
and is available from
<a href="http://www-pcmdi.llnl.gov/drach/GDT_convention.html"><tt>http://www-pcmdi.llnl.gov/drach/GDT_convention.html</tt></a> and

<a href="http://www.met-office.gov.uk/sec5/CR_div/GDT_convention.html"><tt>http://www.met-office.gov.uk/sec5/CR_div/GDT_convention.html</tt></a>.

<p>
The <tt>float</tt> attribute <tt>appendices</tt> is recommended to record
the version number of the appendices to this standard used by the
application which generated the file (see section <A href="#quantity">12</A>).
<i>This information could perhaps be recorded in the <i><tt>Conventions</i></tt>
attribute, but having a separate attribute 
for it will allow applications to extract the information
without having to parse a string.</i>
The string attribute <tt>quantity_table</tt> should be used to
record the URL of the quantity table (see section <A href="#quantity">12</A>).
If this attribute is a null string, it is assumed that Appendix&nbsp;D was used,
at the version specified by <tt>appendices</tt>.

<p>
The string attribute <tt>comment</tt> may be used to record any
extra information about the file.
Additional attributes to describe the file may be included as required.
<i>For example, GCM output might include an attribute 
to name the model integration.</i>

<p>
Although not mandatory,
the Unidata-standard attribute <tt>history</tt> is recommended to
record the evolution of the data contained within a netCDF
file. Applications which process netCDF data can append their
information to the <tt>history</tt> attribute.
The global <tt>history</tt> attribute is assumed to apply to all
data variables;
individual data variables may have their own <tt>history</tt> attributes
supplying additional information (see section&nbsp;<A href="#quantity">12</A>).

<p>
Use of the string attributes <tt>institution</tt> and
<tt>production</tt> is recommended.
The attribute
<tt>institution</tt> specifies who produced or supplied the data.
<i>We prefer this name to ``center'' or ``centre'' because the two
possible spellings could cause confusion.</i>
The attribute
<tt>production</tt> indicates how the data was produced.
If it was model-generated, <tt>production</tt> should name the model
and its version, as specifically as could be useful.
If it is observational, <tt>production</tt> should characterise it
<i>e.g.&nbsp;<i><tt>&#223urface observation"</i></tt> or <i><tt>"radiosonde"</i></tt>.</i>
The global <tt>institution</tt> and <tt>production</tt> attributes are taken to
apply to all data variables which do not have their own such attributes
(see section&nbsp;<A href="#quantity">12</A>).

<p>
The <tt>calendar</tt> attribute (see section <A href="#time">23</A>) may
be recorded as a global attribute.
The global <tt>calendar</tt>
attribute is interpreted as a default for all time axes.

<p>
        <H2><A NAME="tth_sEc6">
6</A>&nbsp;&nbsp;Variable names</H2>
<A NAME="variablenames">
</A>

<p>
Variable names should begin with a letter
and be composed of letters,
digits, and underscores.
Case is significant in netCDF names, but it is recommended that
names should not be distinguished purely by case
i.e.&nbsp;if case is disregarded, no two names should be the same.
It is also recommended that variable names should be obviously
meaningful, if possible, as this renders the file more effectively
self-describing.
However, nothing in this convention relies on the use
of particular names for variables.

<p>
        <H2><A NAME="tth_sEc7">
7</A>&nbsp;&nbsp;Data variables</H2>
<A NAME="datavariables">
</A>

<p>
The netCDF variables which contain the
physical data are referred to as ``data variables'',
also referred to as ``primary variables'' by Unidata.
Apart from the general naming rules for variables (above,
section <A href="#variablenames">6</A>),
the names of data variables are not standardised by these
conventions (since files may in general contain multiple
data variables of the same physical quantity).

<p>
        <H2><A NAME="tth_sEc8">
8</A>&nbsp;&nbsp;Coordinate variables</H2>
<A NAME="coordinates">
</A>

<p>
A one-dimensional netCDF variable
associated with a dimension of one or more data variables
is called a ``coordinate variable''.
A coordinate variable whose dimension name is identical to
its own name is referred to as a ``main coordinate variable''
in this standard,
when it is necessary to distinguish it
from other types of coordinate variable
(sections <A href="#component">17</A>, <A href="#associated">18</A>,
<A href="#bundles">19</A> and <A href="#boundary">20</A>).
Apart from the general naming rules for variables (above,
section <A href="#variablenames">6</A>),
the names of coordinate variables are not standardised by these
conventions (since files may in general contain multiple
coordinate variables of the same orientation).
The values in a main coordinate variable must be
strictly monotonic
(all values are different and either increasing or decreasing)
<i>because this assumption is frequently made by software</i>.

<p>
        <H2><A NAME="tth_sEc9">
9</A>&nbsp;&nbsp;Axes and dimensionality of a data variable</H2>
<A NAME="dimensionality">
</A>

<p>
A data variable may have any number of dimensions, including zero,
and the dimensions must all have different names.
<i>COARDS strongly recommends limiting the number to four,
but we wish to allow greater flexibility.</i>
The dimensions of the variable define the axes of the quantity it contains.
Dimensions other than those of space and time may be included.
<i>Several examples can be found in this document.
Components of vector or tensor quantities could be contained
in a single data variable by giving the variable a dimension over components.
While there exist advantages for manipulating such a variable in memory,
we see no strong advantage in introducing this complexity into the netCDF
description, and do not recommend it.</i>
Under certain circumstances, one may need more than one
dimension in a particular quantity
(see section <A href="#multipletime">28</A> concerning multiple time axes).
<i>For instance, a data variable containing a two-dimensional probability
density function might correlate the temperature at two different
vertical levels,
and hence would have temperature on both axes.</i>

<p>
If any or all of the
dimensions of a data variable have the interpretations
of ``date or time'' (<tt>T</tt>), ``height or depth'' (<tt>Z</tt>),
``latitude'' (<tt>Y</tt>), or ``longitude'' (<tt>X</tt>) then those
dimensions should appear in the relative order <tt>T</tt>, then <tt>Z</tt>,
then <tt>Y</tt>, then <tt>X</tt> in the CDL definition corresponding to the file.
<i>In terms of Fortran, this means <i><tt>X</i></tt> is the first dimension
of the array.</i> Non-spatiotemporal dimensions
should be placed to the left
of the spatiotemporal dimensions
<i>i.e.&nbsp;as trailing dimensions in terms of Fortran</i>.

<p>
<i>The reason for this convention is that these kinds of axes may
have special meanings to particular applications.
For instance, an application might want to plot a longitude-latitude map,
or integrate vertically, or extract a timeseries.
In the COARDS standard, the indication given by the order of dimensions
and information in the attributes of the coordinate variables
have to be used together to identify the required axes.
For compatibility with COARDS, we uphold all these conventions,
but we also introduce a new attribute to make the identification
straightforward and unambiguous, as follows.</i>

<p>
If the last four dimensions
do not have the interpretations <tt>TZYX</tt>
(in CDL order, omitting from the left if there are fewer than four dimensions),
an <tt>axis</tt> attribute should be attached to the data variable.
In other cases it is optional, but recommended.
This attribute is a <tt>char</tt> array of size equal to the dimensionality of the
data variable,
having one element for each dimension (in CDL order),
indicating the interpretation of that dimension.
The permitted characters are <tt>T</tt> <tt>Z</tt> <tt>Y</tt> and <tt>X</tt>,
with the meanings given above,
and <tt>-</tt> as a placeholder for a dimension which has none of these meanings.
Each permitted letter may appear no more than once in the array.
If a data variable has more than one dimension which could be given a certain
interpretation,
the <tt>axis</tt> attribute will therefore clarify which should be chosen.
Note that if there are multiple time axes (section <A href="#multipletime">28</A>),
of which only one is not collapsed,
this single ``climatological time'' axis would normally be the
designated <tt>T</tt>-axis.
<i>If the <i><tt>axis</i></tt> attribute is included,
the dimensions may be put in any order,
but this should be avoided if possible
because applications not able to use this attribute
may not process the data correctly.</i>

<p>

<p><br><i><b>Axes for an ordinary time-mean longitude-latitude-height
variable:</b>

<pre>
  dimensions:
    lat=18;
    lon=36;
    pressure=15;
    con_time=1;
  variables:
    float xwind(con_time,pressure,lat,lon); // order T Z Y X
      xwind:axis="TZYX";
    float lon(lon);
    float lat(lat);
    float pressure(pressure);
    float con_time(con_time);
</pre>
See sections <A href="#longitude">14</A>, <A href="#latitude">15</A>, <A href="#vertical">16</A>,
<A href="#time">23</A>
for details of longitude, latitude, vertical and time axes.
</i>
<p>
The coordinates of points within the data variable are
the simple ordered tuples formed by associating values from the
coordinate variables (section <A href="#coordinates">8</A>).
If a particular axis does not have a coordinate variable,
the coordinate values are assumed to be equal to their indices along
the axis, numbering from 0.

<p>
Dimensions may be of any size, including unity.
When a single value of some physical quantity applies to all the values
in a data variable,
the recommended means of attaching this information to the variable
is by use of a singleton dimension (a dimension of size unity)
with a one-element coordinate variable.
<i>The advantage of this method is that all the attributes of a coordinate
variable (quantity, components, boundaries, etc.) can be used to describe
the single-valued quantity.</i>
Singleton dimensions also result from contractions, described
in section <A href="#contractions">22</A>.

<p>

<p><br><i><b>Longitude-latitude field of temperature
on a pressure level:</b> This would use a
singleton pressure dimension to record the level, thus:

<pre>
  dimensions:
    lon=96;
    lat=72;
    pressure=1; // single-valued coordinate variable
  variables:
    float temperature(pressure,lat,lon); // axes in order Z Y X
      temperature:axis="ZYX";
    float pressure(pressure);
      pressure:long_name="pressure";
      pressure:units="kPa";
  data:
    pressure=50.0; // Pressure level of 50 kPa = 500 mbar
</pre>
The <i><tt>units</i></tt> and <i><tt>long_name</i></tt> attributes
are described in section <A href="#quantity">12</A>.
</i>
<p>

<p><br><i><b>Surface air temperature:</b> Surface meteorological
measurements are made at
a certain defined height e.g.&nbsp;1.5 m, which can be shown thus:

<pre>
  variables:
    float temperature(height,lat,lon);
      temperature:axis="ZYX";
      temperature:long_name="atmospheric temperature";
      temperature:units="K";
    float height(height);
      height:long_name="height above the surface";
      height:units="m";
  data:
    height=1.5;
</pre>
The explicit height should not be given if the surface of measurement
is included in the name of the quantity e.g. screen height.
</i>
<p>
        <H2><A NAME="tth_sEc10">
10</A>&nbsp;&nbsp;Coordinate systems</H2>
<A NAME="systems">
</A>

<p>
If the <tt>axis</tt> attribute indicates <tt>X</tt>- and <tt>Y</tt>-axes,
and these are in degrees of longitude and latitude respectively,
these axes constitute a longitude-latitude grid mapped onto the
Earth's surface, and areas of the <tt>XY</tt>-boxes may be calculated
on this assumption.

<p>
A coordinate system for the Earth's surface which is rectilinear
but
based on a polar axis other than the normal geographical axis is referred
to as a ``rotated grid''.
To describe rotated grids, a two-element <tt>float</tt> attribute
<tt>north_pole</tt> is attached to the data variable,
specifying the (longitude,latitude) coordinates of the rotated north pole.
If the attribute is absent and relevant,
it is assumed to have the value (0.,90.)&nbsp;i.e.&nbsp;the geographical north pole.

<p>
In some systems,
the axes covering the Earth's surface
do not define a rectilinear grid.
We do not wish necessarily to exclude non-rectilinear systems.
For the moment, this standard is undefined for these systems,
and we invite comments from potential users on the appropriate definition.
<i>The COARDS standard excludes non-rectilinear systems.
In principle, any coordinate system can be handled,
albeit clumsily, by replacing the relevant two or more axes by
by a single axis which indexes the points,
and providing associated coordinate variables to specify the coordinates,
point by point (see section <A href="#associated">18</A>).</i>

<p>
        <H2><A NAME="tth_sEc11">
11</A>&nbsp;&nbsp;Units</H2>
<A NAME="units">
</A>

<p>
The udunits package includes a
file <tt>udunits.dat</tt>, which lists collections of unit names. The names
given in the most recent version of this file
and their plural forms will be regarded as acceptable
unit names for this standard, with a few modifications which will be
listed in Appendix&nbsp;C to this standard.
<i>COARDS lists some modifications within the standard,
but we would prefer to put in place a means to allow future
modifications to be made easily.</i>
Users of this standard should not define their own units,
because this would make their files less portable;
requests for new units should be directed to Unidata.

<p>
The udunits package also defines a means for linear transformation
of units by a scale factor and an offset.
This convention is allowed when it is natural to express a unit in
such a form
<i>e.g.&nbsp;density of sea-water in
kg&nbsp;m<sup>-3</sup>
in excess of 1000
kg&nbsp;m<sup>-3</sup>,
which can be specified to udunits as <i><tt>"kg m-3 @ 1000"</i></tt>.
COARDS does not permit the use of this facility.</i>
This facility should not be used as a means of data compression,
for which an alternative is provided
(see section <A href="#pack">32</A>).

<p>
        <H2><A NAME="tth_sEc12">
12</A>&nbsp;&nbsp;Physical quantity of a variable</H2>
<A NAME="quantity">
</A>

<p>
These conventions standardise three string attributes for
specifying
the physical quantity of data and coordinate variables.

<p>
The <tt>units</tt> attribute is formatted as per the
recommendations in the Unidata udunits package
(see section <A href="#units">11</A>),
with extensions for time
(see section <A href="#absolutetime">25</A>).
Case is significant in the <tt>units</tt>.
This attribute is mandatory unless the quantity is dimensionless
(a pure number),
in which case the units may be given as a pure number.
<i>There are a few defined dimensionless units,
such as <i><tt>percent</i></tt>, but
there is no need for a wide variety of dimensionless units for quantities
like sea-ice concentration, cloud fraction, probability and so on;
this descriptive information is the <i><tt>long_name</i></tt> rather
than the <i><tt>units</i></tt>.
A scale factor and/or offset may be specified
quantity e.g.&nbsp;sea-ice concentration in tenths
may be given as <i><tt>units="0.1f"</i></tt>.
A dimensionless quantity with no scaling or offset
may have <i><tt>units="1.0f"</i></tt> or <i><tt>units=&#252;nity"</i></tt>.</i>

<p>
The <tt>long_name</tt> is a standard Unidata attribute
containing a descriptive name,
which should not specify the <tt>units</tt>.
This attribute is optional.

<p>
The <tt>quantity</tt> attribute identifies the quantity by
a description chosen from a defined list,
optionally with additional information enclosed in parentheses
<tt>()</tt>
if sufficient detail cannot be given by a standardised description.
The purpose of defining a list
is to allow users of data from different sources to decide which
quantities are comparable.
Case is not significant in the <tt>quantity</tt>.

<p>
We refer to the list of
possible quantities as the ``quantity table''.
The quantity table defines the <tt>quantity</tt> and a permissible unit
for each quantity.
Any legal and physically equivalent unit would be an acceptable
<tt>units</tt> attribute.
If both present,
the quantity and the <tt>units</tt> attribute must be consistent
according to the quantity table.
There are two options for a choice of quantity table.
One option is to use Appendix&nbsp;D of this standard,
which will be made available on the web.
In this case, the global <tt>quantity_table</tt> attribute should be
set to a null string.
Each quantity in Appendix&nbsp;D will be labelled with the version of the
appendices at which it was introduced,
enabling an application to deduce the complete set of
quantities which was available to the application which generated the file.
The other option is to produce a list of all
the possible <tt>quantity</tt> names,
giving for each one an acceptable unit and the name
of an equivalent quantity in Appendix&nbsp;D.
This list should be made available on the web,
and its URL recorded in the global <tt>quantity_table</tt> attribute.

<p>
The use of standardised quantities is optional.
The presence of the global <tt>quantity_table</tt> attribute implies that
this option is being followed.
The quantity name may optionally be recorded in the <tt>long_name</tt>
attribute if preferred (to avoid having identical <tt>long_name</tt>
and <tt>quantity</tt> attributes).
Therefore if an application which wishes to make use of quantities finds
that the <tt>quantity</tt> attribute is absent,
it should obtain the <tt>quantity</tt> from the <tt>long_name</tt> attribute.
<i>In the remainder of this document, <i><tt>quantity</i></tt> attributes
do not appear in the examples, but the <i><tt>long_name</i></tt> attributes could
serve to supply the <i><tt>quantity</i></tt> information.</i>

<p>

<p><br><i><b>Quantity attributes:</b>

<pre>
    float tempt(pressure,lat,lon);
      tempt:long_name="potential temperature";
      tempt:quantity="atmospheric potential temperature "
        "(after timestep)";
      tempt:units="K";
</pre>
<i><tt>"potential temperature"</i></tt> is the description which might be used
as the title of a plot.
<i><tt>&#228;tmospheric potential temperature"</i></tt> is the standard
quantity, and <i><tt>&#228;fter timestep"</i></tt> is additional information,
which a generic application can disregard.
</i>
<p>
<i>Whether two physical quantities are different or the same is often
not a question with a well-defined answer.
Certainly if they are the same, they must have the same unit, but
various quantities with the same unit may have to be distinguished
e.g.&nbsp;<i><tt>atmospheric potential temperature</i></tt> and <i><tt>soil temperature</i></tt>.
In practice,
the most specific description applicable should be used.
We intend to expand Appendix&nbsp;D on an ongoing basis
in response to requests by users of this standard,
since we cannot foresee all the possibilities,
and we will err on the side of expansion, rather than restriction,
when it is unclear whether a new quantity is needed.</i>

<p>
The <tt>subgrid</tt> attribute (see section&nbsp;<A href="#subgrid">21</A>)
can be regarded as a modifier of the <tt>quantity</tt>;
it applies only to data variables, not coordinate variables.
The <tt>long_name</tt> might repeat information which is standardised
by the <tt>subgrid</tt> attribute.
<i>For instance, the <i><tt>long_name</i></tt> could be
<i><tt>"maximum temperature"</i></tt>.
The <i><tt>subgrid</i></tt> attribute will define precisely in what sense
the temperature is maximised.</i>

<p>
A data variable may have a <tt>history</tt> attribute,
supplying information about the derivation of the quantity that is not
possible to include either as a standardised form or in parentheses in
the <tt>quantity</tt> and <tt>subgrid</tt> attributes.
<i>This attribute should be used as a last resort.</i>
The global <tt>history</tt> attribute, if present, also applies to all
data variables (section&nbsp;<A href="#global">5</A>).
A data variable may also have <tt>institution</tt> and <tt>production</tt>
attributes, indicating how the data was originally obtained
(see section&nbsp;<A href="#global">5</A>).
These attributes take precedence over the corresponding global attributes.
The attributes <tt>history</tt>, <tt>institution</tt> and <tt>production</tt>
must not be relied upon to distinguish between data variables in the file,
and generic applications may ignore them.

<p>

<p><br><i><b>Optional quantity information:</b>
These optional attributes might be used thus to describe a gridded
observational precipitation climatology.

<pre>
    float precipitation(lat,lon);
      precipitation:history="gridded using Thiessen polygon weighting";
      precipitation:institution="Climatic Research Unit, "
        "University of East Anglia, UK";
      precipitation:long_name="rate of precipitation";
      precipitation:production="surface station observation";
      precipitation:units="mm day-1";
</pre>
This would be appropriate if the data variable was in a file with data from
other institutions or methods of production.
</i>
<p>
The optional <tt>modulo</tt> attribute of a variable, if present,
records a number which can be added or subtracted
without altering the validity or physical significance of 
the quantity.
It should be given in the same units as the variable.
<i>This is most likely to be useful for longitude coordinate axes
(section <A href="#longitude">14</A>),
with a <i><tt>modulo</i></tt> of 360,
and climatological 
axes of seasonal or diurnal phase (sections <A href="#absolutetime">25</A>
and <A href="#multipletime">28</A>).</i>

<p>
For variables which have a spatial direction with the
interpretation of height or depth, latitude, or longitude
(<tt>Z</tt>, <tt>Y</tt> or <tt>X</tt> in section&nbsp;<A href="#dimensionality">9</A>),
the optional <tt>positive</tt> attribute may be included to indicate
the sense of positive numbers.
The allowed values are <tt>up</tt> or <tt>down</tt> for <tt>Z</tt>,
<tt>north</tt> or <tt>south</tt> for <tt>Y</tt>, <tt>east</tt> or <tt>west</tt> for <tt>X</tt>.
<i>Components of vectors such as velocities and fluxes might have this
attribute.
The standardised quantity names will also indicate the sign convention
for such quantities; for instance, <i><tt>upward velocity</i></tt> rather than
<i><tt>vertical velocity</i></tt> (<i><tt>positive=&#252;p"</i></tt>),
<i><tt>northward heat flux</i></tt> rather than
<i><tt>meridional heat flux</i></tt> (<i><tt>positive="north"</i></tt>).
See also sections&nbsp;<A href="#longitude">14</A>, <A href="#latitude">15</A> and <A href="#vertical">16</A>.</i>

<p>
We note that the Unidata-standard <tt>FORTRAN_format</tt> attribute
may be useful for both coordinate and data variables.

<p>
In addition,
other locally defined attributes may be included to define
the quantity of a variable.
<i>The Hadley Centre model will give each data variable integer <i><tt>stash</i></tt>
and <i><tt>submodel</i></tt> attributes, for example, which are codes identifying
GCM diagnostic output quantities.</i>

<p>
Variables may contain quantities which are discrete rather than
continuous,
meaning they can take only certain prescribed values.
<i>This is more likely for coordinate variables than data variables.
For instance, a data variable containing the results of
a Fourier or spherical harmonic analysis might have a dimension
for harmonic number.
Section&nbsp;<A href="#absolutetime">25</A> describes some time variables which are discrete.</i>

<p>
        <H2><A NAME="tth_sEc13">
13</A>&nbsp;&nbsp;Topology of an axis</H2>
<A NAME="topology">
</A>

<p>
An axis with ``circular topology'' is one
which can be legitimately
transformed by shifting all the points one place along the axis,
moving the last point to the beginning, any number of times.
The main coordinate variable of an axis with circular topology is distinguished
by the presence of an attribute <tt>topology="circular"</tt>.
<i>A longitude axis which circles the whole globe is an example.</i>
The value <tt>linear</tt> or the absence of this attribute
indicates an axis with ``linear topology''.
The topology is indicated only by the main coordinate variable,
but since it is the property of the axis it applies to any component,
associated or boundary
coordinate variables as well.

<p>
When a circular axis is rotated, the main coordinate values must be
altered in order to remain monotonic.
Therefore the main coordinate variable of a circular axis
requires a <tt>modulo</tt> (section <A href="#quantity">12</A>).

<p>
<i>Note that the <i><tt>topology</i></tt> and <i><tt>modulo</i></tt> attributes convey
different information.
For instance,
a longitude coordinate variable limited to values in the eastern
hemisphere between the Greenwich meridian and the date-line (e.g. 0E, 25E,
120E, 130E, 180E) does not have circular topology. (This might be from a model
of a limited area of the world.) When
making a contour map of a field with such
a longitude axis, one can interpolate anywhere within 
the eastern hemisphere to draw the
contours, but it is not legitimate to interpolate over the western hemisphere
and draw the rest of the world, which is simply missing. The
implication of circular topology would be that one could put any longitude
at all on the left-hand side of the map. However,
this coordinate variable does have a modulo (of 360,
as required in section <A href="#longitude">14</A>), and the points
can be labelled
in any way which is equivalent under the modulo to the coordinates
in the file.
The coordinate values 0,25,120,130,180 are thus equivalent to
-360,-335,-240,-230,-180.</i>

<p>
        <H2><A NAME="tth_sEc14">
14</A>&nbsp;&nbsp;Longitude dimension</H2>
<A NAME="longitude">
</A>

<p>
Coordinate variables representing
longitudes must always explicitly
include the <tt>units</tt> attribute; there is no default value.
The <tt>units</tt> attribute will be a
string formatted as per the recommendations in the Unidata udunits
package.
The recommended unit of longitude is <tt>degrees_east</tt> (eastward
positive). Also acceptable are <tt>degree_east</tt>, <tt>degree_E</tt>, and
<tt>degrees_E</tt>. The unit <tt>degrees_west</tt> (westward positive) is not
recommended because it implies a negative conversion factor from
<tt>degrees_east</tt>.
The <tt>positive</tt> attribute is not required as the sign convention
is implied by the units.

<p>
Longitude axes should have the attribute <tt>modulo=360</tt>,
indicating that they may be interpreted modulo 360.
<i>Thus, for example,
-180, 180, and 540 are all valid representations of the International Dateline
and 0 and 360 are both valid representations of the Prime Meridian.
COARDS assumes that longitudes may always be treated in this way.
Since we have introduced the <i><tt>modulo</i></tt> attribute,
we require that it should be specified to indicate this.</i>
A global longitude axis should have the attribute <tt>topology="circular"</tt>.
<i>Note that the presence of a <i><tt>modulo</i></tt> attribute
does not mean that the axis necessarily has circular topology
(section <A href="#topology">13</A>);
a longitude axis covering only part of the globe cannot have its points
rotated.</i>
The sequence of numerical longitude values stored in the netCDF
file must be monotonic in a non-modulo sense
for a main coordinate variable of longitude.

<p>

<p><br><i><b>Global longitude axis:</b> 

<pre>
    float lon(lon);
      lon:long_name="longitude";
      lon:modulo=360.0f;
      lon:topology="circular";
      lon:units="degrees_east";
</pre>
Note that if a quantity table is in use,
<i><tt>"longitude"</i></tt> is the name of the quantity in the standard list,
and could be recorded instead in a <i><tt>quantity</i></tt> attribute.
</i>
<p>
        <H2><A NAME="tth_sEc15">
15</A>&nbsp;&nbsp;Latitude dimension</H2>
<A NAME="latitude">
</A>

<p>
Coordinate variables representing
latitudes must always explicitly
include the <tt>units</tt> attribute; there is no default value.
The <tt>units</tt> attribute will be a
string formatted as per the recommendations in the Unidata udunits
package.
The recommended unit of latitude is <tt>degrees_north</tt>. Also acceptable
are <tt>degree_north</tt>, <tt>degree_N</tt>, and <tt>degrees_N</tt>.
The <tt>positive</tt> attribute is not required as the sign convention
(northward positive) is implied by the units.

<p>

<p><br><i><b>Latitude axis:</b> 

<pre>
    float lat(lat);
      lat:long_name="latitude";
      lat:units="degrees_north";
</pre>
Note that if a quantity table is in use,
<i><tt>"latitude"</i></tt> is the name of the quantity in the standard list,
and could be recorded instead in a <i><tt>quantity</i></tt> attribute.
</i>
<p>
        <H2><A NAME="tth_sEc16">
16</A>&nbsp;&nbsp;Vertical (height or depth) dimension</H2>
<A NAME="vertical">
</A>

<p>
Whereas the two horizontal dimensions are usually longitude
and latitude, whose direction is well defined,
a variety of quantities may be used for the vertical axis,
if there is one.
The axis to be regarded as the vertical axis
must have both a <tt>long_name</tt> attribute
and a <tt>positive</tt> attribute (section <A href="#quantity">12</A>),
the latter having one of the values <tt>up</tt> or <tt>down</tt>
to indicate the sense of the direction of positive
<i>(The sense may be useful for applications which display the data.)</i>

<p>

<p><br><i><b>Vertical pressure axis:</b> 

<pre>
  dimensions:
    pressure=15;
  variables:
    float pressure(pressure);
      pressure:long_name="pressure";
      pressure:positive="down";
      pressure:units="hPa";
  data:
    pressure=850, 700, 500, 300, 200, 150, 100, 50, 30, 20, 10;
</pre>
</i>
<p>
<i>The COARDS standard requires the units of 
the vertical axis to be selected from a defined list,
in order that this axis can be recognised by its units.
It gives special status to units of pressure,
for which the direction of positive is defined,
and makes the <i><tt>positive</i></tt> attribute mandatory
for vertical axes with other units.</i>

<p>
<i>We have adopted a different approach for a number of reasons.
Firstly, to require units for the vertical axis
means defining dimensionless units for any
dimensionless quantity one might wish to use for the coordinate variable.
This is inconsistent with the treatment of a data variable;
the standard does not require that dimensionless units be invented
for dimensionless physical quantities in data variables.
Secondly, the vertical dimension of a data variable can be identified
from the <i><tt>axis</i></tt> attribute or the
the order of dimensions
(see section <A href="#dimensionality">9</A>),
allowing any application which expects such a
dimension to find it without any further help.
Thirdly, the <i><tt>quantity</i></tt> attribute (if in use) is more informative
than the units.</i>

<p>
<i>We are not entirely convinced that
the direction of positive should really be recorded as part of the
data structure.
It is mostly an issue for displaying the data,
and is to some extent a matter of personal preference.
If such special treatment is given to the vertical axis,
why is it not also recorded for other axes?
For instance, when latitude is shown on the horizontal axis of a plot,
is north on the left or the right?
This is the same kind of question,
but it strikes us as more a matter for a graphics application to consider.
Nonetheless, we have required the <i><tt>positive</i></tt> attribute for
compatibility with COARDS.</i>

<p>
<i>For example, if an oceanographic netCDF file encodes the depth of the
surface as 0 and the depth of 1000&nbsp;m as 1000 then the axis would
use attributes as follows: <i><tt>units="m"</i></tt>,
<i><tt>long_name="depth below the surface"</i></tt>, <i><tt>positive="down"</i></tt>.
If, on the other hand, the depth of 1000&nbsp;m were represented as
-1000,
we would have <i><tt>long_name="height above the surface"</i></tt>,
<i><tt>positive=&#252;p"</i></tt>.</i>

<p>
        <H2><A NAME="tth_sEc17">
17</A>&nbsp;&nbsp;Component variables</H2>
<A NAME="component">
</A>

<p>
A continuous physical variable may require
more than one number to specify it at each point.
We refer to these as ``components''.
The values of the components
are recorded in variables
referred to as ``component variables''.
The variable to which the components belong is called the ``head''
variable of the components.
The names of the component variables are recorded as
a blank-separated list in a <tt>component</tt> string attribute
of the head variable.
The dimensions of a component variable must be identical with those
of its head variable.
<i>OGDT restricted components to coordinate variables,
but the concept has here been generalised,
since any quantity that is used as a coordinate variable might also
be needed as a data variable.</i>

<p>
When a coordinate variable has components,
this standard requires that a main coordinate variable should nonetheless
be supplied which represents a combination of the components that can be
used to order the points on the axis.
As usual, this main coordinate variable must be monotonic,
but the components do not need to be monotonic.
The definition of the main coordinate in terms of its
components may be given in parentheses in the <tt>component</tt> attribute.
This information is not standardised and generic applications cannot be
expected to make use of it.

<p>

<p><br><i><b>Hybrid vertical coordinate:</b>
A vertical coordinate
<font face=symbol>h</font
> <font face=symbol>º</font
> p/p<sub>0</sub> + <font face=symbol>s</font
>
is used in some atmospheric GCMs.
Atmospheric model levels are specified in terms of
(p,<font face=symbol>s</font
>)
pairs,
where p is pressure,
p<sub>0</sub>
is a constant and
<font face=symbol>s</font
>
is fraction
of surface pressure (which is variable).
The
<font face=symbol>h</font
>
value is a linear combination of the two,
which cannot be uniquely decomposed back into
(p,<font face=symbol>s</font
>).
We would record this coordinate variable thus:

<pre>
    float eta(eta); // main coordinate variable
      eta:component="pressure sigma "
        "(eta=pressure/p0+sigma; p0=100 kPa)";
    float pressure(eta);
    float sigma(eta);
</pre>
A generic application would treat the component and main coordinates
as independent information.
The extra knowledge required to relate them would reside in any
specific application which needed it.
Hybrid vertical coordinates are the only obvious application of
component variables, but the convention could be used for other
similar purposes if they arise.
</i>
<p>
        <H2><A NAME="tth_sEc18">
18</A>&nbsp;&nbsp;Associated variables</H2>
<A NAME="associated">
</A>

<p>
An axis of a data variable, or two or more axes in combination,
may have alternative sets of coordinate values.
These alternative sets are recorded in variables
referred to as ``associated'' variables,
having their own <tt>units</tt>, <tt>long_name</tt>
and other appropriate attributes to describe them.
The names of the associated variables are recorded as a blank-separated list
in an <tt>associate</tt> string attribute either of the data variable
or of the main coordinate variable of the axis concerned.
If the association is with the data variable, it applies only for that
data variable,
but if it is with the main coordinate variable,
it applies for any data variable which uses that main coordinate variable.
Association with the main coordinate variable thus may be more convenient,
but is less flexible.
Association with the data variable is the only option when several axes are
involved, and when there is no main coordinate variable.
<i>The examples illustrate these points.</i>

<p>
The <tt>associate</tt>
attribute may alternatively and equivalently be named <tt>coordinates</tt>.
<i>This possibility is included for compatibility with the CSM standard.
However, in the present standard it is deprecated because of possible confusion
with the normal definition of ``coordinate variable'' (section
<A href="#coordinates">8</A>) and because the use of associated variables is wider
than just coordinate variables in the usual sense.</i>

<p>
A variable may be associated with more than one data variable
or coordinate variable.
If an associated variable itself has an <tt>associate</tt> attribute,
variables named by this attribute are also regarded as being associated.

<p>
An associated variable must have dimensions which are all dimensions
of any data variable with which it is associated;
the associated variable can be regarded as a function
of the indices along these axes.
The values of an associated variable do not have to be monotonic.

<p>
A generic application is not required to make any
use of associated variables.
Associated variables are not indicated in the <tt>axis</tt> attribute of the
data variable (section <A href="#dimensionality">9</A>).
However, to improve legibility of the CDL file,
it is recommended that when
variables named by the <tt>associate</tt> attribute
of a data variable have interpretations that would be
denoted by <tt>T</tt> <tt>Z</tt> <tt>Y</tt> or <tt>X</tt> in the <tt>axis</tt> attribute,
they are listed in that order, with any others appearing in front.

<p>

<p><br><i><b>Vertical axis:</b> Many associated variables
will be one-dimensional,
giving alternative sets of values for a single axis.
One example is a vertical axis where one wishes to store both the
physical coordinate and the ordinal model level number:

<pre>
  dimensions:
    lat=90;
    sigma=19;
  variables:
    float xwind(sigma,lat); // 2D data variable
      xwind:axis="ZY";
    float lat(lat);
      lat:long_name="latitude";
      lat:units="degrees_north";
    float sigma(sigma); // physical height coordinate
      sigma:associate="model_level";
      sigma:long_name="sigma";
      sigma:positive="down";
    int model_level(sigma); // model level number at each height
      model_level:long_name="model level number";
      model_level:positive="up";
</pre>
As the association of <i><tt>model_level</i></tt> is with <i><tt>sigma</i></tt>,
any data variable with a <i><tt>sigma</i></tt>-axis
will have the association with <i><tt>model_level</i></tt>;
it is not a property of <i><tt>xwind</i></tt> particularly.
</i>
<p>

<p><br><i><b>Trajectory:</b> The
value of a quantity along a one-dimensional
trajectory.
In such a case, we might have a coordinate variable containing
time of travel and
associated coordinate variables
giving the latitude and longitude of each point:

<pre>
  dimensions:
    day=10; // 10 sample times along a trajectory
  variables:
    float hice(day); // sea-ice thickness measured as the floe drifts
      hice:associate="lat lon";
      hice:axis="T";
      hice:units="m";
    float day(day); // time since the beginning of the journey
      day:long_name="time";
      day:units="day";
    float lon(day); // longitude at each time
      lon:long_name="longitude";
      lon:units="degrees_east";
    float lat(day); // latitude at each time
      lat:long_name="latitude";
      lat:units="degrees_north";
</pre>
The main coordinate variable (<i><tt>day</i></tt>) must be
monotonic, but the associated coordinates are not necessarily.
An important application
rather similar to this one
is described in section <A href="#bundles">19</A>.
Note that <i><tt>lat</i></tt> and <i><tt>lon</i></tt> cannot be
indicated as the <i><tt>X</i></tt> and <i><tt>Y</i></tt> coordinates in the <i><tt>axis</i></tt>
attribute (section <A href="#dimensionality">9</A>).
This is reasonable because, even though they have the interpretations
of latitude and longitude, they are not independent dimensions in
the sense normally expected by an application which might look for
such axes.

<p>
Since <i><tt>lon</i></tt> and <i><tt>lat</i></tt> are associated with the data variable
<i><tt>hice</i></tt>, other variables with a <i><tt>day</i></tt>-axis will not share these
associations.
If they are wanted, they would have to be indicated on those data
variables as well.
This approach allows the possibility that the same <i><tt>day</i></tt>
variable might occur in combination with various different sets of
associated coordinate variables.
For instance, there might be more than one trajectory, with the
same <i><tt>day</i></tt> coordinates but different longitude-latitude positions.
</i>
<p>

<p><br><i><b>Transformed coordinates:</b> Associated variables
of more than one dimension can be used to
describe alternative coordinate systems.
For example, vertical profiles of atmospheric humidity might
be available on a regular longitude-latitude grid,
but we might also wish to give the national grid coordinates of
each point.
The national grid x- and y-coordinates are each functions of
both latitude and longitude;
the x-coordinate does not correspond specifically to longitude,
nor the y- to latitude.
The appropriate representation is therefore:

<pre>
  dimensions:
    lon=10;
    lat=20;
    pressure=15;
  variables:
    float humidity(pressure,lat,lon);
      humidity:associate="y x";
    float pressure(pressure);
      pressure:long_name="pressure";
      pressure:positive="down";
      pressure:units="kPa";
    float lon(lon); // 1D main coordinate variable
      lon:long_name="longitude";
      lon:modulo=360.0f;
      lon:units="degrees_east";
    float lat(lat);
      lat:long_name="latitude";
      lat:units="degrees_north";
    float x(lat,lon); // 2D associated coordinate variable
      x:long_name="UK national grid eastings";
    float y(lat,lon);
      y:long_name="UK national grid northings";
</pre>
This tells us that <i><tt>humidity[*][10][5]</i></tt> is the vertical profile
of humidity at the point with latitude <i><tt>lat[10]</i></tt> and
longitude <i><tt>lon[5]</i></tt>,
which is at national grid x-coordinate <i><tt>x[10][5]</i></tt> and y-coordinate
<i><tt>y[10][5]</i></tt>.
Because the associated variables are multidimensional, they do not
correspond one-to-one with the axes,
so the association must be with the data variable rather than the
main coordinate variables.
</i>
<p>

<p><br><i><b>No main coordinate variables:</b>
A related situation is when the 2D grid is staggered or transformed
geometrically in some way (other than rotation-see section <A href="#systems">10</A>),
so that it is not possible or easy to give
one-dimensional coordinate variables for the axes.
In this case, there would be no main coordinate variables,
and the default of plain indexes would apply.
The physical coordinates are functions of the 2D gridpoint indices,
and would be given in associated variables of the data variable
just as above:

<pre>
  dimensions:
    x=90;
    y=45;
  variables:
    float orog(y,x); // 2D variable on a horizontal grid
      orog:associate="lat lon";
      orog:axis="--";
      orog:long_name="height of the surface above sea-level";
      orog:units="m";
    float lon(y,x); // 2D coordinate variable on the same grid
      lon:long_name="longitude";
      lon:modulo=360.0f;
      lon:units="degrees_east";
    float lat(y,x);
      lat:long_name="latitude";
      lat:units="degrees_north";
</pre>
The <i><tt>lat</i></tt> and <i><tt>lon</i></tt> variables are not indicated as
the <i><tt>X</i></tt> and <i><tt>Y</i></tt> coordinates in the <i><tt>axis</i></tt> variable
(section <A href="#dimensionality">9</A>).
An application which referred to latitude and longitude coordinates
would not generally expect them to be two-dimensional.
If it can handle this situation, it should identify these axes by
their <i><tt>long_name</i></tt> and <i><tt>units</i></tt>.
</i>
<p>

<p><br><i><b>3D associated coordinates:</b> 
These could be used if one wished to describe
a field with alternative 3D coordinate systems,
for instance on both a regular Cartesian grid,
and in cylindrical or spherical coordinates.
The values of the alternative coordinates would be given on the Cartesian
grid. In the spherical case, for instance

<pre>
    float temperature(z,y,x); // 3D variable on a Cartesian grid
      temperature:associate="radius theta phi";
    float radius(z,y,x);
    float theta(z,y,x);
    float phi(z,y,x);
</pre>
</i>
<p>
A particular technical application of a one-dimensional
associated coordinate is to deal with the limitation of netCDF to a
single unlimited dimension.
If several data variables have unlimited axes of different lengths or
physical significance,
they can all share a nominal unlimited dimension,
and each have associated variables specifying the meaning of the axis.

<p>

<p><br><i><b>More than one unlimited axis:</b>
Consider a file which contains data variables with unlimited
axes measuring elapsed time with different sampling frequency,
and hence of different lengths.

<pre>
  dimensions:
    time_counter=UNLIMITED;
  variables:
    float sw(time_counter); // sampled every 3 hours
      sw:associate="time_3h";
      sw:axis="T";
      sw:long_name="vertical component of "
        "shortwave radiative flux density";
      sw:units="W m-2";
    float latent(time_counter); // sampled every 30 minutes
      latent:associate="time_30min";
      latent:axis="T";
      latent:long_name="latent heat flux density";
      latent:units="W m-2";
    float time_3h(time_counter)";
      time_3h:long_name="elapsed time";
      time_3h:units="h";
    float time_30min(time_counter);
      time_30min:long_name="elapsed time";
      time_30min:units="min";
</pre>
</i>
<p>
        <H2><A NAME="tth_sEc19">
19</A>&nbsp;&nbsp;Bundles</H2>
<A NAME="bundles">
</A>

<p>
If several data arrays containing the same physical quantity
have one or more identical axes,
but are distinguished by the values of other singleton coordinate variables,
it may be convenient to store them in the same data variable.
The common axes of the separate arrays become axes of the combined variable.
One or more additional axes are introduced to ``bundle up'' the separate
arrays.
Such an axis does not correspond to a continuous physical coordinate.
It acts simply as an index of the bundled-up arrays.

<p>
The singleton values of the separate arrays are recorded in
associated coordinate variables for the bundling dimension.
They should not be interpreted as continuous coordinates.

<p>

<p><br><i><b>Timeseries:</b>
The Hadley Centre GCM
can generate timeseries of the values of quantities
at individual points.
Typically, timeseries from many different points are produced of the same
quantity at the same sampling times.
It is natural to contain this information
in a data variable with two dimensions.
One dimension is the common time axis, specifying the sampling times,
which are the same for all the points sampled.
The other dimension is not a continuous physical coordinate;
it is simply being used to ``bundle up'' the timeseries,
the points being
irregularly scattered in a space of two or more dimensions.
Thus:

<pre>
  dimensions:
    points=15; // measurement locations
    times=20; // sampling times
  variables:
    float snowdepth(times,points);
      snowdepth:associate="sitename lat lon";
      snowdepth:axis="T-";
    float lon(points); // longitude of sites
      lon:long_name="longitude";
      lon:modulo=360.0f;
      lon:units="degrees_east";
    float lat(points); // latitude of sites
      lat:long_name="latitude";
      lat:units="degrees_north";
    char sitename(points,StringMaxLength); // string array of sitenames
    double times(times); // times of measurement
</pre>
See section <A href="#time">23</A> concerning the time coordinates.
This same form could be used for observed timeseries from stations.
The bundling axis (<i><tt>points</i></tt>) is simply an index.
The <i><tt>long_name</i></tt> and <i><tt>units</i></tt> of the associated coordinates
identify their meanings.
</i>
<p>

<p><br><i><b>Vertical profiles:</b>
A similar application is that of vertical
profiles at sets of points;
for example, scattered vertical temperature profiles through the ocean,
or data from various radiosonde stations.

<pre>
  dimensions:
    station=10; // measurement locations
    pressure=11; // pressure levels
  variables:
    float humidity(pressure,station);
      humidity:associate="lat lon";
      humidity:axis="Z-";
    int station(station); // station numbers
    float lon(station); // longitude of stations
    float lat(station); // latitude of stations
    float pressure(pressure)
</pre>
</i>
<p>

<p><br><i><b>Several parcel trajectories:</b>
Consider a set of Lagrangian parcel trajectories (for instance, ocean
drifters).
Various parameters are evaluated at fixed times from the start of each
trajectory.
The trajectories are identified by their place of origin,
and the position is a function of time and trajectory identity.
The position information is therefore stored in multidimensional
associated coordinate variables.

<pre>
  dimensions:
    parcel=15; // number of trajectories
    times=20;
    max_len_parcel_name=64; // max length of trajectory name
  variables:
    float temperature(parcel,times);
      temperature:associate="parcel_name lat lon";
      temperature:axis="-T";
    float salinity(parcel,times);
      salinity:associate="parcel_name lat lon";
      salinity:axis="-T";
    float times(times);
      times:units="days";
    char parcel_name(parcel,max_len_parcel_name);
    float lon(parcel,times);
    float lat(parcel,times);
</pre>
The associations have to be made on the data variables in this case,
because <i><tt>parcel_name</i></tt> does not have a main coordinate variable,
while <i><tt>lon</i></tt> and <i><tt>lat</i></tt> are multidimensional.
</i>
<p>
<i>This section raises the question of how best to store a single timeseries,
or a single vertical profile.
Following the scheme of this section,
it could be contained in a two-dimensional data variable with the bundling
axis being of size unity.
The associated information such as latitude or longitude would then be
stored in singleton coordinate variables,
all associated with the same dimension.
Alternatively, these values could be recorded as
separate singleton dimensions (following section <A href="#dimensionality">9</A>).
We have no recommendation for this.
Either scheme could be appropriate;
which is more natural perhaps depends on how the data was extracted from
the continuous axes.</i>

<p>
        <H2><A NAME="tth_sEc20">
20</A>&nbsp;&nbsp;Boundary variables</H2>
<A NAME="boundary">
</A>

<p>
Along a dimension,
the values might relate to points (at the coordinate values)
or to contiguous or non-contiguous cells.
The boundaries of the cells should be defined
as well as the point coordinate values.
The convention is to define an additional two-dimensional
``boundary variable'' with
a right-hand dimension <i>(leading dimension in Fortran terms)</i> of size two.
The values for which this dimension has index 0
(numbering from 0 i.e.&nbsp;in C notation) supply the boundaries
with the smaller main coordinate values,
and those with index 1 the large values,
where ``smaller'' and ``larger'' refer simply to numerical comparison,
not to a physical direction.
Supplying upper and lower boundaries separately allows for the possibility
that the cells might not be contiguous; they might even overlap.
If a lower boundary value is equal to the <tt>valid_min</tt> for the coordinate
variable (section <A href="#invalid">29</A>), the cell has no lower boundary.
If an upper boundary value is equal to the <tt>valid_max</tt>,
the cell has no upper boundary.
The name of the boundary variable is recorded in a string attribute
<tt>bounds</tt> of the main coordinate variable.
We recommend that the it should be named
by the coordinate dimension with the prefix <tt>bounds_</tt>.
The boundary variable should not have a <tt>units</tt> attribute;
its units are the same as those of the main coordinate variable.

<p>

<p><br><i><b>Boundaries for a one-dimensional latitude coordinate variable:</b>

<pre>
    float lat(lat);
      lat:bounds="bounds_lat";
    float bounds_lat(lat,2);
</pre>
In C notation,
<i><tt>lat[0]</i></tt> gives the coordinate of the first point,
<i><tt>bounds_lat[0][0]</i></tt> its lower boundary, <i><tt>bounds_lat[0][1]</i></tt>
its upper boundary.
In Fortran notation, the declarations are <i><tt>lat(lat)</i></tt>
and <i><tt>bounds_lat(2,lat)</i></tt>,
and the relevant elements are <i><tt>lat(1)</i></tt>, <i><tt>bounds_lat(1,1)</i></tt>,
<i><tt>bounds_lat(2,1)</i></tt>.
</i>
<p>

<p><br><i><b>Albedo as a function of wavelength and snow cover:</b>
Characteristic values of albedo are given for various wavelength
bands, dependent also on snowdepth.

<pre>
  dimensions:
    lambda=4; // number of shortwave frequency bands
    snowdepth=10; // number of snowdepth categories
  variables:
    float albedo(lambda,snowdepth); // no units for albedo
      albedo:axis="--";
      albedo:long_name="surface albedo";
    float lambda(lambda);
      lambda:bounds="bounds_lambda";
      lambda:long_name="wavelength";
      lambda:units="nm";
    float bounds_lambda(lambda,2);
    float snowdepth(snowdepth);
      snowdepth:bounds="bounds_snowdepth";
      snowdepth:long_name="mass per unit area of lying snow";
      snowdepth:units="kg m-2";
      snowdepth:valid_max=1e9;
    float bounds_snowdepth(snowdepth,2);
  data:
    lambda=250, 385, 570, 795;
    bounds_lambda=175,320, 320,450, 450,690, 690,900;
    snowdepth=0.05, 0.15, 0.35, 0.75, 1.25, 1.75, ..., 450.0, 1000.0;
    bounds_snowdepth=0.0,0.1, 0.1,0.2, 0.2,0.5, 0.5,1.0,
                     1.0,1.5, 1.5,2.0, ..., 400.0,500.0, 500.0,1e9;
</pre>
A first index of 0, for instance, gives albedo values for
the wavelength range 175-320&nbsp;nm.
The deepest snowdepth class has no upper bound; any value above 500
falls into this class.
</i>
<p>
In some cases <i>such as the previous example</i> the boundary
coordinates are well defined,
but the gridpoint coordinates are arbitrary.
In such circumstances, this standard recommends the mid-point of the boundaries
be used as the gridpoint.
<i>Two advantages of this choice are: firstly, comparison of a gridpoint with a
boundary will always decide which cell the point belongs in;
secondly, it will probably be an appropriate choice for plotting and calculations
involving gridpoints such as differentiation.
However, as shown by the last snowdepth cell of the above example,
which is unbounded upwards, the mid-point is not always a sensible choice.</i>

<p>

<p><br><i><b>Probability density function of precipitation amounts:</b>

<pre>
  dimensions:
    ppn=10;
  variables:
    float pdf(ppn,lat,lon);
      pdf:axis="-YX";
      pdf:long_name="probability density of "
        "depth of water-equivalent precipitation";
      pdf:units="mm-1";
    float ppn(ppn);
      ppn:units="mm";
      ppn:long_name="depth of water-equivalent precipitation";
      ppn:bounds="bounds_ppn";
    float bounds_ppn(ppn,2);
  data:
    bounds_ppn=0.0,0.1, 0.1,0.2, 0.2,0.35, 0.35,0.5, 0.5,1.0, ...;
</pre>
<i><tt>pdf[3][10][12]</i></tt> gives the probability density of precipitation
amounts between 0.35 and 0.5&nbsp;mm falling at the location
<i><tt>lat[10] lon[12]</i></tt>.
</i>
<p>
Boundary variables
are recommended if the main coordinate values
are not evenly spaced,
or if the dimension has a size of unity.
If the coordinates are evenly spaced,
and boundaries are not specified,
generic applications may assume that the main coordinates
lie at the centres of their cells.
Boundary variables may be supplied for component and associated coordinate
variables as well as for main coordinate variables.
Their elements are ordered so as to correspond
to the corresponding main boundary variables.
Hence they will not necessarily be monotonic,
and index&nbsp;0 and 1 (numbering from 0) of the dimension of size two
will not necessarily contain the smaller and larger values.

<p>

<p><br><i><b>Boundary values for a hybrid vertical coordinate:</b>
The atmospheric column is here divided into three cells in the vertical;
from the surface to
<font face=symbol>s</font
> = 0.7;
from there to 20&nbsp;kPa, and finally to the top of the atmosphere,
using the hybrid vertical coordinate introduced in an example
in section <A href="#component">17</A>.

<pre>
  dimensions:
    eta=3;
  variables:
    float(eta);
      eta:long_name="pressure-sigma hybrid";
      eta:component="pressure sigma";
      eta:bounds="bounds_eta";
      eta:positive="down";
    float bounds_eta(eta,2);
    float pressure(eta);
      pressure:units="kPa";
      pressure:long_name="pressure";
      pressure:bounds="bounds_pressure";
    float bounds_pressure(eta,2);
    float sigma(eta);
      sigma:long_name="sigma";
      sigma:bounds="bounds_sigma";
    float bounds_sigma(eta,2);
  data:
    eta=0.75, 0.45, 0.05;
    bounds_eta=0.7,1.0, 0.3,0.7, 0.0,0.3;
    pressure=0.0, 10.0, 5.0;  // does not need to be monotonic
    bounds_pressure=0.0,0.0, 20.0,0.0, 0.0,20.0; // note order
    sigma=0.75, 0.35, 0.0;
    bounds_sigma=0.7,1.0, 0.1,0.7, 0.0,0.1;
</pre>
<i><tt>bounds_pressure[1][0]</i></tt> exceeds <i><tt>bounds_pressure[1][1]</i></tt>
because they are ordered to
correspond to <i><tt>bounds_eta</i></tt>.
</i>
<p>
Boundary variables may be given for associated multidimensional
coordinate variables (section <A href="#associated">18</A>).
Each dimension of the main variable requires an extra dimension of size 2
in the boundary variable.
These extra dimensions are placed on the right
<i>(left in Fortran terms)</i> of the coordinate dimensions,
and in the same order as the coordinate dimensions.

<p>

<p><br><i><b>Boundaries for a two-dimensional latitude coordinate variable:</b> 

<pre>
    float lat(y,x);
      lat:bounds="bounds_lat";
    float bounds_lat(y,x,2,2);
</pre>
so <i><tt>bounds[4][5][0][0]</i></tt> contains the latitude of
the lower left (smaller x and y)
corner of gridbox <i><tt>[4][5]</i></tt>, <i><tt>bounds[4][5][0][1]</i></tt> the lower right corner,
<i><tt>bounds[4][5][1][0]</i></tt> upper left and <i><tt>bounds[4][5][1][1]</i></tt> upper right.
In Fortran, the indices of the boxes would be <i><tt>(1,1,6,5)</i></tt>, <i><tt>(2,1,6,5)</i></tt>,
<i><tt>(1,2,6,5)</i></tt>, <i><tt>(2,2,6,5)</i></tt> respectively.
</i>
<p>
        <H2><A NAME="tth_sEc21">
21</A>&nbsp;&nbsp;Representation of subgrid variation</H2>
<A NAME="subgrid">
</A>

<p>
Since a data variable usually
represents a physical quantity which varies
continuously along the axes,
in reality there will generally be variation of the quantity between
adjacent gridpoints.
The data variable can give only one value for each cell,
despite this subgrid variation.
For many purposes, this can be taken as a ``representative'' value,
and it is not necessary to define precisely how it relates to
the subgrid variation.

<p>
To be explicit about how each data value reflects subgrid variation
along a particular axis,
use the <tt>subgrid</tt> attribute of the data variable.
<i>The most important application of this attribute is to
contracted or collapsed axes, described in section <A href="#contractions">22</A>.</i>
This is a string attribute comprising a list of blank-separated words.
In this list, <tt>"</tt>name<tt>:</tt> method<tt>"</tt>
indicates that subgrid variation along the axis with the dimension whose
``name'' is given
is represented by the specified ``method''.
The method, which may be several words, should be one of the
permitted values detailed in Appendix&nbsp;B,
<i>which include <i><tt>mean</i></tt>, <i><tt>maximum</i></tt>, <i><tt>minimum</i></tt>,
<i><tt>standard deviation</i></tt>, <i><tt>variance</i></tt>,
<i><tt>median</i></tt>, <i><tt>cell</i></tt>, <i><tt>point</i></tt></i>.
Case and punctuation are not significant in the method.
<i>Like Appendix&nbsp;D, Appendix&nbsp;B will be expanded on request by
users of this standard.</i>
Some methods imply a change of units of the data variable,
and this also is specified by Appendix&nbsp;B.
<i>In the above list, this is true for <i><tt>variance</i></tt>.</i>
The method <tt>point</tt> indicates that the data values apply exactly
at the coordinate values, and do not at all represent the variation between
adjacent gridpoints along the axis concerned.
The method <tt>cell</tt> indicates that each value
should be regarded as a property of the whole cell
along the axis concerned e.g.&nbsp;a sum or integral.
The method can be differently specified for the various dimensions.
<i>It must be remembered that the method applies only to the axis indicated.
If a precipitation value in a longitude-latitude gridbox is given the
method <i><tt>maximum</i></tt> for these axes, for instance, it means that it is
the maximum within these spatial cells, and does not imply that
it is also the maximum in time.</i>

<p>
The absence of any specification means that generic applications may
regard the data values as representative in whatever way suits their needs.
<i>For quantities calculated at gridpoints by numerical models,
this kind of vagueness is unavoidable.
If a model provides a longitude-latitude field of temperature at gridpoints,
an application used to draw a contour plot of the field will generally
assume that the temperatures apply at points, and will use some interpolation
scheme to compute values between them.
An application which calculates the mean of the field, however, will
probably assume that the temperatures are gridbox means,
and average them by weighting each with its area.
Both of these approaches are valid.
The finite-difference scheme by definition does not have any information
about subgrid variation,
and may itself treat the values in both ways;
it might calculate gradients between them, regarding them as points,
or enforce conservation properties, regarding them as means.
It would be unusual to regard the values as extrema, however, unless
this was explicitly indicated.</i>

<p>
Except when the data are <tt>point</tt> values,
it may also be unclear what the coordinates of the gridpoints should be.
<i>For example,
what time coordinate should be assigned to a time mean value?</i>
In such circumstances, if the boundaries of the cell are well defined,
this standard recommends that the gridpoints should be
defined as the mid-point between the boundaries
(see&nbsp;section&nbsp;<A href="#boundary">20</A>).

<p>

<p><br><i><b>Subgrid time variation in timeseries:</b>
Consider 12-hourly timeseries of pressure, temperature
and precipitation from a number of stations,
where pressure is measured instantaneously, temperature extremes over
the preceding period are recorded by maximum and minimum thermometers,
and precipitation is accumulated in a rain gauge.
For a period of 48 hours from 6 a.m.&nbsp;on 19th April 1998,
the data is structured as follows:

<pre>
  dimensions:
    instanttime=5; // 5 instantaneous measurements at 12-hour intervals
    periodtime=4; // 4 intervening 12-hour periods
    station=10;
  variables:
    float pressure(station,instanttime);
      pressure:axis="-T";
      pressure:long_name="pressure";
      pressure:subgrid="instanttime: point";
      pressure:units="kPa";
    float maxtemp(station,periodtime);
      maxtemp:axis="-T";
      maxtemp:long_name="temperature";
      maxtemp:subgrid="periodtime: maximum";
      maxtemp:units="K";
    float ppn(station,periodtime);
      ppn:axis="-T";
      ppn:long_name="depth of water-equivalent precipitation";
      ppn:subgrid="periodtime: cell";
      ppn:units="mm";
    double instanttime(instanttime);
      instanttime:long_name="time";
      instanttime:units="h since 1998-19-4 6:0:0";
    double periodtime(periodtime);
      periodtime:bounds="bounds_periodtime";
      periodtime:long_name="time";
      periodtime:units="h since 1998-19-4 6:0:0";
    double bounds_periodtime(periodtime,2);
  data:
    instanttime=0., 12., 24., 36., 48.;
    periodtime=6., 18., 30., 42.;
    bounds_periodtime=0.,12., 12.,24., 24.,36., 36.,48.;
</pre>
It is not appropriate give a subgrid method for the station axis,
since this is a bundling axis (section <A href="#bundles">19</A>) and not
a continuous physical coordinate.
The instantaneous and period measurements have to have different time
axes both because of their different dimension,
and because they do not coincide.
If the pressure measurements were made at times half-way between the
others (noon and midnight), the time axes could be shared.
Since the precipitation is given as an amount, it is a sum over
the interval of time by definition.
It could instead have been expressed as a rate in <i><tt>mm h-1</i></tt>, for
instance, in which case its subgrid method would be <i><tt>mean</i></tt>
rather than <i><tt>cell</i></tt>.
</i>
<p>

<p><br><i><b>Thickness (geopotential difference):</b> The
``thickness'' is the difference
in geopotential height between two pressure surfaces in the
atmosphere. This quantity is by definition one which relates
to the whole extent of its cell in the vertical dimension.

<pre>
  variables:
    float thickness(pressure,lat,lon);
      thickness:long_name="thickness";
      thickness:subgrid="pressure: cell";
      thickness:units="m2 s-2";
    float pressure(pressure);
      pressure:bounds="bounds_pressure";
      pressure:long_name="pressure";
      pressure:units="hPa";
    float bounds_pressure(pressure,2);
</pre>
Here, <i><tt>bounds_pressure[0][0]</i></tt> and <i><tt>bounds_pressure[0][1]</i></tt>
will be the upper and lower pressure bounds of the thickness field
<i><tt>thickness[0][*][*]</i></tt>.
</i>
<p>
If more than one subgrid method is to be indicated,
they should be arranged in the order they were applied.
The left-most operation is assumed to have been applied first.
<i>Suppose a quantity varies in both longitude and time
(dimensions <i><tt>lon</i></tt> and <i><tt>time</i></tt>) within each
gridbox.
Values which represent the time-average of the zonal maximum
are labelled <i><tt>subgrid="lon: maximum time: mean"</i></tt>,
i.e.&nbsp;find the largest value at each instant of time over all longitudes,
then average these maxima over time;
values of the zonal maximum of time-averages are
labelled <i><tt>subgrid="time: mean lon: maximum"</i></tt>.
If the methods could have been applied in any order without affecting
the outcome, they may be put in any order in the <i><tt>subgrid</i></tt> attribute.</i>

<p>
If a data value is representative of variation over a
combination of axes,
a single method should be prefixed by the names of all the dimensions involved,
whose order is immaterial.
Dimensions should be grouped in this way only if there is an essential difference
from treating them individually.
<i>For instance, the subgrid standard deviation of 
topographic height within a longitude-latitude gridbox
would have <i><tt>subgrid="lat: lon: standard deviation"</i></tt>.
This is not the same as
<i><tt>subgrid="lon: standard deviation lat: standard deviation"</i></tt>,
which would mean finding the standard deviation along each parallel of
latitude within the zonal extent of the gridbox,
and then the standard deviation of these values over latitude.</i>

<p>
To indicate more precisely how the <tt>subgrid</tt> method was
applied,
extra information may be included in parentheses <tt>()</tt> after the
identification of the method.
This information is not standardised and may be ignored by a generic
application.
<i>A mean over latitude, for instance, may be area-weighted.
This could be indicated as <i><tt>"lat: mean (area-weighted)"</i></tt>.</i>

<p>
The <tt>subgrid</tt> attribute cannot be used
to show how a value reflects variation over a coordinate which does
not have a dimension in the data variable.
This should be done in the <tt>long_name</tt> instead.
It is generally more informative and precise to introduce a singleton dimension
specifically for this purpose, however.
<i>For example, we could describe a quantity in its <i><tt>long_name</i></tt> as
being simply a temporal variance,
but it would be more informative to record it as a subgrid
method, by giving the variable
a singleton time dimension, which could also
be used to should the range of times
it covers and the time-interval of the data from which the variance was
calculated. See also section&nbsp;<A href="#contractions">22</A>.</i>

<p>
        <H2><A NAME="tth_sEc22">
22</A>&nbsp;&nbsp;Contracted dimensions</H2>
<A NAME="contractions">
</A>

<p>
A contracted axis is one which is formed by aggregating
the values of an axis with a larger dimension into a smaller number of groups.
In the commonest case, the dimension is collapsed completely to
a singleton dimension (i.e.&nbsp;a size of unity, section <A href="#dimensionality">9</A>),
where all data points share the entire collapsed axis.
The collapsed dimension
indicates the relationship of the data variable which is
being described to another variable of higher dimensionality.
The boundaries of the cells along a contracted axis
will be the outside boundaries of the groups of cells along the
uncontracted axis,
or the outside coordinates if boundaries were not given.
The main coordinate values of a contracted axis will be values representative
of the coordinate ranges spanned by the groups.
A collapsed dimension has a single representative main
coordinate value and boundary coordinate values supplying the
complete range of the uncollapsed axis.
These boundaries will be
the extreme boundary coordinate values of the uncollapsed axis,
or the extreme main coordinate values if boundaries were not supplied.
<i>A very important application of collapsed axes is to indicate
climatological time.
This is discussed in section <A href="#multipletime">28</A>.</i>

<p>
The <tt>subgrid</tt> attribute
(section <A href="#subgrid">21</A>) of the data variable
with contracted axes
can be used to indicate how the data values
of the variable with uncontracted axes
were aggregated to reduce the dimensions.
The new <tt>subgrid</tt> information will be appended to the existing attribute,
if any,
indicating the name of the newly contracted dimension.
Any existing references to the uncontracted dimension in the
<tt>subgrid</tt> attribute should be modified to refer to the contracted
dimension, since the uncontracted dimension will no longer be a dimension
of the data variable.

<p>
<i>As explained in section <A href="#subgrid">21</A>, this attribute will indicate
that the data value is the mean, maximum, minimum, etc.
The allowed <i><tt>subgrid</i></tt> ``methods''
are listed in Appendix&nbsp;B, which will be expanded as need arises.
As foreseen at the moment, the idea is limited to operations which give
a single value representative of each contracted group of values,
without reference to any external constants.
For example, the number which exceeds 20% of the values in the group,
or equivalently the 20th percentile, is a single number
representing the group, but the
procedure of finding it is not treated as a <i><tt>subgrid</i></tt> method
because it requires the constant 0.2 to define it.
Instead, the relationship of this new variable to the old should be shown
by changing its <i><tt>long_name</i></tt> to indicate that it is a percentile value,
and giving it a new singleton percentage axis with value 20,
or cumulative probability with value 0.2.
This kind of transformation is analogous to reducing a variable on three
spatial dimensions (say) to two by extracting its values on a specified
surface.
The contraction or collapse is a special case, because,
in general, the percentile axis need not have a size of unity;
it might be a new multi-valued axis (in cumulative probability)
replacing the old one (in some spatial dimension, for instance).
This is like regridding a vertical axis of height onto pressure.
Having said all this, however, we note that <i><tt>median</i></tt> is in fact a named
instance of this operation-extraction of the 50th percentile-but we
allow it on the grounds that it is a common method
for choosing a single representative value.</i>

<p>
<i>Singleton axes are not necessarily the result of collapsing an axis.
In section&nbsp;<A href="#dimensionality">9</A>, we recommend singleton axes as the means
of attaching characteristic single physical values to a data variable,
for instance the height or pressure of the surface on which a variable
is supplied.
If no <i><tt>subgrid</i></tt> method is specified, the application knows only
that the single value characterises the data in some way.
All information in the <i><tt>subgrid</i></tt> attribute is entirely optional.
For instance, a time-mean quantity should generally have a singleton time
dimension
to indicate the range of times to which it applies, but
it is not mandatory to indicate in the <i><tt>subgrid</i></tt> attribute that it is
a mean over time.</i>

<p>
On the coordinate variable of a contracted axis,
the optional <tt>old_interval</tt> attribute
specifies the typical spacing between
two adjacent coordinates of the uncontracted axis, where
``typical'' is not well defined.
The <tt>old_interval</tt> attribute should be given in the same units as the
coordinates.
Further information may be given by the
the optional <tt>old_spacing</tt> attribute,
which may have value <tt>uniform</tt>, indicating that the coordinates were
evenly spaced with the <tt>old_interval</tt> specified (if any) and the cells
contiguous,
or <tt>variable</tt>, if they were not evenly spaced but still contiguous,
or <tt>disjoint</tt>, which means there may have been gaps between them.
The coordinates of the uncontracted axis may be explicitly recorded
in separate variables;
if so, the main uncontracted coordinate variable 
should be named by the attribute <tt>expand</tt> of the 
main contracted coordinate variable.

<p>

<p><br><i><b>Area-averaging a longitude-latitude field to one of
lower resolution:</b> The original resolution was 1 degree, and the field
has been averaged into 10-degree boxes.

<pre>
  dimensions:
    con_lat=18; // contracted dimension
    con_lon=36;
    lat=180; // original uncontracted dimension
    lon=360;
  variables:
    float sst(con_lat,con_lon);
      sst:axis="YX";
      sst:long_name="sea surface temperature";
      sst:subgrid="con_lat: mean con_lon: mean";
      sst:units="degC";
    float con_lat(con_lat); // contracted latitude axis
      con_lat:bounds="bounds_con_lat";
      con_lat:expand="lat";
      con_lat:old_interval=1.0f; // original resolution in latitude
      con_lat:long_name="latitude";
      con_lat:units="degree_north";
    float bounds_con_lat(con_lat,2);
    float lat(lat); // original uncontracted latitude axis
      lat:bounds="bounds_lat";
    float bounds_lat(lat,2);
  data:
    con_lat=-85, -75, -65, ...;
    bounds_con_lat=-90.,-80., -80.,-70., -70.,-60., ..., 80.,90.;
    lat=-89.5, -88.5, -87.5, ...;
    bounds_lat=-90,-89, -89,-88, -88,-87, ..., 89,90;
</pre>
Instead of an area-average, the contracted field might instead have
represented the subgrid spatial variation of SST.
In that case, <i><tt>subgrid="con_lat: con_lon: standard deviation"</i></tt>.
</i>
<p>

<p><br><i><b>Mean over time and longitude:</b> Here, the time-mean
zonal-mean humidity is given as a function of latitude and height.
The means have been formed over the complete time and longitude
intervals of the original data, so these dimensions are collapsed.

<pre>
  dimensions:
    con_lon=1; // collapsed longitude dimension
    con_time=1; // collapsed time dimension
    lon=72;
    sigma=6;
  variables:
    float humidity(con_time,sigma,lat,con_lon);
      humidity:axis="TZYX";
      humidity:long_name="specific humidity";
      humidity:subgrid="con_time: mean con_lon: mean";
    double con_time(con_time);
      con_time:bounds="bounds_con_time";
      con_time:old_interval=0.125; // originally at intervals of 3 h
      con_time:units="days as %Y%m%d.%f";
    float bounds_con_time(con_time,2);
    float con_lon(con_lon);
      con_lon:bounds="bounds_con_lon";
      con_lon:long_name="longitude";
      con_lon:modulo=360f;
      con_lon:topology="circular";
      con_lon:units="degree_east";
    float bounds_con_lon(con_lon,2);
    float sigma(sigma);
      sigma:bounds="bounds_sigma";
      sigma:long_name="sigma";
    float bounds_sigma(sigma,2);
  data:
    con_time=19960901.0;
    bounds_con_time=19960301.0, 19970301.0;
    con_lon=180;
    bounds_con_lon=0, 360;
    sigma=0.99, 0.96, 0.92, 0.8, 0.5, 0.1;
    bounds_sigma=0.98,1.00, 0.94,0.98, 0.86,0.94,
                 0.65,0.86, 0.30,0.65, 0.05,0.30;
</pre>
This is a mean over the complete
range of longitude from 1 March 1996 to 1 March 1997
(see section <A href="#absolutetime">25</A> concerning the time coordinate).
The longitude axis indicates circular topology because
this was the case before it was collapsed; after collapse, the topology
is not really meaningful.
If the humidity was subsequently meaned over the depth of the atmosphere
as well,
<i><tt>subgrid</i></tt> would be suffixed with <i><tt>con_sigma: mean</i></tt>,
and <i><tt>con_sigma</i></tt> would have bounds 0.05 and 1.00.
</i>
<p>
If the same axis is contracted repeatedly,
the methods may all be
recorded in the <tt>subgrid</tt> attribute of the data variable,
but only the most recent <tt>old_interval</tt>
and <tt>old_spacing</tt> will be shown on the contracted coordinate variable.
But if the axis before contraction is retained in the file (identified by
an <tt>expand</tt> attribute), and was itself the result of a contraction,
it can record the previous <tt>old_interval</tt> and <tt>old_spacing</tt>.

<p>
Repeated operations of some methods can be regarded as equivalent to a
single operation.
<i>For instance, meaning longitude cells of 1 degree width to 5 degrees,
and then from 5 to 45 degrees, gives the same result as meaning in one step
from 1 degree to 45 degrees (apart from complications with missing data).
Similarly, meaning a time axis from days into months, then into seasons,
and finally into years could be represented as a single operation of meaning
from days to years.</i>
In that case, the <tt>subgrid</tt>,
<tt>old_interval</tt> and <tt>old_spacing</tt> attributes need not be modified
for successive operations.
The choice of whether to take this approach
is left to the application.

<p>
Some methods imply a change in the physical dimensions of the
quantity. For these methods, the quantity name must be modified,
and the <tt>units</tt> changed as indicated by Appendix&nbsp;B.
<i>The commonest such method is <i><tt>variance</i></tt>, which changes
a variable with <i><tt>quantity="temperature"</i></tt>
and <i><tt>units="K"</i></tt> to one with <i><tt>quantity="variance of temperature"</i></tt>
and <i><tt>units="K2"</i></tt>.</i>
Methods of simultaneous combination and contraction
of separate quantities also imply a change in the physical dimensions.
<i>We do not have <i><tt>subgrid</i></tt> attributes for arbitrary combinations
of quantities, but only for those operations which are frequently used
to represent the simultaneous variation of separate quantities,
such as covariance and correlation.</i>

<p>

<p><br><i><b>Covariance of temperature and wind:</b>
The <i><tt>covariance</i></tt> method is one which combines two quantities in order
to perform a contraction.

<pre>
  dimensions:
    lon=96;
    lat=72;
    con_time=1;
  variables:
    float eddyut(con_time,lat,lon);
      eddyut:axis="TYX";
      eddyut:long_name="covariance of temperature and eastward wind";
      eddyut:subgrid="con_time: covariance";
      eddyut:units="K m s-1";
    float con_time(con_time);
    float bounds_con_time(con_time,2);
</pre>
The <i><tt>subgrid</i></tt> attribute indicates that the quantity is a temporal
covariance,
and the time bounds specify the period of time over which the covariance
was calculated.
An <i><tt>old_interval</i></tt> attribute could record the original spacing in time
of the values, hourly for instance.
</i>
<p>
        <H2><A NAME="tth_sEc23">
23</A>&nbsp;&nbsp;Time variables and intervals</H2>
<A NAME="time">
</A>

<p>
A ``time variable'' is one which represents date and time,
which we will refer to hereafter just as ``time''.
An ``interval of time'' is the difference between two times.

<p>
It would be possible to describe
time in terms of six components (year, month, day, hour, minute, second)
in a netCDF file,
using six component variables of various data types.
However, it is more efficient and for many purposes more convenient
to represent a time as a single number,
giving the elapsed interval since a certain reference time,
which may be either implicit or explicit.
We refer to conversion from the components of a time into a single
number as ``encoding'', and the reverse as ``decoding''.
Encoding and decoding are complicated because
year and month are units with lengths that depend on the date
and the calendar in use,
so special provisions are needed for time axes.

<p>
A ``calendar'' defines the set of valid dates
(year-month-day combinations).
The standard calendar is the Gregorian
(the calendar of udunits),
but climate models do not always use this.
<i>For instance, in the calendar of
the Hadley Centre GCM, all months have 30 days.</i>
The elapsed interval in units of fixed length
(days, hours, minutes, seconds)
between two times will not necessarily be the same
in two different calendars,
because there may be different numbers of valid dates between them.
<i>For example,
the interval between 1 February 1996 and 1 March 1996 is one month,
and equals
29 days in the standard calendar, but 30 days in the Hadley Centre
model calendar,
since 30 February is a valid date in the latter.</i>
Therefore the encoding of a time into an elapsed interval will
depend on the calendar,
and it is necessary to know the calendar when converting.
This standard permits the use of the standard calendar
(below, section <A href="#gregorian">26</A>)
and of other calendars (section <A href="#othercalendars">27</A>).
The <tt>calendar</tt> attribute,
described in the following sections,
indicates the calendar in use.
If a time coordinate variable has no <tt>calendar</tt> attribute,
the global <tt>calendar</tt> attribute (section <A href="#global">5</A>),
if present, applies to it.

<p>
This standard permits two different methods,
distinguished by their <tt>units</tt>,
of encoding a time into a number.
These methods, referred to as ``relative time''
and ``absolute time'',
are described in the following sections
(<A href="#relativetime">24</A> and <A href="#absolutetime">25</A>).
Relative time is a more familiar method,
but absolute time offers important advantages.

<p>
Time variables may have
an attribute <tt>time_format</tt>, to specify
a format for printing the date and time,
according to the conventions of the
Unix (TM) <tt>date</tt> command.

<p>
Time coordinate variables must always explicitly include
the <tt>units</tt> attribute; there is no default value.

<p>
        <H2><A NAME="tth_sEc24">
24</A>&nbsp;&nbsp;Relative time</H2>
<A NAME="relativetime">
</A>

<p>
A time encoded as a relative time gives the elapsed interval since
a specified reference time;
<tt>units</tt> takes the form <tt>"</tt>time-unit <tt>since</tt>
reference-time<tt>"</tt>,
as per the recommendations of 
the Unidata udunits package (but see below concerning
the time-unit)
<i>e.g.&nbsp;a unit of <i><tt>seconds since 1992-10-8 15:15:42.5</i></tt>
indicates seconds since 8 October 1992 at 3 hours, 15 minutes and
42.5 seconds in the afternoon, in Universal Coordinated Time
(time zones can also be handled).</i>
In order to decode the values on a relative time axis,
the application will in general need to know the calendar;
the encoded time values are meaningless without this knowledge.
Furthermore, a given date may result in different time values
when encoded in two different calendars
with the same <tt>units</tt>.
<i>For instance, <i><tt>1996-2-1 15:00:00</i></tt> is <i><tt>62.625 days since
1995-12-1 0:0:0</i></tt> in the standard calendar,
and <i><tt>60.625 days since 1995-12-1 0:0:0</i></tt> in the 360-day calendar.</i>

<p>
The file <tt>udunits.dat</tt> defines
second, minute, hour and day as units of time.
Units of months and years are disallowed by Appendix C
of this standard,
because they are not well-defined;
since udunits defines a year as a ``tropical year''
of 31556925.97&nbsp;s (674.03&nbsp;s less than 365 days)
and a month as exactly a twelfth of a year,
use of these units will probably not give the expected results.
<i>For example, <i><tt>1 month since 1995-4-1 0:0:0</i></tt>
is treated by udunits as
<i><tt>30.4368 days since 1995-4-1 0:0:0</i></tt>, which is approximately
<i><tt>1995-5-1 10:29</i></tt>,
not <i><tt>1995-5-1 0:0:0</i></tt>.
Also, <i><tt>1 year since 1995-4-1 0:0:0</i></tt> is about <i><tt>1996-3-31 5:49</i></tt>,
not <i><tt>1996-4-1 0:0:0</i></tt>.</i>
The udunits unit <tt>common_year</tt> (exactly 365 days)
is permitted, but not recommended.

<p>

<p><br><i><b>A relative time axis for instantaneous measurements of a
quantity:</b> Measurements are made
at noon on 2nd-5th June 1996.

<pre>
  dimensions:
    time=4;
  variables:
    double time(time);
      time:long_name="time";
      time:units="days since 1996-1-1 0:0:0";
  data:
    time=1.5, 2.5, 3.5, 4.5;
</pre>
</i>
<p>

<p><br><i><b>A relative time axis for monthly means:</b> 
Means are calculated for February, March 
and April of 1990.

<pre>
  dimensions:
    time=3;
  variables:
    double time(time);
      time:bounds="bounds_time";
      time:long_name="time";
      time:units="days since 1990-1-1 0:0:0";
    double bounds_time(time,2);
  data:
    time=45.0, 74.5, 105.0;
    bounds_time=31.0,59.0, 59.0,90.0, 90.0,120.0;
</pre>
In this example, the main time coordinates are merely representative
values, being the mid-points of their respective months.
Decoded, they are <i><tt>1990-2-15 0:0:0</i></tt>, <i><tt>1990-3-16 12:0:0</i></tt>
and <i><tt>1990-4-16 0:0:0</i></tt>.
</i>
<p>
        <H2><A NAME="tth_sEc25">
25</A>&nbsp;&nbsp;Absolute time</H2>
<A NAME="absolutetime">
</A>

<p>
This method of encoding time refers to the separate components
of time, rather than to a single unit of fixed length.
It offers two advantages.
Firstly, the encoded times are meaningful and can be decoded
into components of time without knowledge of the
calendar, although to calculate intervals between them
this knowledge is still required.
Secondly, ``partial'' times can be encoded,
which omit the year, or the ``seasonal phase'' (time of year,
time within the seasonal cycle), or the ``diurnal phase''
(time of day, time within the diurnal cycle).
By contrast, relative times can only be ``complete'' times,
which include information about all three of these.

<p>
The <tt>units</tt> attribute of absolute time takes the form
<tt>"</tt>time-unit <tt>as</tt> time-string<tt>"</tt>,
The possibilities with the recommended data types
and their meanings are as follows:

<center>
<table border>
<tr><td>Format </td><td>Data type </td><td>Interpretation </td>
<tr><td><tt>second as %S.%f</tt> </td><td><tt>float</tt> </td><td>Diurnal phase </td>
<tr><td><tt>minute as %M.%f</tt> </td><td><tt>float</tt> </td><td>Diurnal phase </td>
<tr><td><tt>hour as %H.%f</tt> </td><td><tt>float</tt> </td><td>Diurnal phase </td>
<tr><td><tt>day as %Y%m%d.%f</tt> </td><td><tt>double</tt> </td><td>Time </td>
<tr><td><tt>day as %Y%m%d</tt> </td><td><tt>int</tt> </td><td>Year and seasonal phase </td>
<tr><td><tt>day as %m%d.%f</tt> </td><td><tt>double</tt> </td><td>Seasonal phase and diurnal phase </td>
<tr><td><tt>day as %m%d</tt> </td><td><tt>int</tt> </td><td>Seasonal phase </td>
<tr><td><tt>day as .%f</tt> </td><td><tt>float</tt> </td><td>Diurnal phase </td>
<tr><td><tt>calendar_month as %Y%m.%f</tt> </td><td><tt>double</tt> </td><td>Year and seasonal phase </td>
<tr><td><tt>calendar_month as %m.%f</tt> </td><td><tt>float</tt> </td><td>Seasonal phase </td>
<tr><td><tt>calendar_year as %Y.%f</tt> </td><td><tt>double</tt> </td><td>Year and seasonal phase </td>
<tr><td><tt>calendar_year as %Y</tt> </td><td><tt>int</tt> </td><td>Year </td>
<tr><td><tt>calendar_year as .%f</tt> </td><td><tt>float</tt> </td><td>Seasonal phase </td></table>
</center>
Standard abbreviations and plural forms of the unit names are acceptable,
as usual.
The time-units <tt>calendar_year</tt> and <tt>calendar_month</tt>
are units of time defined by this standard (Appendix C).

<p>
The time-string
codes show how the year, month, day within month
and time within day are encoded into a single number,
after the fashion of the Unix (TM) <tt>date</tt>
and <tt>printf</tt> commands, thus:

<center>
<table border>
<tr><td>Format letter </td><td>Interpretation </td>
<tr><td><tt>%Y</tt> </td><td>Year (including century) </td>
<tr><td><tt>%m</tt> </td><td>Two-digit month (01=January) </td>
<tr><td><tt>%d</tt> </td><td>Two-digit day within month </td>
<tr><td><tt>%H</tt> </td><td>Hours since midnight </td>
<tr><td><tt>%M</tt> </td><td>Minutes since midnight </td>
<tr><td><tt>%S</tt> </td><td>Seconds since midnight </td>
<tr><td><tt>%f</tt> </td><td>Floating-point fraction of the specified time-unit </td>
<tr><td><tt>.</tt> </td><td>Position of decimal point </td></table>
</center>
Since an encoded time is an ordinary number, leading zeroes in the
integer part may be omitted.
It is not mandatory to use the suggested data types, which are recommended
on grounds of precision.
If an integer data type is used for an absolute time variable whose format
includes a fraction <tt>%f</tt>,
a fraction of zero is assumed.
If a floating-point data type is used for a format not including <tt>%f</tt>,
any fraction is ignored.

<p>
<i>In absolute time,
3 p.m.&nbsp;on 5th April 1998 is encoded with value 19980405.625
and <i><tt>units="day as %Y%m%d.%f"</i></tt>.
The advantage of this method of encoding a complete time is that it
can be done without knowledge of the calendar,
whereas if we encoded in relative time units of
<i><tt>days since 1900-1-1</i></tt>, the value would be 35888.625 in the standard
calendar, and 35374.625 in the 360-day calendar.
We also know, without reference to the calendar, that the value
19980605.625, with the same units, is a time exactly two calendar months
later, and 19970405.625 is exactly one calendar year earlier.
But to calculate these intervals in other time units-days, hours, etc.-we
still need to know the calendar.</i>

<p>
The only complete form of absolute time
is <tt>"day as %Y%m%d.%f"</tt>. 
Note in particular that the forms <tt>"calendar_month as %Y%m.%f"</tt>
and <tt>"calendar_year as %Y.%f"</tt> are partial times which imply
no information about the diurnal phase.
<i>This is a very important point.
For instance, <i><tt>1998.25 calendar_year as %Y.%f</i></tt> means no more than
``a quarter of the way through 1998 as regards the seasonal cycle''.
This meaning is the same in the standard and 360-day calendars.
Because this representation carries no information about diurnal phase,
it is not permitted to decode it to <i><tt>1998-4-2 3:0:0</i></tt>
(i.e.&nbsp;91.25 days from the start of the year)
in the standard calendar or
<i><tt>1998-4-1 0:0:0</i></tt> in the 360-day calendar.
Similarly, <i><tt>199804.3 calendar_month as %Y%m.%f</i></tt> means
``30% of the way through April 1998 as regards the seasonal cycle''.
Examples below show the use of such partial times.</i>

<p>
Note also
that the only form of partial time which is composed of the
seasonal and diurnal phases is <tt>"day as %m%d.%f"</tt>; 
there is no method of encoding the seasonal phase as a fraction
of a calendar year or month in combination with the diurnal phase.
Should this be required, the application could construct it as a
two-component time variable.
<i>This exclusion seems reasonable because data which resolves both
the seasonal and diurnal cycles must belong to a known calendar
(it will exhibit a certain number of days in a year, for instance)
and so its seasonal cycle can be labelled by month and day.
The calendar-independent representations of the seasonal cycle,
shown in examples below,
are more useful when portions of the seasonal cycle have been averaged,
in which case the seasonal and diurnal cycles, if both present,
will be on separate axes.</i>

<p>
The forms of partial time which do not include <tt>.%f</tt>
in the time-string are discrete variables, rather than continuous.
The interval of time in days or years
covered by a time axis in one of these forms
is reckoned by including the both ends of the axis in the count,
or equivalently by adding one to the difference of the ends.
<i>For instance, an axis with <i><tt>units="calendar_year as %Y"</i></tt>
that runs from 1930 to 1939 covers ten years, not nine,
since both ends are included.
This is a partial time indicating only the year,
not the seasonal phase.
Contrast this with an axis including the seasonal phase,
having <i><tt>units="calendar_year as %Y.%f"</i></tt>,
and end points of 1930.0 and 1939.0.
This axis spans nine years, from the beginning of 1930 to the
beginning of 1939, and does not include 1939 itself.
Examples below illustrate this point further.</i>

<p>

<p><br><i><b>An absolute
time axis for instantaneous measurements of a quantity:</b>
Measurements are made at noon on 2nd-5th June 1996.

<pre>
  dimensions:
    time=4;
  variables:
    double time(time);
      time:long_name="time";
      time:units="days as %Y%m%d.%f";
  data:
    time=19960602.5, 19960603.5, 19960604.5, 19960605.5;
</pre>
</i>
<p>

<p><br><i><b>An absolute time axis for monthly means, encoded in days:</b>

<pre>
  dimensions:
    time=3;
  variables:
    double time(time);
      time:bounds="bounds_time";
      time:long_name="time";
      time:units="days as %Y%m%d.%f";
    double bounds_time(time,2);
  data:
    time=19900215.0, 19900316.5, 19900416.0;
    bounds_time=19900201.0,19900301.0, 19900301.0,19900401.0,
                19900401.0,19900501.0;
</pre>
As in the relative time version of this example, 
the main time coordinates are the mid-points of their respective months.
Although they are encoded straightforwardly,
their values depend on the calendar.
If one was comparing means over these months from data sources which
used different calendars, that might be inconvenient,
and could be avoided as in the next example.
</i>
<p>

<p><br><i><b>An absolute time axis for monthly means, encoded in months:</b>

<pre>
  dimensions:
    time=3;
  variables:
    double time(time);
      time:bounds="bounds_time";
      time:long_name="year and seasonal phase";
      time:units="calendar_months as %Y%m.%f";
    double bounds_time(time,2);
  data:
    time=199002.5, 199003.5, 199004.5;
    bounds_time=199002.0,199003.0, 199003.0,199004.0, 199004.0,199005.0;
</pre>
This method shows directly that the main coordinates are half-way 
through their months.
</i>
<p>

<p><br><i><b>A partial time defining just the year:</b>
An axis of this kind could be used to record
the number of occurrences of a particular kind of event:

<pre>
  dimensions:
    year=3;
  variables:
    int year(year);
      year:long_name="year";
      year:units="calendar_year as %Y";
    int count(year);
  data:
    year=1991,1992,1993,1994,1995;
    count=0,2,1,0,1;
</pre>
As discussed above, this axis spans five years.
No boundaries are supplied, because each element of <i><tt>count</i></tt>
applies to just a single year.
Hence, both the upper and the lower <i><tt>year</i></tt> boundaries would be
equal to their <i><tt>year</i></tt>s.
</i>
<p>

<p><br><i><b>Year and seasonal phase defined in calendar years:</b>
By contrast to the last example, if it was appropriate to indicate that
each count applied to the whole of the continuous period of time of its
respective year, this could be done thus:

<pre>
  variables:
    double year(year);
      year:bounds="bounds_year";
      year:long_name="year and seasonal phase";
      year:units="calendar_year as %Y.%f";
    double bounds_year(year,2);
    int count(year);
  data:
    year=1991.5, 1992.5, 1993.5, 1994.5, 1995.5;
    bounds_year=1991.0,1992.0, 1992.0,1993.0, 1993.0,1994.0,
                1994.0,1995.0, 1995.0,1996.0;
    count=0,2,1,0,1;
</pre>
The use of floating-point years allows us conveniently to represent
exactly the beginning and ending of a year and a point half-way through.
In the standard calendar, of course, the interval from 1992.0 to 1993.0
is longer in relative time than all the other years.
But for some purposes, it might be more useful to record that each interval
is a calendar year.
This could be especially helpful when comparing data from different
calendars.
</i>
<p>

<p><br><i><b>Seasonal phase as a function of year:</b>
Here we show the date within the year of a particular event,
such as the highest daily
maximum temperature, or the onset of the monsoon, as a partial time
within its year.

<pre>
  dimensions:
    year=5;
  variables:
    int year(year);
      year:long_name="year";
      year:units="calendar_year as %Y";
    int date(year);
      date:long_name="seasonal phase";
      date:units="day as %m%d";
  data:
    year=2011, 2013, 2027, 2028, 2051;
    date=629, 627, 626, 703, 710;
</pre>
The event concerned occurred on 29th June 2011, 27th June 2013,
26th June 2027, 3rd July 2028 and 10th July 2051.
Clearly the date variable could have been encoded as a complete time,
perhaps in relative time units,
but this would have included redundant year information.
</i>
<p>
A time variable which indicates seasonal phase but not year has a
modulo of one year. If it spans the entire seasonal cycle, it also has
circular topology. Similarly, a time variable indicating diurnal phase
but not seasonal phase has a modulo of one day, and has circular
topology if it spans the entire diurnal cycle.
<i>These kinds of time coordinate are particular useful for
representing climatological time, in conjunction with other contracted
time axes. See section <A href="#multipletime">28</A>.</i>

<p>

<p><br><i><b>Average seasonal cycle expressed in months:</b>
Data for solar radiation as 3-monthly averages.

<pre>
  dimensions:
    time=4;
    lat=72;
    lon=96;
  variables:
    float sol(time,lat,lon);
      sol:axis="TYX";
      sol:long_name="vertical component of "
        "solar radiative flux density";
      sol:units="W m-2";
    float time(time); 
      time:bounds="bounds_time";
      time:long_name="seasonal phase";
      time:modulo=12.0f;
      time:topology="circular";
      time:units="calendar_month as %m.%f";
    float bounds_time(time,2);
  data:
    time=10.5, 13.5, 16.5, 19.5;
    bounds_time=9.0,12.0, 12.0,15.0, 15.0,18.0, 18.0,21.0;
</pre>
The first time point applies from the beginning of month 9 to the
beginning of month 12, i.e.&nbsp;September to November inclusive.
A representative main coordinate is given of half-way through October.
The second point runs to the beginning of month 15, which is equivalent
to 3 i.e.&nbsp;March under modulo 12, and thus covers December to February.
The use of the modulo allows the main coordinate to be specified as
monotonic, as is generally required. Because the axis is also circular,
it would be permissible to rotate the values in order to begin with a
different season.
</i>
<p>

<p><br><i><b>Average seasonal cycle expressed in years:</b> The time
coordinate above could equally well be given in calendar years, thus:

<pre>
  dimensions:
    double time(time); 
      time:bounds="bounds_time";
      time:long_name="seasonal phase";
      time:modulo=1.0;
      time:topology="circular";
      time:units="calendar_year as .%f";
    float bounds_time(time,2);
  data:
    time=0.7917, 1.0417, 1.2917, 1.5417;
    bounds_time=0.6667,0.9167, 0.9167,1.1667,
                1.1667,1.4167, 1.4167,1.6667;
</pre>
Here, the periods have been constructed as exactly quarters of a
year, beginning two-thirds of the way through the year.
In the 360-day calendar, this is identical to the last example, of
periods of three months starting at the beginning of September,
but in the standard calendar it is slightly different,
since a quarter of a year is not exactly three calendar months.
</i>
<p>
        <H2><A NAME="tth_sEc26">
26</A>&nbsp;&nbsp;Gregorian calendar</H2>
<A NAME="gregorian">
</A>

<p>
This standard recommends that Gregorian times be given in
units of
<tt>days as %Y%m%d.%f</tt> with data type <tt>double</tt>
(section <A href="#absolutetime">25</A>),
unless compatibility is essential with applications that cannot process
absolute times.
In that case, Gregorian times may have units of time
formatted as per the recommendations of the Unidata udunits package,
which specify a unit and a reference time, i.e.&nbsp;a relative time
(section <A href="#relativetime">24</A>).
The recommended unit is <tt>days</tt>, with data type <tt>double</tt>.

<p>
Intervals between two times in the standard
Gregorian calendar can be calculated by the Unidata udunits package.
<i>Udunits implements the mixed Gregorian/Julian calendar system,
as followed in England, in which
dates prior to 1582-10-15 are assumed to use the Julian calendar.
Other software cannot be relied upon to handle the change of calendar
in the same way, so for robustness it is recommended that the reference
date be later than 1582.
If earlier dates must be used, it should be noted that
udunits treats 0 AD as identical to 1 AD.</i>

<p>
<i>Data type <i><tt>double</i></tt> gives a precision of about
16 decimal digits,
which means that it can resolve tenths of a second
for years of up to O(1 million) in relative times.
The precision of absolute times is an order of magnitude worse,
since a year looks like 10&nbsp;000 days, rather than 365.
The larger the year, the worse the absolute precision.
If very large years are needed and the precision is not sufficient,
the reference year will have to be modified to keep the interval
small enough.</i>

<p>
If there is no <tt>calendar</tt> attribute applying to
a time variable,
the values are assumed to be in the normal Gregorian calendar.
This can be made explicit by setting <tt>calendar</tt> to <tt>standard</tt>
or <tt>gregorian</tt>.

<p>
        <H2><A NAME="tth_sEc27">
27</A>&nbsp;&nbsp;Non-Gregorian calendars</H2>
<A NAME="othercalendars">
</A>

<p>
It is recommended that
times in other calendars should be encoded in units of
<tt>days as %Y%m%d.%f</tt> with data type <tt>double</tt>
(section <A href="#absolutetime">25</A>).
Relative times are permitted, the recommended <tt>units</tt> being
<tt>days since 1-1-1</tt> (midnight on 1 January of year 1),
with data type <tt>double</tt>.
Since the Unidata udunits package can process only
the standard calendar,
an extension will be required to process relative times 
for other calendars.

<p>
Apart from the Gregorian,
calendars recognised by this standard are
<tt>julian</tt> for the Julian calendar (in which all years divisible
by four are leap years),
<tt>noleap</tt> for a calendar with 365 days in every year,
and <tt>360</tt> when each month has 30 days in every year.
If any other calendar is used, a suitable description should appear
in the <tt>calendar</tt> attribute,
but generic applications cannot be expected to be able to encode and
decode relative times or calculate intervals in the calendar concerned.

<p>
        <H2><A NAME="tth_sEc28">
28</A>&nbsp;&nbsp;Multiple time axes and climatological time</H2>
<A NAME="multipletime">
</A>

<p>
There is no bar on a data variable having more than one
dimension in
a particular quantity, so long as the dimensions have different names.
A particular use of this is to decompose time
into multiple partial time dimensions (section <A href="#absolutetime">25</A>),
of which one or may be collapsed (section <A href="#contractions">22</A>).
This gives a method of indicating disjoint intervals of time
belonging to corresponding parts of the seasonal or diurnal cycles.
When a variable has two or three time axes,
the first interval of time which they cover is assumed to begin
at the earliest boundary values of all the axes.
If there is an uncollapsed axis in combination with collapsed axes,
it is a ``climatological time'' axis.
<i>There may be more than one-see below for an example.</i>

<p>
<i>COARDS recommends use of year 0 to indicate climatological time.
We do not favour this convention.
Firstly, it does not provide any way of recording which years were used
to make the climatology.
Secondly, udunits treats year 0 and year 1 as identical
(which is reasonable because year 0 does not exist-there is
no year between 1 AD and 1 BC).</i>

<p>

<p><br><i><b>A mean of a corresponding months in a number of years:</b>
A longitude-latitude precipitation field with time axes
to indicate the mean over the months of January in 1961 to 1990 inclusive:

<pre>
  dimensions:
    con_year=1;
    year=30;
    month=1;
  variables:
    float precipitation(con_year,month,lat,lon);
      precipitation:axis="-TYX";
      precipitation:subgrid="month: mean con_year: mean";
    int con_year(con_year);
      con_year:bounds="bounds_con_year";
      con_year:expand="year";
      con_year:long_name="year";
      con_year:old_interval=1;
      con_year:units="calendar_year as %Y";
    int bounds_con_year(con_year,2);
    int year(year);
    float month(month);
      month:bounds="bounds_month";
      month:long_name="seasonal phase";
      month:units="calendar_month as %m.%f";
    float bounds_month(month,2);
  data:
    con_year=1975;
    bounds_con_year=1961, 1990;
    year=1961, 1962, 1963, ..., 1990;
    month=1.5;
    bounds_month=1.0, 2.0;
</pre>
The representative year is not likely to be particularly useful in
this case; the important information is the boundaries, which indicate
the range of years used to form the climatological mean.
These years are also given explicitly, and optionally, for reference.
Since the <i><tt>con_year</i></tt> axis has a discrete form of time (<i><tt>%.f</i></tt> does
not appear in the time-string-see section&nbsp;<A href="#absolutetime">25</A>),
we have to include both ends of the axis in working out how many years are
involved in the mean:
<i><tt>bounds_con_year</i></tt> tells us that years from 1961 to 1990 were used,
which comes to 30 years, counting both 1961 and 1990.

<p>
Suppose we wish to include in the same data variable the mean over Decembers
from 1960 to 1989.
To do this, we give the <i><tt>month</i></tt> variable <i><tt>modulo=12.0f</i></tt>,
which previously was not needed, change the dimension to <i><tt>month=2</i></tt> and
the data to

<pre>
    month=0.5, 1.5;
    bounds_month=0.0,1.0, 1.0,2.0;
</pre>
According to the convention, the earliest time indicated by the combined axes
is the lower boundary of all of them, which is the start of the 0th month of
1961, equivalent to the start of the 12th month of 1960 under modulo 12.
Alternatively, we could have

<pre>
    bounds_con_year=1960,1989;
    month=12.5, 13.5;
    bounds_month=12.0,13.0, 13.0,14.0;
</pre>
This is exactly equivalent. The last January used ends at the start of the 14th
month of 1989, which is the start of February 1990, as before.

<p>
There is no standardised way to indicate missing months from the mean, say
December 1974 in this case,
except to include <i><tt>con_year:old_spacing="disjoint"</i></tt>.
The information could be included as a note in the <i><tt>subgrid</i></tt> attribute, thus
<i><tt>"con_year: mean (December 1974 missing)"</i></tt>.
</i>
<p>

<p><br><i><b>Climatological seasonal means for several decades:</b>
This is an extension of the previous case,
and of the
example of an average seasonal cycle in section <A href="#absolutetime">25</A>.
Here, the axes are set up
to indicate climatological means for two of the seasons
in three successive decades.

<pre>
  dimensions:
    decade=3;
    season=2;
  variables:
    float precipitation(decade,season,lat,lon);
      precipitation:axis="-TYX";
      precipitation:subgrid="season: mean decade: mean";
    int decade(decade);
      decade:bounds="bounds_decade";
      decade:old_interval=1;
      decade:units="calendar_year as %Y";
    int bounds_decade(decade,2);
    int season(season);
      season:bounds="bounds_season";
      season:calendar="standard";
      season:modulo=1200;
      season:units="day as %m%d";
    int bounds_season(season,2);
  data:
    decade=1966, 1976, 1986;
    bounds_decade=1961,1970, 1971,1980, 1981,1990;
    season=115, 415;
    bounds_season=1,228, 301,531;
</pre>
Here, <i><tt>precipitation[0][0][*][*]</i></tt> is the data for December-February
(i.e.&nbsp;1 December to 28 February inclusive)
of the decade 1960-1970 (first December in 1960, last February in 1970),
while <i><tt>[2][1][*][*]</i></tt> is March-May 1981-1990.
The choice has been made to give the seasonal phase in months and days,
rather than months alone;
hence the modulo is 1200 rather than 12.
Under modulo 1200, midnight on 1 December can be expressed equivalently
as 1 or 1201.
If 1201 were specified, it would mean that the first interval of time
began on 1 December 1961 (rather than 1960),
taking the combination of the lower boundaries of both time axes;
the value 1 is a year earlier.
The drawback of this <i><tt>%m%d</i></tt> scheme
is that it is awkward or impossible to give accurate
representative dates for the middle of the periods, especially since
February has variable length.
The absolute time format <i><tt>%m.%f</i></tt> for seasonal phase
is better from this point of view.
The season axis is not shown as having circular topology because no
information is implied about the other two seasons.
</i>
<p>

<p><br><i><b>Average early June maximum temperatures for several years:</b>
In this example, the dimensions indicate that
maximum daily temperatures (between 9 a.m.&nbsp;on the day
of record and 9 a.m.&nbsp;of the previous day) were recorded for 1-10 June,
and an average maximum found for these ten days in
each of the years 1980-1984.

<pre>
  dimensions:
    year=5;
    con_season=1;
    con_day=1;
  variables:
    float temperature(year,con_season,con_day);
      temperature:axis="T--";
      temperature:subgrid="con_day: maximum con_season: mean";
    int year(year);
      year:long_name="year";
      year:units="calendar_year as %Y";
    int con_season(con_season);
      con_season:bounds="bounds_con_season";
      con_season:long_name="seasonal phase";
      con_season:old_interval=1;
      con_season:units="day as %m%d";
    int bounds_con_season(con_season,2);
    float con_day(con_day);
      con_day:bounds="bounds_con_day";
      con_day:long_name="diurnal phase";
      con_day:modulo=24.0f;
      con_day:units="hour as %H.%f";
    float bounds_con_day(con_day,2);
  data:
    year=1980, 1981, 1982, 1983, 1984;
    con_season=605;
    bounds_con_season=601, 610;
    con_day=-3.0;
    bounds_con_day=-15.0, 9.0;
</pre>
The diurnal phase of -15&nbsp;h means 15 hours before the beginning 
of the day in question, i.e.&nbsp;9 a.m.&nbsp;on the previous day.
No bounds are given for the year, because it is a discrete quantity,
and there is no further information which could be added.
But if the five years were averaged together, this would collapse the year
axis, and the extreme years of 1980 and 1984 would be recorded as
the boundaries of the collapsed axis.
If, say, 1981 were not used in forming the average,
the collapsed axis would have attribute <i><tt>old_spacing="disjoint"</i></tt>.
</i>
<p>
    
<p><br><i><b>Daily values as an average of subdaily values:</b>
Instantaneous pressure measurements are made at intervals of 3 hours
(first measurement at midnight)
throughout the days 6 May to 9 June 1937,
and daily means formed from midnight to midnight.

<pre>
  dimensions:
    con_subday=1;
    day=35;
  variables:
    float pressure(day,con_subday);
      pressure:axis="T-";
      pressure:subgrid="con_subday: point con_subday: mean";
    float con_subday(con_subday);
      con_subday:bounds="bounds_con_subday";
      con_subday:long_name="diurnal phase";
      con_subday:old_interval=0.125f;
      con_subday:old_spacing="uniform";
      con_subday:units="days as .%f";
    float bounds_con_subday(con_subday,2);
    int day(day);
      day:long_name="year and seasonal phase";
      day:units="days as %Y%m%d";
  data:
    con_subday=0.5;
    bounds_con_subday=0.0, 0.875;
    day=19370506, 19370507, ..., 19370608, 19370609;
</pre>
Note that the <i><tt>con_subday</i></tt> axis is shown with two
subgrid methods, referring to subgrid variation before
and after its collapse.
The only point here in having separate axes for day and diurnal phase
is to show when the first and last instantaneous measurements were made
in each day.
If this is not important to record, the two axes could be merged together
thus:

<pre>
  dimensions:
    day=35;
  variables:
    float pressure(day);
      pressure:subgrid="day: point day: mean";
    float day(day);
      con_subday:bounds="bounds_day";
      con_subday:old_interval=0.125f;
      con_subday:long_name="time";
      con_subday:old_spacing="uniform";
      con_subday:units="days as %Y%m%d.%f";
    float bounds_day(day,2);
  data:
    day=19370506.5, 19370507.5, ..., 19370608.5, 19370609.5;
    bounds_day=19370506.0,19370507.0, 19370507.0,19370508.0, ...,
               19370608.0,19370609.0, 19370609.0,19370610.0;
</pre>
If the 35 days were then averaged together,
the date axis would collapse with bounds of 19370506.0 and 19370610.0.
The <i><tt>subgrid</i></tt> attribute would not need modification since
it is already shown as a mean over the <i><tt>day</i></tt> axis.
</i>
<p>

<p><br><i><b>Average diurnal cycle:</b> 
The following axes are appropriate for
the average diurnal cycle of
precipitation rate in July 1970-1979 as a function of latitude:

<pre>
  dimensions:
    con_year=1;
    con_month=1;
    hour=8;
    lat=45;
    con_lon=1;
  variables:
    float ppnrate(con_year,con_month,hour,lat,con_lon);
      ppnrate:axis="--TYX";
      ppnrate:subgrid="con_lon: mean con_month: mean "
        "con_year: mean";
      ppnrate:units="kg m-2 s-1";
    int con_year(con_year);
      con_year:bounds="bounds_con_year";
      con_year:old_interval=1;
      con_year:units="calendar_year as %Y";
    int bounds_con_year(con_year,2);
    float con_month(con_month);
      con_month:bounds="bounds_con_month";
      con_month:units="calendar_month as %m.%f";
    float bounds_con_month(con_month,2);
    float hour(hour);
      hour:bounds="bounds_hour";
      hour:modulo=24.0f;
      hour:topology="circular";
      hour:units="hour as %H.%f";
    float bounds_hour(bounds_hour,2);
  data:
    con_year=1975;
    bounds_con_year=1970, 1979;
    con_month=7.5;
    bounds_con_month=7.0, 8.0;
    hour=1.5, 4.5, 7.5, 10.5, 13.5, 16.5, 19.5, 22.5;
    bounds_hour=0.0,3.0, 3.0,6.0, 6.0,9.0, 9.0,12.0,
                12.0,15.0, 15.0,18.0, 18.0,21.0, 21.0,24.0;
</pre>
</i>
<p>
        <H2><A NAME="tth_sEc29">
29</A>&nbsp;&nbsp;Invalid values in a data variable</H2>
<A NAME="invalid">
</A>

<p>
Invalid values are any which fall
outside the valid range or equal the fill value, as indicated by the
Unidata-standard attributes described here. An invalid value indicates bad data
i.e.&nbsp;a software problem, which is a different circumstance from unknown or
missing data (see section&nbsp;<A href="#missing">30</A>).
Invalid values are not permitted in a coordinate variable,
but the attributes which define the valid range may be used in boundary
variables (section <A href="#boundary">20</A>) to indicate unbounded cells.

<p>
The attribute <tt>valid_min</tt> is a scalar specifying the
minimum valid value for a variable.  The attribute <tt>valid_max</tt> specifies
the maximum valid value, while <tt>valid_range</tt> is a vector of two numbers
specifying the minimum and maximum valid values, in that order, equivalent to
specifying values for both <tt>valid_min</tt> and <tt>valid_max</tt>
attributes. Any of these attributes define the valid range.  The attribute <tt>
valid_range</tt> must not be defined if either <tt>valid_min</tt> or <tt>
valid_max</tt> is defined. Generic applications should treat values outside the
valid range as invalid. The type of each <tt>valid_range</tt>, <tt>valid_min</tt>
and <tt>valid_max</tt> attribute should match the type of its variable.  <i>The
Unidata special treatment of <i><tt>byte</i></tt> type is not included here as we do not
recommend use of that type (see section <A href="#datatype">3</A>).</i>

<p>
A scalar attribute with the name <tt>_FillValue</tt> and of the
same type as its variable is used as the fill value for the variable.  The
netCDF package defines a default fill value for each type of variable, so it is
not necessary to define your own <tt>_FillValue</tt> attribute if the default is
suitable.  The purpose of the fill value is to save the applications programmer
the work of prefilling the data and also to eliminate the duplicate writes that
result from netCDF filling in undefined data with its default fill value,
only to be immediately overwritten by the programmer's preferred value. This
value is considered to be a special value that indicates undefined data, and is
returned when reading values that were not written.  The <tt>_FillValue</tt>
should be outside the range specified by <tt>valid_range</tt> (if used) for a
variable.
In cases where the data variable is packed using the <tt>
scale_factor</tt> and <tt>add_offset</tt> attributes (section <A href="#pack">32</A>), the
<tt>_FillValue</tt> attribute applies the numbers as packed, so they must be
checked against it before unpacking.

<p>
If none of <tt>valid_min</tt>, <tt>valid_max</tt> or <tt>valid_range</tt>
is defined then generic applications should define a valid range by using the
fill value (whether defined explicitly or by default); if the fill value is
positive then it defines a valid maximum, otherwise it defines a valid
minimum. For integer types, there should be a difference of 1 between the fill
value and this valid minimum or maximum. For floating point types, the valid
extreme should have a magnitude which is half the magnitude of the fill value.
<i>We recommend a factor of two, rather than a difference of one bit, because
it is easier for applications programmers.  There is no special treatment for
<i><tt>byte</i></tt> as we do not recommend that type (see section <A href="#datatype">3</A>).</i>

<p>
        <H2><A NAME="tth_sEc30">
30</A>&nbsp;&nbsp;Missing values in a data variable</H2>
<A NAME="missing">
</A>

<p>
Missing values are not permitted in a coordinate variable, so this
section applies only to data variables. The <tt>missing_value</tt> attribute
indicates a value that is used for data that are unknown or ``missing''. This
attribute is not be treated in any special way by the netCDF API, unlike the
<tt>_FillValue</tt> attribute (section <A href="#invalid">29</A>).
The <tt>missing_value</tt> should be outside the valid range
(section <A href="#invalid">29</A>), so that generic applications will treat it
appropriately.
The netCDF data type of
the <tt>missing_value</tt> attribute should match the netCDF data type of the
data variable that it describes. In cases where the data variable is packed via
the <tt>scale_factor</tt> and <tt>add_offset</tt> attributes (section <A href="#pack">32</A>),
the <tt>missing_value</tt> attribute
matches the type of and should be compared with the data
after unpacking.
<i>This standard is unlike COARDS in giving
a particular interpretation to the
distinction between <i><tt>missing_value</i></tt> and <i><tt>_FillValue</i></tt>.</i>

<p>
        <H2><A NAME="tth_sEc31">
31</A>&nbsp;&nbsp;Compression by gathering</H2>
<A NAME="gather">
</A>

<p>
To save space in the netCDF file,
it may be desirable to eliminate points
from data arrays which are invariably missing.
Such a compression can operate over one or more adjacent axes,
and is accomplished with reference to a list of
the points to be stored.
The list is constructed by considering a mask array which has just the
axes to be compressed,
and mapping this array onto one dimension without reordering.
The list is the set of indices
in this one-dimensional mask of the required points.
In the compressed array,
the axes to be compressed are all replaced by a single axis,
whose dimension is the number of wanted points.
The wanted points appear along this dimension in the same order they
appear in the uncompressed array, with the unwanted points skipped over.
Compression and uncompression are executed by looping over the list.

<p>
The list is stored as the
coordinate variable for the compressed axis of the data array.
Thus, the list variable and its dimension have the same name.
The list variable has a string attribute <tt>compress</tt>,
containing a blank-separated list of the dimensions which were affected
by the compression in the order of the CDL declaration of the
uncompressed array.
The presence of this attribute identifies the list variable as such.
The list, the original dimensions and coordinate variables
(including component, associated and boundary variables),
and the compressed data variables with all the attributes
of the uncompressed variables
are written to the archived netCDF file.
The uncompressed data variables can be reconstituted
exactly as they were
using this information,
except that their original variable names are not known.

<p>

<p><br><i><b>Horizontal compression of a three-dimensional array:</b>
We eliminate sea points at all depths
in a longitude-latitude-depth array of soil temperatures.
In this case, only the longitude and latitude axes would be affected
by the compression.
We construct a list <i><tt>landpoint(landpoint)</i></tt>
containing the indices of land points.

<pre>
  dimensions:
    lat=73;
    lon=96;
    landpoint=2381;
    depth=4;
  variables:
    long landpoint(landpoint);
      landpoint:compress="lat lon";
    float landsoilt(depth,landpoint);
      landsoilt:axis="Z-";
      landsoilt:long_name="soil temperature";
      landsoilt:units="K";
    float depth(depth);
    float lat(lat);
    float lon(lon);
  data:
    landpoint=363, 364, 365, ...;
</pre>
Since <i><tt>landpoint[0]=363</i></tt>, for instance,
we know that <i><tt>landsoilt[*][0]</i></tt>
maps on to point 363 of the original data with dimensions <i><tt>(lat,lon)</i></tt>.
This corresponds to indices <i><tt>[3][75]</i></tt>.
</i>
<p>

<p><br><i><b>Compression of a three-dimensional field:</b> 
We compress a longitude-latitude-depth field of ocean
salinity by eliminating points below the sea-floor.
In this case, all three dimensions are affected by the compression,
since there are successively fewer active ocean points at increasing
depths.

<pre>
  variables:
    float salinity(oceanpoint);
      salinity:axis="-";
    long oceanpoint(oceanpoint);
      oceanpoint:compress="depth lat lon";
    float depth(depth);
    float lat(lat);
    float lon(lon);
</pre>
This information implies that the salinity field should be
uncompressed to an array with dimensions <i><tt>(depth,lat,lon)</i></tt>.
</i>
<p>
        <H2><A NAME="tth_sEc32">
32</A>&nbsp;&nbsp;Compression using a scale and offset</H2>
<A NAME="pack">
</A>

<p>
This standard
endorses the use of the optional Unidata-standard attributes
<tt>scale_factor</tt> and <tt>add_offset</tt>
for data and coordinate variables.
These attributes
can be used to provide simple number compression (packing),
to store low-resolution
floating-point data as small integers in a netCDF file.
After the data values of the variable have been read in,
they are to be multiplied by the <tt>scale_offset</tt>,
and have <tt>add_offset</tt> added to them.
If both <tt>scale_factor</tt> and <tt>add_offset</tt> attributes are present, the
data are scaled before the offset is added.
When scaled data are
written, the application should first subtract the offset and then divide by
the scale factor.
This procedure is concerned only with storage.
It does not affect the unit of the quantity.
<i>For instance, a pressure variable with values in the range
900.0-1100.0&nbsp;Pa
could be converted to short integers in the range
<font face=symbol>±</font
>20000
by subtracting 1000 and dividing by 0.005 i.e.&nbsp;multiplying by 200.
The units of the compressed variable are still recorded as pascals.</i>

<p>
This standard is more restrictive than the netCDF Users'
Guide with respect to the use of the <tt>scale_factor</tt> and <tt>add_offset</tt>
attributes; ambiguities and precision problems related to data type conversions
are resolved by these restrictions. If the <tt>scale_factor</tt> and <tt>
add_offset</tt> attributes are of the same data type as the associated variable no
restrictions apply; the unpacked data is assumed to be of the same data type as
the packed data. However, if the <tt>scale_factor</tt> and <tt>add_offset</tt>
attributes are of a different data type from the variable
(containing the packed data) then in files adhering to this standard the
variable may only be of type <tt>short</tt> or <tt>long</tt>.  <i>We
exclude <i><tt>byte</i></tt> on grounds discussed in section <A href="#datatype">3</A>.</i> The
attributes <tt>scale_factor</tt> and <tt>add_offset</tt> (which must match in data
type) must be of type <tt>float</tt> or <tt>double</tt>. The data type of the
attributes should match the intended type of the unpacked data. (It is not
advised to unpack a <tt>long</tt> into a <tt>float</tt> as there is a potential
precision loss.)  <i>Users should note that Unidata may provide a built-in
means of packing data in netCDF files in future.</i>

<p>
        <H2><A NAME="tth_sEcA">
A</A>&nbsp;&nbsp;Attributes</H2>

<p>

<center>
<table border>
<tr><td>Attribute </td><td>T </td><td>Use </td><td>Section(s) </td><td width="200">Description </td>
<tr><td><tt>add_offset</tt> </td><td>N </td><td>CD </td><td><A href="#invalid">29</A> <A href="#pack">32</A> </td><td width="200">Additive offset for packing data </td>
<tr><td><tt>appendices</tt> </td><td>S </td><td>G </td><td><A href="#global">5</A>
  </td><td width="200">Version number of these appendices </td>
<tr><td><tt>associate</tt> </td><td>S </td><td>CD
  </td><td><A href="#associated">18</A> <A href="#bundles">19</A> </td><td width="200">Identifies variables
  containing alternative sets of coordinates </td>
<tr><td><tt>axis</tt> </td><td>S </td><td>D
  </td><td><A href="#dimensionality">9</A> <A href="#vertical">16</A> <A href="#associated">18</A> </td><td width="200">Identifies spatiotemporal dimensions </td>
<tr><td><tt>bounds</tt> </td><td>N </td><td>C
  </td><td><A href="#boundary">20</A> <A href="#contractions">22</A> <A href="#multipletime">28</A>
  </td><td width="200">Identifies a bounday variable </td>
<tr><td><tt>calendar</tt> </td><td>S </td><td>GD </td><td><A href="#global">5</A> <A href="#time">23</A> <A href="#gregorian">26</A> 
  <A href="#othercalendars">27</A> </td><td width="200">Calendar used for encoding time axes </td>
<tr><td><tt>comment</tt> </td><td>S </td><td>G </td><td><A href="#global">5</A>
  </td><td width="200">Additional information about the file </td>
<tr><td><tt>component</tt> </td><td>S </td><td>CD
  </td><td><A href="#component">17</A> <A href="#boundary">20</A> </td><td width="200">Identifies variables containing
  components of a variable </td>
<tr><td><tt>compress</tt> </td><td>S </td><td>D </td><td><A href="#gather">31</A> </td><td width="200">Records dimensions which have been compressed by gathering </td>
<tr><td><tt>Conventions</tt> </td><td>S </td><td>G
  </td><td><A href="#global">5</A> </td><td width="200">Identifies the netCDF standard </td>
<tr><td><tt>coordinates</tt> </td><td>S </td><td>CD
  </td><td><A href="#associated">18</A> </td><td width="200">Synonym for <tt>associate</tt> </td>
<tr><td><tt>expand</tt> </td><td>S </td><td>C
  </td><td><A href="#contractions">22</A> <A href="#multipletime">28</A> </td><td width="200">Coordinates
  before contraction </td>
<tr><td><tt>_FillValue</tt> </td><td>N </td><td>D
  </td><td><A href="#invalid">29</A> </td><td width="200">Indicator of invalid data </td>
<tr><td><tt>FORTRAN_format</tt> </td><td>S </td><td>CD
  </td><td><A href="#quantity">12</A> </td><td width="200">Format for a variable </td>
<tr><td><tt>history</tt> </td><td>S </td><td>GD </td><td><A href="#global">5</A> <A href="#quantity">12</A>
  </td><td width="200">Evolution of the data in the file </td>
<tr><td><tt>institution</tt> </td><td>S </td><td>GD </td><td><A href="#global">5</A> <A href="#quantity">12</A>
  </td><td width="200">Who made or supplied the data </td>
<tr><td><tt>long_name</tt> </td><td>S </td><td>CD </td><td><A href="#quantity">12</A> </td><td width="200">Long
  description of a physical quantity </td>
<tr><td><tt>modulo</tt> </td><td>N </td><td>CD
  </td><td><A href="#quantity">12</A> <A href="#longitude">14</A> <A href="#absolutetime">25</A> </td><td width="200">Arithmetic
  modulo of a variable </td>
<tr><td><tt>north_pole</tt> </td><td>N </td><td>D
  </td><td><A href="#systems">10</A> </td><td width="200">Long.,lat.&nbsp;of rotated
  North Pole </td>
<tr><td><tt>old_interval</tt> </td><td>N </td><td>C </td><td><A href="#contractions">22</A> <A href="#multipletime">28</A> </td><td width="200">The typical separation between points on an axis before contraction </td>
<tr><td><tt>old_spacing</tt> </td><td>S </td><td>C
  </td><td><A href="#contractions">22</A> <A href="#multipletime">28</A> </td><td width="200">Indicates the spacing
  of points along an axis before contraction </td>
<tr><td><tt>positive</tt> </td><td>S </td><td>CD </td><td><A href="#quantity">12</A> <A href="#longitude">14</A> <A href="#latitude">15</A>
  <A href="#vertical">16</A> </td><td width="200">Sense of positive for a variable referring to a spatial direction </td>
<tr><td><tt>production</tt> </td><td>S </td><td>GD </td><td><A href="#global">5</A> <A href="#quantity">12</A>
  </td><td width="200">How the data was produced </td>
<tr><td><tt>quantity</tt> </td><td>S </td><td>CD </td><td><A href="#quantity">12</A> </td><td width="200">Standardised
  description of a physical quantity </td>
<tr><td><tt>quantity_table</tt> </td><td>S </td><td>G </td><td><A href="#global">5</A> <A href="#quantity">12</A>
  </td><td width="200">URL of the quantity table </td>
<tr><td><tt>scale_factor</tt> </td><td>N </td><td>CD </td><td><A href="#invalid">29</A> <A href="#pack">32</A> </td><td width="200">Multiplicative factor for packing data </td>
<tr><td><tt>subgrid</tt> </td><td>S </td><td>D
  </td><td><A href="#subgrid">21</A> <A href="#contractions">22</A> <A href="#multipletime">28</A> </td><td width="200">Records how the data values represent subgrid variation </td>
<tr><td><tt>topology</tt> </td><td>S </td><td>C
  </td><td><A href="#topology">13</A> <A href="#longitude">14</A> <A href="#absolutetime">25</A> </td><td width="200">Topology
  of an axis (circular or not) </td>
<tr><td><tt>time_format</tt> </td><td>S </td><td>CD
  </td><td><A href="#time">23</A> </td><td width="200">Format for printing a time and date </td>
<tr><td><tt>units</tt> </td><td>S </td><td>CD </td><td><A href="#quantity">12</A> <A href="#longitude">14</A> <A href="#latitude">15</A>
  <A href="#time">23</A>-<A href="#othercalendars">27</A> </td><td width="200">Units of a physical quantity </td>
<tr><td><tt>valid_max</tt> </td><td>N </td><td>CD
  </td><td><A href="#boundary">20</A> <A href="#invalid">29</A> </td><td width="200">Largest valid value of a
  variable </td>
<tr><td><tt>valid_min</tt> </td><td>N </td><td>CD
  </td><td><A href="#boundary">20</A> <A href="#invalid">29</A> </td><td width="200">Smallest valid value of a
  variable </td>
<tr><td><tt>valid_range</tt> </td><td>N </td><td>CD
  </td><td><A href="#invalid">29</A> </td><td width="200">Smallest and largest valid values
  of a variable </td></table>
</center>

<p>
<b>T</b> is <b>S</b> for string, <b>N</b> for numeric.

<p>
<b>Use</b> is composed of <b>G</b> for global,
<b>C</b> for coordinate variables (including multidimensional
coordinate variables), <b>D</b> for data variables.

<p>
        <H2><A NAME="tth_sEcB">
B</A>&nbsp;&nbsp;Methods of representing subgrid variation</H2>

<p>
See section&nbsp;<A href="#subgrid">21</A>.

<p>

<center>
<table border>
<tr><td>Method </td><td>Units </td><td>Description </td>
<tr><td><tt>cell</tt> </td><td>u </td><td>Value is a property of the whole cell (e.g. an integral) </td>
<tr><td><tt>correlation</tt> </td><td>1 </td><td>Pearson product-moment correlation coefficient </td>
<tr><td><tt>covariance</tt> </td><td>uv </td><td>Covariance </td>
<tr><td><tt>maximum</tt> </td><td>u </td><td>Maximum </td>
<tr><td><tt>median</tt> </td><td>u </td><td>Median </td>
<tr><td><tt>mid-range</tt> </td><td>u </td><td>Average of maximum and minimum </td>
<tr><td><tt>minimum</tt> </td><td>u </td><td>Minimum </td>
<tr><td><tt>mean</tt> </td><td>u </td><td>Mean (average) </td>
<tr><td><tt>mean square</tt> </td><td>u<sup>2</sup> </td><td>Mean (average) square </td>
<tr><td><tt>mode</tt> </td><td>u </td><td>Mode (most common) </td>
<tr><td><tt>point</tt> </td><td>u </td><td>Value applies at gridpoint </td>
<tr><td><tt>range</tt> </td><td>u </td><td>Absolute difference between maximum and minimum </td>
<tr><td><tt>root mean square</tt> </td><td>u </td><td>Square-root of mean square </td>
<tr><td><tt>standard deviation</tt> </td><td>u </td><td>Standard deviation (RMS deviation from
the mean) </td>
<tr><td><tt>variance</tt> </td><td>u<sup>2</sup>
</td><td>Variance (mean-square deviation from the mean) </td></table>
</center>

<p>
<b>Units:</b> u means the units of the quantity whose
subgrid variation is represented by this method,
v the units of the second quantity when two quantities are combined.

<p>
        <H2><A NAME="tth_sEcC">
C</A>&nbsp;&nbsp;Modifications to <tt>udunits.dat</tt></H2>

<p>
See section&nbsp;<A href="#units">11</A>.

<p>
The unit <tt>unity</tt> is defined as a dimensionless constant
equal to one.

<p>
The unit <tt>degrees</tt> is not permitted, because
it creates ambiguities when attempting to
differentiate longitude and latitude coordinate variables.
This unit does not appear in the current version
of the file.

<p>
The units <tt>calendar_month</tt> and <tt>calendar_year</tt>
are units of time, but cannot be converted into each other
or any other units of time,
except that multiples of 12 calendar months equal integral numbers
of calendar years. The units <tt>year</tt> and <tt>month</tt> are not allowed,
because they can cause confusion.

<p>
        <H2><A NAME="tth_sEcD">
D</A>&nbsp;&nbsp;Long names for quantities</H2>

<p>
See section&nbsp;<A href="#quantity">12</A>.
This Appendix is not yet available.
As well as existing as part of this standard,
it will be made available on the web.

<p>

<center>
<table border>
<tr><td>Version </td><td><tt>long_name</tt> </td><td><tt>units</tt> </td>
<tr><td>1.0 </td><td><tt>depth below the surface</tt> </td><td><tt>m</tt> </td>
<tr><td>1.0 </td><td><tt>height above the surface</tt> </td><td><tt>m</tt> </td>
<tr><td>1.0 </td><td><tt>latitude</tt> </td><td><tt>degree_north</tt> </td>
<tr><td>1.0 </td><td><tt>longitude</tt> </td><td><tt>degree_east</tt> </td>
<tr><td>1.0 </td><td><tt>pressure</tt> </td><td><tt>Pa</tt> </td>
<tr><td>1.0 </td><td><tt>soil temperature</tt> </td><td><tt>K</tt> </td>
<tr><td>1.0 </td><td><tt>specific humidity</tt> </td><td><tt>unity</tt> </td>
<tr><td>1.0 </td><td><tt>temperature</tt> </td><td><tt>K</tt> </td>
<tr><td>1.0 </td><td><tt>time</tt> </td><td><tt>s</tt> </td></table>
</center>

<p>

<b>Version:</b> The version of the appendices at which this
quantity was introduced.<br>
<b><tt>long_name</tt>:</b> Case, spaces and punctuation are not
significant in the <tt>long_name</tt>.

<p>

<P>
<HR>
<P><ADDRESS>
Jonathan Gregory | jmgregory@meto.gov.uk
</ADDRESS>
<ADDRESS>
Robert Drach | drach@llnl.gov
</ADDRESS>
<ADDRESS>
Simon Tett | sfbtett@meto.gov.uk
</ADDRESS>
<ADDRESS>
Karl Taylor | ktaylor@pcmdi.llnl.gov
</ADDRESS>
<P>
<A HREF="http://www.llnl.gov/disclaimer.html">LLNL Disclaimers</A>
<P>
UCRL-MI-127703


<p>

<p><hr><small>File translated from T<sub><font size="-1">E</font></sub>X by <a href="http://hutchinson.belmont.ma.us/tth/">T<sub><font size="-1">T</font></sub>H</a>, version 1.96.<br>On 15 Sep 1999, 16:47.</small>
</HTML>
